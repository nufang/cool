!function (t) {
    function e(i) {
        if (n[i])return n[i].exports;
        var r = n[i] = {exports: {}, id: i, loaded: !1};
        return t[i].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports
    }

    var n = {};
    return e.m = t, e.c = n, e.p = "", e(0)
}([function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    var r = n(1), a = i(r);
    (0, a.default)()
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function r(t) {
        if (t && t.__esModule)return t;
        var e = {};
        if (null != t)for (var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e.default = t, e
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var a = n(2), o = r(a), s = n(3), c = i(s), l = n(4), u = i(l), h = n(5), d = i(h), p = n(10), f = i(p), m = n(18), g = i(m), v = function () {
        c.default.scene = new o.Scene
    }, y = function () {
        c.default.renderer = new o.WebGLRenderer({alpha: !u.default.backgroundColor}), c.default.renderer.setPixelRatio(u.default.mobile ? 1 : window.devicePixelRatio), c.default.renderer.setSize(window.innerWidth, window.innerHeight), c.default.renderer.gammaInput = !0, c.default.renderer.gammaOutput = !0, document.body.appendChild(c.default.renderer.domElement)
    }, _ = function () {
        c.default.camera = new o.PerspectiveCamera(u.default.camera.fov, u.default.camera.aspect, u.default.camera.near, u.default.camera.far), c.default.camera.position.set(0, 35, 0), c.default.camera.lookAt(new o.Vector3(0, 0, 0))
    };
    e.default = function () {
        v(), y(), _(), (0, d.default)(), (0, f.default)(), (0, g.default)()
    }
}, function (t, e, n) {
    !function (t, n) {
        n(e)
    }(this, function (t) {
        "use strict";
        function e() {
        }

        function n(t, e) {
            this.x = t || 0, this.y = e || 0
        }

        function i(t, e, r, a, o, s, c, l, u, h) {
            Object.defineProperty(this, "id", {value: Ko++}), this.uuid = Qo.generateUUID(), this.name = "", this.image = void 0 !== t ? t : i.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : i.DEFAULT_MAPPING, this.wrapS = void 0 !== r ? r : Va, this.wrapT = void 0 !== a ? a : Va, this.magFilter = void 0 !== o ? o : Za, this.minFilter = void 0 !== s ? s : Qa, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== c ? c : fo, this.type = void 0 !== l ? l : $a, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : ko, this.version = 0, this.onUpdate = null
        }

        function r(t, e, n, i) {
            this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
        }

        function a(t, e, n) {
            this.uuid = Qo.generateUUID(), this.width = t, this.height = e, this.scissor = new r(0, 0, t, e), this.scissorTest = !1, this.viewport = new r(0, 0, t, e), n = n || {}, void 0 === n.minFilter && (n.minFilter = Za), this.texture = new i(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }

        function o(t, e, n) {
            a.call(this, t, e, n), this.activeCubeFace = 0, this.activeMipMapLevel = 0
        }

        function s(t, e, n, i) {
            this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
        }

        function c(t, e, n) {
            this.x = t || 0, this.y = e || 0, this.z = n || 0
        }

        function l() {
            this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function u(t, e, n, r, a, o, s, c, l, u) {
            t = void 0 !== t ? t : [], e = void 0 !== e ? e : Ua, i.call(this, t, e, n, r, a, o, s, c, l, u), this.flipY = !1
        }

        function h() {
            this.seq = [], this.map = {}
        }

        function d(t, e, n) {
            var i = t[0];
            if (i <= 0 || i > 0)return t;
            var r = e * n, a = es[r];
            if (void 0 === a && (a = new Float32Array(r), es[r] = a), 0 !== e) {
                i.toArray(a, 0);
                for (var o = 1, s = 0; o !== e; ++o)s += n, t[o].toArray(a, s)
            }
            return a
        }

        function p(t, e) {
            var n = ns[e];
            void 0 === n && (n = new Int32Array(e), ns[e] = n);
            for (var i = 0; i !== e; ++i)n[i] = t.allocTextureUnit();
            return n
        }

        function f(t, e) {
            t.uniform1f(this.addr, e)
        }

        function m(t, e) {
            t.uniform1i(this.addr, e)
        }

        function g(t, e) {
            void 0 === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
        }

        function v(t, e) {
            void 0 !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : void 0 !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
        }

        function y(t, e) {
            void 0 === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
        }

        function _(t, e) {
            t.uniformMatrix2fv(this.addr, !1, e.elements || e)
        }

        function x(t, e) {
            t.uniformMatrix3fv(this.addr, !1, e.elements || e)
        }

        function b(t, e) {
            t.uniformMatrix4fv(this.addr, !1, e.elements || e)
        }

        function w(t, e, n) {
            var i = n.allocTextureUnit();
            t.uniform1i(this.addr, i), n.setTexture2D(e || $o, i)
        }

        function M(t, e, n) {
            var i = n.allocTextureUnit();
            t.uniform1i(this.addr, i), n.setTextureCube(e || ts, i)
        }

        function E(t, e) {
            t.uniform2iv(this.addr, e)
        }

        function T(t, e) {
            t.uniform3iv(this.addr, e)
        }

        function S(t, e) {
            t.uniform4iv(this.addr, e)
        }

        function A(t) {
            switch (t) {
                case 5126:
                    return f;
                case 35664:
                    return g;
                case 35665:
                    return v;
                case 35666:
                    return y;
                case 35674:
                    return _;
                case 35675:
                    return x;
                case 35676:
                    return b;
                case 35678:
                    return w;
                case 35680:
                    return M;
                case 5124:
                case 35670:
                    return m;
                case 35667:
                case 35671:
                    return E;
                case 35668:
                case 35672:
                    return T;
                case 35669:
                case 35673:
                    return S
            }
        }

        function L(t, e) {
            t.uniform1fv(this.addr, e)
        }

        function R(t, e) {
            t.uniform1iv(this.addr, e)
        }

        function C(t, e) {
            t.uniform2fv(this.addr, d(e, this.size, 2))
        }

        function P(t, e) {
            t.uniform3fv(this.addr, d(e, this.size, 3))
        }

        function O(t, e) {
            t.uniform4fv(this.addr, d(e, this.size, 4))
        }

        function I(t, e) {
            t.uniformMatrix2fv(this.addr, !1, d(e, this.size, 4))
        }

        function U(t, e) {
            t.uniformMatrix3fv(this.addr, !1, d(e, this.size, 9))
        }

        function N(t, e) {
            t.uniformMatrix4fv(this.addr, !1, d(e, this.size, 16))
        }

        function D(t, e, n) {
            var i = e.length, r = p(n, i);
            t.uniform1iv(this.addr, r);
            for (var a = 0; a !== i; ++a)n.setTexture2D(e[a] || $o, r[a])
        }

        function F(t, e, n) {
            var i = e.length, r = p(n, i);
            t.uniform1iv(this.addr, r);
            for (var a = 0; a !== i; ++a)n.setTextureCube(e[a] || ts, r[a])
        }

        function B(t) {
            switch (t) {
                case 5126:
                    return L;
                case 35664:
                    return C;
                case 35665:
                    return P;
                case 35666:
                    return O;
                case 35674:
                    return I;
                case 35675:
                    return U;
                case 35676:
                    return N;
                case 35678:
                    return D;
                case 35680:
                    return F;
                case 5124:
                case 35670:
                    return R;
                case 35667:
                case 35671:
                    return E;
                case 35668:
                case 35672:
                    return T;
                case 35669:
                case 35673:
                    return S
            }
        }

        function z(t, e, n) {
            this.id = t, this.addr = n, this.setValue = A(e.type)
        }

        function G(t, e, n) {
            this.id = t, this.addr = n, this.size = e.size, this.setValue = B(e.type)
        }

        function k(t) {
            this.id = t, h.call(this)
        }

        function H(t, e) {
            t.seq.push(e), t.map[e.id] = e
        }

        function V(t, e, n) {
            var i = t.name, r = i.length;
            for (is.lastIndex = 0; ;) {
                var a = is.exec(i), o = is.lastIndex, s = a[1], c = "]" === a[2], l = a[3];
                if (c && (s |= 0), void 0 === l || "[" === l && o + 2 === r) {
                    H(n, void 0 === l ? new z(s, t, e) : new G(s, t, e));
                    break
                }
                var u = n.map, h = u[s];
                void 0 === h && (h = new k(s), H(n, h)), n = h
            }
        }

        function j(t, e, n) {
            h.call(this), this.renderer = n;
            for (var i = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r !== i; ++r) {
                var a = t.getActiveUniform(e, r), o = a.name, s = t.getUniformLocation(e, o);
                V(a, s, this)
            }
        }

        function W(t, e, n) {
            return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
        }

        function X(t, e, n, r, a, o, s, c, l, u, h, d) {
            i.call(this, null, o, s, c, l, u, r, a, h, d), this.image = {
                data: t,
                width: e,
                height: n
            }, this.magFilter = void 0 !== l ? l : Xa, this.minFilter = void 0 !== u ? u : Xa, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
        }

        function Y(t, e) {
            this.min = void 0 !== t ? t : new n(+(1 / 0), +(1 / 0)), this.max = void 0 !== e ? e : new n(-(1 / 0), -(1 / 0))
        }

        function q(t, e) {
            function i() {
                var t = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]), e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                a = f.createBuffer(), o = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, a), f.bufferData(f.ARRAY_BUFFER, t, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, o), f.bufferData(f.ELEMENT_ARRAY_BUFFER, e, f.STATIC_DRAW), d = f.createTexture(), p = f.createTexture(), m.bindTexture(f.TEXTURE_2D, d), f.texImage2D(f.TEXTURE_2D, 0, f.RGB, 16, 16, 0, f.RGB, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), m.bindTexture(f.TEXTURE_2D, p), f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, 16, 16, 0, f.RGBA, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), s = {
                    vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                }, l = r(s), u = {
                    vertex: f.getAttribLocation(l, "position"),
                    uv: f.getAttribLocation(l, "uv")
                }, h = {
                    renderType: f.getUniformLocation(l, "renderType"),
                    map: f.getUniformLocation(l, "map"),
                    occlusionMap: f.getUniformLocation(l, "occlusionMap"),
                    opacity: f.getUniformLocation(l, "opacity"),
                    color: f.getUniformLocation(l, "color"),
                    scale: f.getUniformLocation(l, "scale"),
                    rotation: f.getUniformLocation(l, "rotation"),
                    screenPosition: f.getUniformLocation(l, "screenPosition")
                }
            }

            function r(e) {
                var n = f.createProgram(), i = f.createShader(f.FRAGMENT_SHADER), r = f.createShader(f.VERTEX_SHADER), a = "precision " + t.getPrecision() + " float;\n";
                return f.shaderSource(i, a + e.fragmentShader), f.shaderSource(r, a + e.vertexShader), f.compileShader(i), f.compileShader(r), f.attachShader(n, i), f.attachShader(n, r), f.linkProgram(n), n
            }

            var a, o, s, l, u, h, d, p, f = t.context, m = t.state;
            this.render = function (r, s, g) {
                if (0 !== e.length) {
                    var v = new c, y = g.w / g.z, _ = .5 * g.z, x = .5 * g.w, b = 16 / g.w, w = new n(b * y, b), M = new c(1, 1, 0), E = new n(1, 1), T = new Y;
                    T.min.set(g.x, g.y), T.max.set(g.x + (g.z - 16), g.y + (g.w - 16)), void 0 === l && i(), f.useProgram(l), m.initAttributes(), m.enableAttribute(u.vertex), m.enableAttribute(u.uv), m.disableUnusedAttributes(), f.uniform1i(h.occlusionMap, 0), f.uniform1i(h.map, 1), f.bindBuffer(f.ARRAY_BUFFER, a), f.vertexAttribPointer(u.vertex, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(u.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, o), m.disable(f.CULL_FACE), m.setDepthWrite(!1);
                    for (var S = 0, A = e.length; S < A; S++) {
                        b = 16 / g.w, w.set(b * y, b);
                        var L = e[S];
                        if (v.set(L.matrixWorld.elements[12], L.matrixWorld.elements[13], L.matrixWorld.elements[14]), v.applyMatrix4(s.matrixWorldInverse), v.applyProjection(s.projectionMatrix), M.copy(v), E.x = g.x + M.x * _ + _ - 8, E.y = g.y + M.y * x + x - 8, T.containsPoint(E) === !0) {
                            m.activeTexture(f.TEXTURE0), m.bindTexture(f.TEXTURE_2D, null), m.activeTexture(f.TEXTURE1), m.bindTexture(f.TEXTURE_2D, d), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGB, E.x, E.y, 16, 16, 0), f.uniform1i(h.renderType, 0), f.uniform2f(h.scale, w.x, w.y), f.uniform3f(h.screenPosition, M.x, M.y, M.z), m.disable(f.BLEND), m.enable(f.DEPTH_TEST), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), m.activeTexture(f.TEXTURE0), m.bindTexture(f.TEXTURE_2D, p), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGBA, E.x, E.y, 16, 16, 0), f.uniform1i(h.renderType, 1), m.disable(f.DEPTH_TEST), m.activeTexture(f.TEXTURE1), m.bindTexture(f.TEXTURE_2D, d), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), L.positionScreen.copy(M), L.customUpdateCallback ? L.customUpdateCallback(L) : L.updateLensFlares(), f.uniform1i(h.renderType, 2), m.enable(f.BLEND);
                            for (var R = 0, C = L.lensFlares.length; R < C; R++) {
                                var P = L.lensFlares[R];
                                P.opacity > .001 && P.scale > .001 && (M.x = P.x, M.y = P.y, M.z = P.z, b = P.size * P.scale / g.w, w.x = b * y, w.y = b, f.uniform3f(h.screenPosition, M.x, M.y, M.z), f.uniform2f(h.scale, w.x, w.y), f.uniform1f(h.rotation, P.rotation), f.uniform1f(h.opacity, P.opacity), f.uniform3f(h.color, P.color.r, P.color.g, P.color.b), m.setBlending(P.blending, P.blendEquation, P.blendSrc, P.blendDst), t.setTexture2D(P.texture, 1), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0))
                            }
                        }
                    }
                    m.enable(f.CULL_FACE), m.enable(f.DEPTH_TEST), m.setDepthWrite(!0), t.resetGLState()
                }
            }
        }

        function Z(t, e) {
            function n() {
                var t = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]), e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                o = f.createBuffer(), l = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, o), f.bufferData(f.ARRAY_BUFFER, t, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, l), f.bufferData(f.ELEMENT_ARRAY_BUFFER, e, f.STATIC_DRAW), u = r(), h = {
                    position: f.getAttribLocation(u, "position"),
                    uv: f.getAttribLocation(u, "uv")
                }, d = {
                    uvOffset: f.getUniformLocation(u, "uvOffset"),
                    uvScale: f.getUniformLocation(u, "uvScale"),
                    rotation: f.getUniformLocation(u, "rotation"),
                    scale: f.getUniformLocation(u, "scale"),
                    color: f.getUniformLocation(u, "color"),
                    map: f.getUniformLocation(u, "map"),
                    opacity: f.getUniformLocation(u, "opacity"),
                    modelViewMatrix: f.getUniformLocation(u, "modelViewMatrix"),
                    projectionMatrix: f.getUniformLocation(u, "projectionMatrix"),
                    fogType: f.getUniformLocation(u, "fogType"),
                    fogDensity: f.getUniformLocation(u, "fogDensity"),
                    fogNear: f.getUniformLocation(u, "fogNear"),
                    fogFar: f.getUniformLocation(u, "fogFar"),
                    fogColor: f.getUniformLocation(u, "fogColor"),
                    alphaTest: f.getUniformLocation(u, "alphaTest")
                };
                var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                n.width = 8, n.height = 8;
                var a = n.getContext("2d");
                a.fillStyle = "white", a.fillRect(0, 0, 8, 8), p = new i(n), p.needsUpdate = !0
            }

            function r() {
                var e = f.createProgram(), n = f.createShader(f.VERTEX_SHADER), i = f.createShader(f.FRAGMENT_SHADER);
                return f.shaderSource(n, ["precision " + t.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), f.shaderSource(i, ["precision " + t.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), f.compileShader(n), f.compileShader(i), f.attachShader(e, n), f.attachShader(e, i), f.linkProgram(e), e
            }

            function a(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : e.id - t.id
            }

            var o, l, u, h, d, p, f = t.context, m = t.state, g = new c, v = new s, y = new c;
            this.render = function (i, r) {
                if (0 !== e.length) {
                    void 0 === u && n(), f.useProgram(u), m.initAttributes(), m.enableAttribute(h.position), m.enableAttribute(h.uv), m.disableUnusedAttributes(), m.disable(f.CULL_FACE), m.enable(f.BLEND), f.bindBuffer(f.ARRAY_BUFFER, o), f.vertexAttribPointer(h.position, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(h.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, l), f.uniformMatrix4fv(d.projectionMatrix, !1, r.projectionMatrix.elements), m.activeTexture(f.TEXTURE0), f.uniform1i(d.map, 0);
                    var s = 0, c = 0, _ = i.fog;
                    _ ? (f.uniform3f(d.fogColor, _.color.r, _.color.g, _.color.b), _.isFog ? (f.uniform1f(d.fogNear, _.near), f.uniform1f(d.fogFar, _.far), f.uniform1i(d.fogType, 1), s = 1, c = 1) : _.isFogExp2 && (f.uniform1f(d.fogDensity, _.density), f.uniform1i(d.fogType, 2), s = 2, c = 2)) : (f.uniform1i(d.fogType, 0), s = 0, c = 0);
                    for (var x = 0, b = e.length; x < b; x++) {
                        var w = e[x];
                        w.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, w.matrixWorld), w.z = -w.modelViewMatrix.elements[14]
                    }
                    e.sort(a);
                    for (var M = [], x = 0, b = e.length; x < b; x++) {
                        var w = e[x], E = w.material;
                        if (E.visible !== !1) {
                            f.uniform1f(d.alphaTest, E.alphaTest), f.uniformMatrix4fv(d.modelViewMatrix, !1, w.modelViewMatrix.elements), w.matrixWorld.decompose(g, v, y), M[0] = y.x, M[1] = y.y;
                            var T = 0;
                            i.fog && E.fog && (T = c), s !== T && (f.uniform1i(d.fogType, T), s = T), null !== E.map ? (f.uniform2f(d.uvOffset, E.map.offset.x, E.map.offset.y), f.uniform2f(d.uvScale, E.map.repeat.x, E.map.repeat.y)) : (f.uniform2f(d.uvOffset, 0, 0), f.uniform2f(d.uvScale, 1, 1)), f.uniform1f(d.opacity, E.opacity), f.uniform3f(d.color, E.color.r, E.color.g, E.color.b), f.uniform1f(d.rotation, E.rotation), f.uniform2fv(d.scale, M), m.setBlending(E.blending, E.blendEquation, E.blendSrc, E.blendDst), m.setDepthTest(E.depthTest), m.setDepthWrite(E.depthWrite), E.map ? t.setTexture2D(E.map, 0) : t.setTexture2D(p, 0), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0)
                        }
                    }
                    m.enable(f.CULL_FACE), t.resetGLState()
                }
            }
        }

        function J() {
            Object.defineProperty(this, "id", {value: sl++}), this.uuid = Qo.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Zr, this.side = Gr, this.shading = jr, this.vertexColors = Wr, this.opacity = 1, this.transparent = !1, this.blendSrc = ua, this.blendDst = ha, this.blendEquation = ea, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = xa, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this._needsUpdate = !0
        }

        function Q(t) {
            J.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
        }

        function K(t) {
            J.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Zo, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function $(t, e) {
            this.min = void 0 !== t ? t : new c(+(1 / 0), +(1 / 0), +(1 / 0)), this.max = void 0 !== e ? e : new c(-(1 / 0), -(1 / 0), -(1 / 0))
        }

        function tt(t, e) {
            this.center = void 0 !== t ? t : new c, this.radius = void 0 !== e ? e : 0
        }

        function et() {
            this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function nt(t, e) {
            this.normal = void 0 !== t ? t : new c(1, 0, 0), this.constant = void 0 !== e ? e : 0
        }

        function it(t, e, n, i, r, a) {
            this.planes = [void 0 !== t ? t : new nt, void 0 !== e ? e : new nt, void 0 !== n ? n : new nt, void 0 !== i ? i : new nt, void 0 !== r ? r : new nt, void 0 !== a ? a : new nt]
        }

        function rt(t, e, i, o) {
            function s(e, n, i, r) {
                var a = e.geometry, o = null, s = E, c = e.customDepthMaterial;
                if (i && (s = T, c = e.customDistanceMaterial), c)o = c; else {
                    var l = !1;
                    n.morphTargets && (a && a.isBufferGeometry ? l = a.morphAttributes && a.morphAttributes.position && a.morphAttributes.position.length > 0 : a && a.isGeometry && (l = a.morphTargets && a.morphTargets.length > 0));
                    var u = e.isSkinnedMesh && n.skinning, h = 0;
                    l && (h |= b), u && (h |= w), o = s[h]
                }
                if (t.localClippingEnabled && n.clipShadows === !0 && 0 !== n.clippingPlanes.length) {
                    var d = o.uuid, p = n.uuid, f = S[d];
                    void 0 === f && (f = {}, S[d] = f);
                    var m = f[p];
                    void 0 === m && (m = o.clone(), f[p] = m), o = m
                }
                o.visible = n.visible, o.wireframe = n.wireframe;
                var g = n.side;
                return B.renderSingleSided && g == Hr && (g = Gr), B.renderReverseSided && (g === Gr ? g = kr : g === kr && (g = Gr)), o.side = g, o.clipShadows = n.clipShadows, o.clippingPlanes = n.clippingPlanes, o.wireframeLinewidth = n.wireframeLinewidth, o.linewidth = n.linewidth, i && void 0 !== o.uniforms.lightPos && o.uniforms.lightPos.value.copy(r), o
            }

            function u(t, e, n) {
                if (t.visible !== !1) {
                    var i = 0 !== (t.layers.mask & e.layers.mask);
                    if (i && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (t.frustumCulled === !1 || p.intersectsObject(t) === !0)) {
                        var r = t.material;
                        r.visible === !0 && (t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), x.push(t))
                    }
                    for (var a = t.children, o = 0, s = a.length; o < s; o++)u(a[o], e, n)
                }
            }

            var h = t.context, d = t.state, p = new it, f = new l, m = e.shadows, g = new n, v = new n(o.maxTextureSize, o.maxTextureSize), y = new c, _ = new c, x = [], b = 1, w = 2, M = (b | w) + 1, E = new Array(M), T = new Array(M), S = {}, A = [new c(1, 0, 0), new c(-1, 0, 0), new c(0, 0, 1), new c(0, 0, -1), new c(0, 1, 0), new c(0, -1, 0)], L = [new c(0, 1, 0), new c(0, 1, 0), new c(0, 1, 0), new c(0, 1, 0), new c(0, 0, 1), new c(0, 0, -1)], R = [new r, new r, new r, new r, new r, new r], C = new K;
            C.depthPacking = Jo, C.clipping = !0;
            for (var P = ol.distanceRGBA, O = rs.clone(P.uniforms), I = 0; I !== M; ++I) {
                var U = 0 !== (I & b), N = 0 !== (I & w), D = C.clone();
                D.morphTargets = U, D.skinning = N, E[I] = D;
                var F = new Q({
                    defines: {USE_SHADOWMAP: ""},
                    uniforms: O,
                    vertexShader: P.vertexShader,
                    fragmentShader: P.fragmentShader,
                    morphTargets: U,
                    skinning: N,
                    clipping: !0
                });
                T[I] = F
            }
            var B = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Br, this.renderReverseSided = !0, this.renderSingleSided = !0, this.render = function (e, n) {
                if (B.enabled !== !1 && (B.autoUpdate !== !1 || B.needsUpdate !== !1) && 0 !== m.length) {
                    d.buffers.color.setClear(1, 1, 1, 1), d.disable(h.BLEND), d.setDepthTest(!0), d.setScissorTest(!1);
                    for (var r, o, c = 0, l = m.length; c < l; c++) {
                        var b = m[c], w = b.shadow;
                        if (void 0 !== w) {
                            var M = w.camera;
                            if (g.copy(w.mapSize), g.min(v), b && b.isPointLight) {
                                r = 6, o = !0;
                                var E = g.x, T = g.y;
                                R[0].set(2 * E, T, E, T), R[1].set(0, T, E, T), R[2].set(3 * E, T, E, T), R[3].set(E, T, E, T), R[4].set(3 * E, 0, E, T), R[5].set(E, 0, E, T), g.x *= 4, g.y *= 2
                            } else r = 1, o = !1;
                            if (null === w.map) {
                                var S = {minFilter: Xa, magFilter: Xa, format: fo};
                                w.map = new a(g.x, g.y, S), M.updateProjectionMatrix()
                            }
                            w.isSpotLightShadow && w.update(b), w && w.isRectAreaLightShadow && w.update(b);
                            var C = w.map, P = w.matrix;
                            _.setFromMatrixPosition(b.matrixWorld), M.position.copy(_), t.setRenderTarget(C), t.clear();
                            for (var O = 0; O < r; O++) {
                                if (o) {
                                    y.copy(M.position), y.add(A[O]), M.up.copy(L[O]), M.lookAt(y);
                                    var I = R[O];
                                    d.viewport(I)
                                } else y.setFromMatrixPosition(b.target.matrixWorld), M.lookAt(y);
                                M.updateMatrixWorld(), M.matrixWorldInverse.getInverse(M.matrixWorld), P.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), P.multiply(M.projectionMatrix), P.multiply(M.matrixWorldInverse), f.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), p.setFromMatrix(f), x.length = 0, u(e, n, M);
                                for (var U = 0, N = x.length; U < N; U++) {
                                    var D = x[U], F = i.update(D), z = D.material;
                                    if (z && z.isMultiMaterial)for (var G = F.groups, k = z.materials, H = 0, V = G.length; H < V; H++) {
                                        var j = G[H], W = k[j.materialIndex];
                                        if (W.visible === !0) {
                                            var X = s(D, W, o, _);
                                            t.renderBufferDirect(M, null, F, X, D, j)
                                        }
                                    } else {
                                        var X = s(D, z, o, _);
                                        t.renderBufferDirect(M, null, F, X, D, null)
                                    }
                                }
                            }
                        } else console.warn("THREE.WebGLShadowMap:", b, "has no shadow.")
                    }
                    var Y = t.getClearColor(), q = t.getClearAlpha();
                    t.setClearColor(Y, q), B.needsUpdate = !1
                }
            }
        }

        function at(t, e) {
            this.origin = void 0 !== t ? t : new c, this.direction = void 0 !== e ? e : new c
        }

        function ot(t, e, n, i) {
            this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = i || ot.DefaultOrder
        }

        function st() {
            this.mask = 1
        }

        function ct() {
            function t() {
                r.setFromEuler(i, !1)
            }

            function e() {
                i.setFromQuaternion(r, void 0, !1)
            }

            Object.defineProperty(this, "id", {value: cl++}), this.uuid = Qo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ct.DefaultUp.clone();
            var n = new c, i = new ot, r = new s, a = new c(1, 1, 1);
            i.onChange(t), r.onChange(e), Object.defineProperties(this, {
                position: {enumerable: !0, value: n},
                rotation: {enumerable: !0, value: i},
                quaternion: {enumerable: !0, value: r},
                scale: {enumerable: !0, value: a},
                modelViewMatrix: {value: new l},
                normalMatrix: {value: new et}
            }), this.matrix = new l, this.matrixWorld = new l, this.matrixAutoUpdate = ct.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new st, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = function () {
            }, this.onAfterRender = function () {
            }
        }

        function lt(t, e) {
            this.start = void 0 !== t ? t : new c, this.end = void 0 !== e ? e : new c
        }

        function ut(t, e, n) {
            this.a = void 0 !== t ? t : new c, this.b = void 0 !== e ? e : new c, this.c = void 0 !== n ? n : new c
        }

        function ht(t, e, n, i, r, a) {
            this.a = t, this.b = e, this.c = n, this.normal = i && i.isVector3 ? i : new c, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new W, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
        }

        function dt(t) {
            J.call(this), this.type = "MeshBasicMaterial", this.color = new W(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Ta, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
        }

        function pt(t, e, n) {
            if (Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.uuid = Qo.generateUUID(), this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = n === !0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function () {
            }, this.version = 0
        }

        function ft(t, e) {
            pt.call(this, new Int8Array(t), e)
        }

        function mt(t, e) {
            pt.call(this, new Uint8Array(t), e)
        }

        function gt(t, e) {
            pt.call(this, new Uint8ClampedArray(t), e)
        }

        function vt(t, e) {
            pt.call(this, new Int16Array(t), e)
        }

        function yt(t, e) {
            pt.call(this, new Uint16Array(t), e)
        }

        function _t(t, e) {
            pt.call(this, new Int32Array(t), e)
        }

        function xt(t, e) {
            pt.call(this, new Uint32Array(t), e)
        }

        function bt(t, e) {
            pt.call(this, new Float32Array(t), e)
        }

        function wt(t, e) {
            pt.call(this, new Float64Array(t), e)
        }

        function Mt() {
            this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function Et() {
            Object.defineProperty(this, "id", {value: Tt()}), this.uuid = Qo.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
        }

        function Tt() {
            return ll++
        }

        function St() {
            Object.defineProperty(this, "id", {value: Tt()}), this.uuid = Qo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }

        function At(t, e) {
            ct.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new St, this.material = void 0 !== e ? e : new dt({color: 16777215 * Math.random()}), this.drawMode = Bo, this.updateMorphTargets()
        }

        function Lt(t, e, n, i, r, a) {
            function o(t, e, n) {
                var i = 0;
                return i += (t + 1) * (e + 1) * 2, i += (t + 1) * (n + 1) * 2, i += (n + 1) * (e + 1) * 2
            }

            function s(t, e, n) {
                var i = 0;
                return i += t * e * 2, i += t * n * 2, i += n * e * 2, 6 * i
            }

            function l(t, e, n, i, r, a, o, s, l, h, d) {
                for (var w = a / l, M = o / h, E = a / 2, T = o / 2, S = s / 2, A = l + 1, L = h + 1, R = 0, C = 0, P = new c, O = 0; O < L; O++)for (var I = O * M - T, U = 0; U < A; U++) {
                    var N = U * w - E;
                    P[t] = N * i, P[e] = I * r, P[n] = S, f[v] = P.x, f[v + 1] = P.y, f[v + 2] = P.z, P[t] = 0, P[e] = 0, P[n] = s > 0 ? 1 : -1, m[v] = P.x, m[v + 1] = P.y, m[v + 2] = P.z, g[y] = U / l, g[y + 1] = 1 - O / h, v += 3, y += 2, R += 1
                }
                for (O = 0; O < h; O++)for (U = 0; U < l; U++) {
                    var D = x + U + A * O, F = x + U + A * (O + 1), B = x + (U + 1) + A * (O + 1), z = x + (U + 1) + A * O;
                    p[_] = D, p[_ + 1] = F, p[_ + 2] = z, p[_ + 3] = F, p[_ + 4] = B, p[_ + 5] = z, _ += 6, C += 6
                }
                u.addGroup(b, C, d), b += C, x += R
            }

            St.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a
            };
            var u = this;
            i = Math.floor(i) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
            var h = o(i, r, a), d = s(i, r, a), p = new (d > 65535 ? Uint32Array : Uint16Array)(d), f = new Float32Array(3 * h), m = new Float32Array(3 * h), g = new Float32Array(2 * h), v = 0, y = 0, _ = 0, x = 0, b = 0;
            l("z", "y", "x", -1, -1, n, e, t, a, r, 0), l("z", "y", "x", 1, -1, n, e, -t, a, r, 1), l("x", "z", "y", 1, 1, t, n, e, i, a, 2), l("x", "z", "y", 1, -1, t, n, -e, i, a, 3), l("x", "y", "z", 1, -1, t, e, n, i, r, 4), l("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(new pt(p, 1)), this.addAttribute("position", new pt(f, 3)), this.addAttribute("normal", new pt(m, 3)), this.addAttribute("uv", new pt(g, 2))
        }

        function Rt(t, e, n, i) {
            St.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            };
            for (var r = t / 2, a = e / 2, o = Math.floor(n) || 1, s = Math.floor(i) || 1, c = o + 1, l = s + 1, u = t / o, h = e / s, d = new Float32Array(c * l * 3), p = new Float32Array(c * l * 3), f = new Float32Array(c * l * 2), m = 0, g = 0, v = 0; v < l; v++)for (var y = v * h - a, _ = 0; _ < c; _++) {
                var x = _ * u - r;
                d[m] = x, d[m + 1] = -y, p[m + 2] = 1, f[g] = _ / o, f[g + 1] = 1 - v / s, m += 3, g += 2
            }
            m = 0;
            for (var b = new (d.length / 3 > 65535 ? Uint32Array : Uint16Array)(o * s * 6), v = 0; v < s; v++)for (var _ = 0; _ < o; _++) {
                var w = _ + c * v, M = _ + c * (v + 1), E = _ + 1 + c * (v + 1), T = _ + 1 + c * v;
                b[m] = w, b[m + 1] = M, b[m + 2] = T, b[m + 3] = M, b[m + 4] = E, b[m + 5] = T, m += 6
            }
            this.setIndex(new pt(b, 1)), this.addAttribute("position", new pt(d, 3)), this.addAttribute("normal", new pt(p, 3)), this.addAttribute("uv", new pt(f, 2))
        }

        function Ct() {
            ct.call(this), this.type = "Camera", this.matrixWorldInverse = new l, this.projectionMatrix = new l
        }

        function Pt(t, e, n, i) {
            Ct.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function Ot(t, e, n, i, r, a) {
            Ct.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
        }

        function It(t, e, n) {
            function i(t) {
                s = t
            }

            function r(n) {
                n.array instanceof Uint32Array && e.get("OES_element_index_uint") ? (c = t.UNSIGNED_INT, l = 4) : n.array instanceof Uint16Array ? (c = t.UNSIGNED_SHORT, l = 2) : (c = t.UNSIGNED_BYTE, l = 1)
            }

            function a(e, i) {
                t.drawElements(s, i, c, e * l), n.calls++, n.vertices += i, s === t.TRIANGLES && (n.faces += i / 3)
            }

            function o(i, r, a) {
                var o = e.get("ANGLE_instanced_arrays");
                return null === o ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (o.drawElementsInstancedANGLE(s, a, c, r * l, i.maxInstancedCount), n.calls++, n.vertices += a * i.maxInstancedCount, void(s === t.TRIANGLES && (n.faces += i.maxInstancedCount * a / 3)))
            }

            var s, c, l;
            return {setMode: i, setIndex: r, render: a, renderInstances: o}
        }

        function Ut(t, e, n) {
            function i(t) {
                o = t
            }

            function r(e, i) {
                t.drawArrays(o, e, i), n.calls++, n.vertices += i, o === t.TRIANGLES && (n.faces += i / 3)
            }

            function a(i) {
                var r = e.get("ANGLE_instanced_arrays");
                if (null === r)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                var a = i.attributes.position, s = 0;
                a.isInterleavedBufferAttribute ? (s = a.data.count, r.drawArraysInstancedANGLE(o, 0, s, i.maxInstancedCount)) : (s = a.count, r.drawArraysInstancedANGLE(o, 0, s, i.maxInstancedCount)), n.calls++, n.vertices += s * i.maxInstancedCount, o === t.TRIANGLES && (n.faces += i.maxInstancedCount * s / 3)
            }

            var o;
            return {setMode: i, render: r, renderInstances: a}
        }

        function Nt() {
            var t = {};
            return {
                get: function (e) {
                    if (void 0 !== t[e.id])return t[e.id];
                    var i;
                    switch (e.type) {
                        case"DirectionalLight":
                            i = {
                                direction: new c,
                                color: new W,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new n
                            };
                            break;
                        case"SpotLight":
                            i = {
                                position: new c,
                                direction: new c,
                                color: new W,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new n
                            };
                            break;
                        case"PointLight":
                            i = {
                                position: new c,
                                color: new W,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new n
                            };
                            break;
                        case"HemisphereLight":
                            i = {direction: new c, skyColor: new W, groundColor: new W};
                            break;
                        case"RectAreaLight":
                            i = {color: new W, position: new c, halfWidth: new c, halfHeight: new c}
                    }
                    return t[e.id] = i, i
                }
            }
        }

        function Dt(t) {
            for (var e = t.split("\n"), n = 0; n < e.length; n++)e[n] = n + 1 + ": " + e[n];
            return e.join("\n")
        }

        function Ft(t, e, n) {
            var i = t.createShader(e);
            return t.shaderSource(i, n), t.compileShader(i), t.getShaderParameter(i, t.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(i), Dt(n)), i
        }

        function Bt(t) {
            switch (t) {
                case ko:
                    return ["Linear", "( value )"];
                case Ho:
                    return ["sRGB", "( value )"];
                case jo:
                    return ["RGBE", "( value )"];
                case Xo:
                    return ["RGBM", "( value, 7.0 )"];
                case Yo:
                    return ["RGBM", "( value, 16.0 )"];
                case qo:
                    return ["RGBD", "( value, 256.0 )"];
                case Vo:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw new Error("unsupported encoding: " + t)
            }
        }

        function zt(t, e) {
            var n = Bt(e);
            return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
        }

        function Gt(t, e) {
            var n = Bt(e);
            return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
        }

        function kt(t, e) {
            var n;
            switch (e) {
                case Ra:
                    n = "Linear";
                    break;
                case Ca:
                    n = "Reinhard";
                    break;
                case Pa:
                    n = "Uncharted2";
                    break;
                case Oa:
                    n = "OptimizedCineon";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + e)
            }
            return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function Ht(t, e, n) {
            t = t || {};
            var i = [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
            return i.filter(Wt).join("\n")
        }

        function Vt(t) {
            var e = [];
            for (var n in t) {
                var i = t[n];
                i !== !1 && e.push("#define " + n + " " + i)
            }
            return e.join("\n")
        }

        function jt(t, e, n) {
            for (var i = {}, r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), a = 0; a < r; a++) {
                var o = t.getActiveAttrib(e, a), s = o.name;
                i[s] = t.getAttribLocation(e, s)
            }
            return i
        }

        function Wt(t) {
            return "" !== t
        }

        function Xt(t, e) {
            return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        }

        function Yt(t) {
            function e(t, e) {
                var n = il[e];
                if (void 0 === n)throw new Error("Can not resolve #include <" + e + ">");
                return Yt(n)
            }

            var n = /#include +<([\w\d.]+)>/g;
            return t.replace(n, e)
        }

        function qt(t) {
            function e(t, e, n, i) {
                for (var r = "", a = parseInt(e); a < parseInt(n); a++)r += i.replace(/\[ i \]/g, "[ " + a + " ]");
                return r
            }

            var n = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
            return t.replace(n, e)
        }

        function Zt(t, e, n, i) {
            var r = t.context, a = n.extensions, o = n.defines, s = n.__webglShader.vertexShader, c = n.__webglShader.fragmentShader, l = "SHADOWMAP_TYPE_BASIC";
            i.shadowMapType === Br ? l = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === zr && (l = "SHADOWMAP_TYPE_PCF_SOFT");
            var u = "ENVMAP_TYPE_CUBE", h = "ENVMAP_MODE_REFLECTION", d = "ENVMAP_BLENDING_MULTIPLY";
            if (i.envMap) {
                switch (n.envMap.mapping) {
                    case Ua:
                    case Na:
                        u = "ENVMAP_TYPE_CUBE";
                        break;
                    case za:
                    case Ga:
                        u = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case Da:
                    case Fa:
                        u = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case Ba:
                        u = "ENVMAP_TYPE_SPHERE"
                }
                switch (n.envMap.mapping) {
                    case Na:
                    case Fa:
                        h = "ENVMAP_MODE_REFRACTION"
                }
                switch (n.combine) {
                    case Ta:
                        d = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case Sa:
                        d = "ENVMAP_BLENDING_MIX";
                        break;
                    case Aa:
                        d = "ENVMAP_BLENDING_ADD"
                }
            }
            var p, f, m = t.gammaFactor > 0 ? t.gammaFactor : 1, g = Ht(a, i, t.extensions), v = Vt(o), y = r.createProgram();
            n.isRawShaderMaterial ? (p = [v, "\n"].filter(Wt).join("\n"), f = [g, v, "\n"].filter(Wt).join("\n")) : (p = ["precision " + i.precision + " float;", "precision " + i.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, v, i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + i.maxBones, i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + h : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.useVertexTexture ? "#define BONE_TEXTURE" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && i.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + i.numClippingPlanes, i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Wt).join("\n"), f = [g, "precision " + i.precision + " float;", "precision " + i.precision + " int;", "#define SHADER_NAME " + n.__webglShader.name, v, i.alphaTest ? "#define ALPHATEST " + i.alphaTest : "", "#define GAMMA_FACTOR " + m, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + u : "", i.envMap ? "#define " + h : "", i.envMap ? "#define " + d : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.vertexColors ? "#define USE_COLOR" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + i.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (i.numClippingPlanes - i.numClipIntersection), i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + l : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", i.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", i.toneMapping !== La ? "#define TONE_MAPPING" : "", i.toneMapping !== La ? il.tonemapping_pars_fragment : "", i.toneMapping !== La ? kt("toneMapping", i.toneMapping) : "", i.outputEncoding || i.mapEncoding || i.envMapEncoding || i.emissiveMapEncoding ? il.encodings_pars_fragment : "", i.mapEncoding ? zt("mapTexelToLinear", i.mapEncoding) : "", i.envMapEncoding ? zt("envMapTexelToLinear", i.envMapEncoding) : "", i.emissiveMapEncoding ? zt("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "", i.outputEncoding ? Gt("linearToOutputTexel", i.outputEncoding) : "", i.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Wt).join("\n")), s = Yt(s, i), s = Xt(s, i), c = Yt(c, i), c = Xt(c, i), n.isShaderMaterial || (s = qt(s), c = qt(c));
            var _ = p + s, x = f + c, b = Ft(r, r.VERTEX_SHADER, _), w = Ft(r, r.FRAGMENT_SHADER, x);
            r.attachShader(y, b), r.attachShader(y, w), void 0 !== n.index0AttributeName ? r.bindAttribLocation(y, 0, n.index0AttributeName) : i.morphTargets === !0 && r.bindAttribLocation(y, 0, "position"), r.linkProgram(y);
            var M = r.getProgramInfoLog(y), E = r.getShaderInfoLog(b), T = r.getShaderInfoLog(w), S = !0, A = !0;
            r.getProgramParameter(y, r.LINK_STATUS) === !1 ? (S = !1, console.error("THREE.WebGLProgram: shader error: ", r.getError(), "gl.VALIDATE_STATUS", r.getProgramParameter(y, r.VALIDATE_STATUS), "gl.getProgramInfoLog", M, E, T)) : "" !== M ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", M) : "" !== E && "" !== T || (A = !1), A && (this.diagnostics = {
                runnable: S,
                material: n,
                programLog: M,
                vertexShader: {log: E, prefix: p},
                fragmentShader: {log: T, prefix: f}
            }), r.deleteShader(b), r.deleteShader(w);
            var L;
            this.getUniforms = function () {
                return void 0 === L && (L = new j(r, y, t)), L
            };
            var R;
            return this.getAttributes = function () {
                return void 0 === R && (R = jt(r, y)), R
            }, this.destroy = function () {
                r.deleteProgram(y), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function () {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                }, attributes: {
                    get: function () {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = ul++, this.code = e, this.usedTimes = 1, this.program = y, this.vertexShader = b, this.fragmentShader = w, this
        }

        function Jt(t, e) {
            function n(t) {
                if (e.floatVertexTextures && t && t.skeleton && t.skeleton.useVertexTexture)return 1024;
                var n = e.maxVertexUniforms, i = Math.floor((n - 20) / 4), r = i;
                return void 0 !== t && t && t.isSkinnedMesh && (r = Math.min(t.skeleton.bones.length, r), r < t.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + t.skeleton.bones.length + ", this GPU supports just " + r + " (try OpenGL instead of ANGLE)")), r
            }

            function i(t, e) {
                var n;
                return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = ko, n === ko && e && (n = Vo), n
            }

            var r = [], a = {
                MeshDepthMaterial: "depth",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points"
            }, o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"];
            this.getParameters = function (r, o, s, c, l, u) {
                var h = a[r.type], d = n(u), p = t.getPrecision();
                null !== r.precision && (p = e.getMaxPrecision(r.precision), p !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", p, "instead."));
                var f = t.getCurrentRenderTarget(), m = {
                    shaderID: h,
                    precision: p,
                    supportsVertexTextures: e.vertexTextures,
                    outputEncoding: i(f ? f.texture : null, t.gammaOutput),
                    map: !!r.map,
                    mapEncoding: i(r.map, t.gammaInput),
                    envMap: !!r.envMap,
                    envMapMode: r.envMap && r.envMap.mapping,
                    envMapEncoding: i(r.envMap, t.gammaInput),
                    envMapCubeUV: !!r.envMap && (r.envMap.mapping === za || r.envMap.mapping === Ga),
                    lightMap: !!r.lightMap,
                    aoMap: !!r.aoMap,
                    emissiveMap: !!r.emissiveMap,
                    emissiveMapEncoding: i(r.emissiveMap, t.gammaInput),
                    bumpMap: !!r.bumpMap,
                    normalMap: !!r.normalMap,
                    displacementMap: !!r.displacementMap,
                    roughnessMap: !!r.roughnessMap,
                    metalnessMap: !!r.metalnessMap,
                    specularMap: !!r.specularMap,
                    alphaMap: !!r.alphaMap,
                    gradientMap: !!r.gradientMap,
                    combine: r.combine,
                    vertexColors: r.vertexColors,
                    fog: !!s,
                    useFog: r.fog,
                    fogExp: s && s.isFogExp2,
                    flatShading: r.shading === Vr,
                    sizeAttenuation: r.sizeAttenuation,
                    logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                    skinning: r.skinning,
                    maxBones: d,
                    useVertexTexture: e.floatVertexTextures && u && u.skeleton && u.skeleton.useVertexTexture,
                    morphTargets: r.morphTargets,
                    morphNormals: r.morphNormals,
                    maxMorphTargets: t.maxMorphTargets,
                    maxMorphNormals: t.maxMorphNormals,
                    numDirLights: o.directional.length,
                    numPointLights: o.point.length,
                    numSpotLights: o.spot.length,
                    numRectAreaLights: o.rectArea.length,
                    numHemiLights: o.hemi.length,
                    numClippingPlanes: c,
                    numClipIntersection: l,
                    shadowMapEnabled: t.shadowMap.enabled && u.receiveShadow && o.shadows.length > 0,
                    shadowMapType: t.shadowMap.type,
                    toneMapping: t.toneMapping,
                    physicallyCorrectLights: t.physicallyCorrectLights,
                    premultipliedAlpha: r.premultipliedAlpha,
                    alphaTest: r.alphaTest,
                    doubleSided: r.side === Hr,
                    flipSided: r.side === kr,
                    depthPacking: void 0 !== r.depthPacking && r.depthPacking
                };
                return m
            }, this.getProgramCode = function (t, e) {
                var n = [];
                if (e.shaderID ? n.push(e.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines)for (var i in t.defines)n.push(i), n.push(t.defines[i]);
                for (var r = 0; r < o.length; r++)n.push(e[o[r]]);
                return n.join()
            }, this.acquireProgram = function (e, n, i) {
                for (var a, o = 0, s = r.length; o < s; o++) {
                    var c = r[o];
                    if (c.code === i) {
                        a = c, ++a.usedTimes;
                        break
                    }
                }
                return void 0 === a && (a = new Zt(t, i, e, n), r.push(a)), a
            }, this.releaseProgram = function (t) {
                if (0 === --t.usedTimes) {
                    var e = r.indexOf(t);
                    r[e] = r[r.length - 1], r.pop(), t.destroy()
                }
            }, this.programs = r
        }

        function Qt(t, e, n) {
            function i(t) {
                var r = t.target, s = c[r.id];
                null !== s.index && a(s.index), o(s.attributes), r.removeEventListener("dispose", i), delete c[r.id];
                var l = e.get(r);
                l.wireframe && a(l.wireframe), e.delete(r);
                var u = e.get(s);
                u.wireframe && a(u.wireframe), e.delete(s), n.memory.geometries--
            }

            function r(t) {
                return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
            }

            function a(e) {
                var n = r(e);
                void 0 !== n && (t.deleteBuffer(n), s(e))
            }

            function o(t) {
                for (var e in t)a(t[e])
            }

            function s(t) {
                t.isInterleavedBufferAttribute ? e.delete(t.data) : e.delete(t)
            }

            var c = {};
            return {
                get: function (t) {
                    var e = t.geometry;
                    if (void 0 !== c[e.id])return c[e.id];
                    e.addEventListener("dispose", i);
                    var r;
                    return e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new St).setFromObject(t)), r = e._bufferGeometry), c[e.id] = r, n.memory.geometries++, r
                }
            }
        }

        function Kt(t, e, n) {
            function i(e) {
                var n = u.get(e);
                e.geometry.isGeometry && n.updateFromObject(e);
                var i = n.index, a = n.attributes;
                null !== i && r(i, t.ELEMENT_ARRAY_BUFFER);
                for (var o in a)r(a[o], t.ARRAY_BUFFER);
                var s = n.morphAttributes;
                for (var o in s)for (var c = s[o], l = 0, h = c.length; l < h; l++)r(c[l], t.ARRAY_BUFFER);
                return n
            }

            function r(t, n) {
                var i = t.isInterleavedBufferAttribute ? t.data : t, r = e.get(i);
                void 0 === r.__webglBuffer ? a(r, i, n) : r.version !== i.version && o(r, i, n)
            }

            function a(e, n, i) {
                e.__webglBuffer = t.createBuffer(), t.bindBuffer(i, e.__webglBuffer);
                var r = n.dynamic ? t.DYNAMIC_DRAW : t.STATIC_DRAW;
                t.bufferData(i, n.array, r);
                var a = t.FLOAT, o = n.array;
                o instanceof Float32Array ? a = t.FLOAT : o instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : o instanceof Uint16Array ? a = t.UNSIGNED_SHORT : o instanceof Int16Array ? a = t.SHORT : o instanceof Uint32Array ? a = t.UNSIGNED_INT : o instanceof Int32Array ? a = t.INT : o instanceof Int8Array ? a = t.BYTE : o instanceof Uint8Array && (a = t.UNSIGNED_BYTE), e.bytesPerElement = o.BYTES_PER_ELEMENT, e.type = a, e.version = n.version, n.onUploadCallback()
            }

            function o(e, n, i) {
                t.bindBuffer(i, e.__webglBuffer), n.dynamic === !1 ? t.bufferData(i, n.array, t.STATIC_DRAW) : n.updateRange.count === -1 ? t.bufferSubData(i, 0, n.array) : 0 === n.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, n.updateRange.offset * n.array.BYTES_PER_ELEMENT, n.array.subarray(n.updateRange.offset, n.updateRange.offset + n.updateRange.count)), n.updateRange.count = 0), e.version = n.version
            }

            function s(t) {
                return t.isInterleavedBufferAttribute ? e.get(t.data).__webglBuffer : e.get(t).__webglBuffer
            }

            function c(t) {
                return t.isInterleavedBufferAttribute ? e.get(t.data) : e.get(t)
            }

            function l(n) {
                var i = e.get(n);
                if (void 0 !== i.wireframe)return i.wireframe;
                var a = [], o = n.index, s = n.attributes, c = s.position;
                if (null !== o)for (var l = o.array, u = 0, h = l.length; u < h; u += 3) {
                    var d = l[u + 0], p = l[u + 1], f = l[u + 2];
                    a.push(d, p, p, f, f, d)
                } else for (var l = s.position.array, u = 0, h = l.length / 3 - 1; u < h; u += 3) {
                    var d = u + 0, p = u + 1, f = u + 2;
                    a.push(d, p, p, f, f, d)
                }
                var m = c.count > 65535 ? Uint32Array : Uint16Array, g = new pt(new m(a), 1);
                return r(g, t.ELEMENT_ARRAY_BUFFER), i.wireframe = g, g
            }

            var u = new Qt(t, e, n);
            return {getAttributeBuffer: s, getAttributeProperties: c, getWireframeAttribute: l, update: i}
        }

        function $t(t, e, n, i, r, a, o) {
            function s(t, e) {
                if (t.width > e || t.height > e) {
                    var n = e / Math.max(t.width, t.height), i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    i.width = Math.floor(t.width * n), i.height = Math.floor(t.height * n);
                    var r = i.getContext("2d");
                    return r.drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t), i
                }
                return t
            }

            function c(t) {
                return Qo.isPowerOfTwo(t.width) && Qo.isPowerOfTwo(t.height)
            }

            function l(t) {
                if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
                    var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    e.width = Qo.nearestPowerOfTwo(t.width), e.height = Qo.nearestPowerOfTwo(t.height);
                    var n = e.getContext("2d");
                    return n.drawImage(t, 0, 0, e.width, e.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t), e
                }
                return t
            }

            function u(t) {
                return t.wrapS !== Va || t.wrapT !== Va || t.minFilter !== Xa && t.minFilter !== Za
            }

            function h(e) {
                return e === Xa || e === Ya || e === qa ? t.NEAREST : t.LINEAR
            }

            function d(t) {
                var e = t.target;
                e.removeEventListener("dispose", d), f(e), A.textures--
            }

            function p(t) {
                var e = t.target;
                e.removeEventListener("dispose", p), m(e), A.textures--
            }

            function f(e) {
                var n = i.get(e);
                if (e.image && n.__image__webglTextureCube)t.deleteTexture(n.__image__webglTextureCube); else {
                    if (void 0 === n.__webglInit)return;
                    t.deleteTexture(n.__webglTexture)
                }
                i.delete(e)
            }

            function m(e) {
                var n = i.get(e), r = i.get(e.texture);
                if (e) {
                    if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)for (var a = 0; a < 6; a++)t.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]); else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                    i.delete(e.texture), i.delete(e)
                }
            }

            function g(e, r) {
                var a = i.get(e);
                if (e.version > 0 && a.__version !== e.version) {
                    var o = e.image;
                    if (void 0 === o)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e); else {
                        if (o.complete !== !1)return void x(a, e, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                    }
                }
                n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_2D, a.__webglTexture)
            }

            function v(e, o) {
                var l = i.get(e);
                if (6 === e.image.length)if (e.version > 0 && l.__version !== e.version) {
                    l.__image__webglTextureCube || (e.addEventListener("dispose", d), l.__image__webglTextureCube = t.createTexture(), A.textures++), n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_CUBE_MAP, l.__image__webglTextureCube), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                    for (var u = e && e.isCompressedTexture, h = e.image[0] && e.image[0].isDataTexture, p = [], f = 0; f < 6; f++)u || h ? p[f] = h ? e.image[f].image : e.image[f] : p[f] = s(e.image[f], r.maxCubemapSize);
                    var m = p[0], g = c(m), v = a(e.format), y = a(e.type);
                    _(t.TEXTURE_CUBE_MAP, e, g);
                    for (var f = 0; f < 6; f++)if (u)for (var x, b = p[f].mipmaps, w = 0, M = b.length; w < M; w++)x = b[w], e.format !== fo && e.format !== po ? n.getCompressedTextureFormats().indexOf(v) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, w, v, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, w, v, x.width, x.height, 0, v, y, x.data); else h ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, v, p[f].width, p[f].height, 0, v, y, p[f].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, v, v, y, p[f]);
                    e.generateMipmaps && g && t.generateMipmap(t.TEXTURE_CUBE_MAP), l.__version = e.version, e.onUpdate && e.onUpdate(e)
                } else n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_CUBE_MAP, l.__image__webglTextureCube)
            }

            function y(e, r) {
                n.activeTexture(t.TEXTURE0 + r), n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
            }

            function _(n, o, s) {
                var c;
                if (s ? (t.texParameteri(n, t.TEXTURE_WRAP_S, a(o.wrapS)), t.texParameteri(n, t.TEXTURE_WRAP_T, a(o.wrapT)), t.texParameteri(n, t.TEXTURE_MAG_FILTER, a(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, a(o.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), o.wrapS === Va && o.wrapT === Va || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", o), t.texParameteri(n, t.TEXTURE_MAG_FILTER, h(o.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, h(o.minFilter)), o.minFilter !== Xa && o.minFilter !== Za && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", o)), c = e.get("EXT_texture_filter_anisotropic")) {
                    if (o.type === ao && null === e.get("OES_texture_float_linear"))return;
                    if (o.type === oo && null === e.get("OES_texture_half_float_linear"))return;
                    (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                }
            }

            function x(e, i, o) {
                void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", d), e.__webglTexture = t.createTexture(), A.textures++), n.activeTexture(t.TEXTURE0 + o), n.bindTexture(t.TEXTURE_2D, e.__webglTexture), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
                var h = s(i.image, r.maxTextureSize);
                u(i) && c(h) === !1 && (h = l(h));
                var p = c(h), f = a(i.format), m = a(i.type);
                _(t.TEXTURE_2D, i, p);
                var g, v = i.mipmaps;
                if (i.isDepthTexture) {
                    var y = t.DEPTH_COMPONENT;
                    if (i.type === ao) {
                        if (!L)throw new Error("Float Depth Texture only supported in WebGL2.0");
                        y = t.DEPTH_COMPONENT32F
                    } else L && (y = t.DEPTH_COMPONENT16);
                    i.format === yo && y === t.DEPTH_COMPONENT && i.type !== no && i.type !== ro && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = no, m = a(i.type)), i.format === _o && (y = t.DEPTH_STENCIL, i.type !== uo && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = uo, m = a(i.type))), n.texImage2D(t.TEXTURE_2D, 0, y, h.width, h.height, 0, f, m, null)
                } else if (i.isDataTexture)if (v.length > 0 && p) {
                    for (var x = 0, b = v.length; x < b; x++)g = v[x], n.texImage2D(t.TEXTURE_2D, x, f, g.width, g.height, 0, f, m, g.data);
                    i.generateMipmaps = !1
                } else n.texImage2D(t.TEXTURE_2D, 0, f, h.width, h.height, 0, f, m, h.data); else if (i.isCompressedTexture)for (var x = 0, b = v.length; x < b; x++)g = v[x], i.format !== fo && i.format !== po ? n.getCompressedTextureFormats().indexOf(f) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, x, f, g.width, g.height, 0, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, x, f, g.width, g.height, 0, f, m, g.data); else if (v.length > 0 && p) {
                    for (var x = 0, b = v.length; x < b; x++)g = v[x], n.texImage2D(t.TEXTURE_2D, x, f, f, m, g);
                    i.generateMipmaps = !1
                } else n.texImage2D(t.TEXTURE_2D, 0, f, f, m, h);
                i.generateMipmaps && p && t.generateMipmap(t.TEXTURE_2D), e.__version = i.version, i.onUpdate && i.onUpdate(i)
            }

            function b(e, r, o, s) {
                var c = a(r.texture.format), l = a(r.texture.type);
                n.texImage2D(s, 0, c, r.width, r.height, 0, c, l, null), t.bindFramebuffer(t.FRAMEBUFFER, e), t.framebufferTexture2D(t.FRAMEBUFFER, o, s, i.get(r.texture).__webglTexture, 0), t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function w(e, n) {
                t.bindRenderbuffer(t.RENDERBUFFER, e), n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height), t.bindRenderbuffer(t.RENDERBUFFER, null)
            }

            function M(e, n) {
                var r = n && n.isWebGLRenderTargetCube;
                if (r)throw new Error("Depth Texture with cube render targets is not supported!");
                if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), g(n.depthTexture, 0);
                var a = i.get(n.depthTexture).__webglTexture;
                if (n.depthTexture.format === yo)t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0); else {
                    if (n.depthTexture.format !== _o)throw new Error("Unknown depthTexture format");
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0)
                }
            }

            function E(e) {
                var n = i.get(e), r = e.isWebGLRenderTargetCube === !0;
                if (e.depthTexture) {
                    if (r)throw new Error("target.depthTexture not supported in Cube render targets");
                    M(n.__webglFramebuffer, e)
                } else if (r) {
                    n.__webglDepthbuffer = [];
                    for (var a = 0; a < 6; a++)t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = t.createRenderbuffer(), w(n.__webglDepthbuffer[a], e)
                } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), w(n.__webglDepthbuffer, e);
                t.bindFramebuffer(t.FRAMEBUFFER, null)
            }

            function T(e) {
                var r = i.get(e), a = i.get(e.texture);
                e.addEventListener("dispose", p), a.__webglTexture = t.createTexture(), A.textures++;
                var o = e.isWebGLRenderTargetCube === !0, s = c(e);
                if (o) {
                    r.__webglFramebuffer = [];
                    for (var l = 0; l < 6; l++)r.__webglFramebuffer[l] = t.createFramebuffer()
                } else r.__webglFramebuffer = t.createFramebuffer();
                if (o) {
                    n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture), _(t.TEXTURE_CUBE_MAP, e.texture, s);
                    for (var l = 0; l < 6; l++)b(r.__webglFramebuffer[l], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + l);
                    e.texture.generateMipmaps && s && t.generateMipmap(t.TEXTURE_CUBE_MAP), n.bindTexture(t.TEXTURE_CUBE_MAP, null)
                } else n.bindTexture(t.TEXTURE_2D, a.__webglTexture), _(t.TEXTURE_2D, e.texture, s), b(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D), e.texture.generateMipmaps && s && t.generateMipmap(t.TEXTURE_2D), n.bindTexture(t.TEXTURE_2D, null);
                e.depthBuffer && E(e)
            }

            function S(e) {
                var r = e.texture;
                if (r.generateMipmaps && c(e) && r.minFilter !== Xa && r.minFilter !== Za) {
                    var a = e && e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D, o = i.get(r).__webglTexture;
                    n.bindTexture(a, o), t.generateMipmap(a), n.bindTexture(a, null)
                }
            }

            var A = o.memory, L = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
            this.setTexture2D = g, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = T, this.updateRenderTargetMipmap = S
        }

        function te() {
            var t = {};
            return {
                get: function (e) {
                    var n = e.uuid, i = t[n];
                    return void 0 === i && (i = {}, t[n] = i), i
                }, delete: function (e) {
                    delete t[e.uuid]
                }, clear: function () {
                    t = {}
                }
            }
        }

        function ee(t, e, n) {
            function i() {
                var e = !1, n = new r, i = null, a = new r;
                return {
                    setMask: function (n) {
                        i === n || e || (t.colorMask(n, n, n, n), i = n)
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e, i, r, o, s) {
                        s === !0 && (e *= o, i *= o, r *= o), n.set(e, i, r, o), a.equals(n) === !1 && (t.clearColor(e, i, r, o), a.copy(n))
                    }, reset: function () {
                        e = !1, i = null, a.set(0, 0, 0, 1)
                    }
                }
            }

            function a() {
                var e = !1, n = null, i = null, r = null;
                return {
                    setTest: function (e) {
                        e ? p(t.DEPTH_TEST) : f(t.DEPTH_TEST)
                    }, setMask: function (i) {
                        n === i || e || (t.depthMask(i), n = i)
                    }, setFunc: function (e) {
                        if (i !== e) {
                            if (e)switch (e) {
                                case va:
                                    t.depthFunc(t.NEVER);
                                    break;
                                case ya:
                                    t.depthFunc(t.ALWAYS);
                                    break;
                                case _a:
                                    t.depthFunc(t.LESS);
                                    break;
                                case xa:
                                    t.depthFunc(t.LEQUAL);
                                    break;
                                case ba:
                                    t.depthFunc(t.EQUAL);
                                    break;
                                case wa:
                                    t.depthFunc(t.GEQUAL);
                                    break;
                                case Ma:
                                    t.depthFunc(t.GREATER);
                                    break;
                                case Ea:
                                    t.depthFunc(t.NOTEQUAL);
                                    break;
                                default:
                                    t.depthFunc(t.LEQUAL)
                            } else t.depthFunc(t.LEQUAL);
                            i = e
                        }
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e) {
                        r !== e && (t.clearDepth(e), r = e)
                    }, reset: function () {
                        e = !1, n = null, i = null, r = null
                    }
                }
            }

            function o() {
                var e = !1, n = null, i = null, r = null, a = null, o = null, s = null, c = null, l = null;
                return {
                    setTest: function (e) {
                        e ? p(t.STENCIL_TEST) : f(t.STENCIL_TEST)
                    }, setMask: function (i) {
                        n === i || e || (t.stencilMask(i), n = i)
                    }, setFunc: function (e, n, o) {
                        i === e && r === n && a === o || (t.stencilFunc(e, n, o), i = e, r = n, a = o)
                    }, setOp: function (e, n, i) {
                        o === e && s === n && c === i || (t.stencilOp(e, n, i), o = e, s = n, c = i)
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e) {
                        l !== e && (t.clearStencil(e), l = e)
                    }, reset: function () {
                        e = !1, n = null, i = null, r = null, a = null, o = null, s = null, c = null, l = null
                    }
                }
            }

            function s(e, n, i) {
                var r = new Uint8Array(4), a = t.createTexture();
                t.bindTexture(e, a), t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
                for (var o = 0; o < i; o++)t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
                return a
            }

            function c() {
                B.setClear(0, 0, 0, 1), z.setClear(1), G.setClear(0), p(t.DEPTH_TEST), x(xa), T(!1), S(Or), p(t.CULL_FACE), p(t.BLEND), g(Zr)
            }

            function l() {
                for (var t = 0, e = H.length; t < e; t++)H[t] = 0
            }

            function u(n) {
                if (H[n] = 1, 0 === V[n] && (t.enableVertexAttribArray(n), V[n] = 1), 0 !== j[n]) {
                    var i = e.get("ANGLE_instanced_arrays");
                    i.vertexAttribDivisorANGLE(n, 0), j[n] = 0
                }
            }

            function h(e, n, i) {
                H[e] = 1, 0 === V[e] && (t.enableVertexAttribArray(e), V[e] = 1), j[e] !== n && (i.vertexAttribDivisorANGLE(e, n), j[e] = n)
            }

            function d() {
                for (var e = 0, n = V.length; e !== n; ++e)V[e] !== H[e] && (t.disableVertexAttribArray(e), V[e] = 0)
            }

            function p(e) {
                W[e] !== !0 && (t.enable(e), W[e] = !0)
            }

            function f(e) {
                W[e] !== !1 && (t.disable(e), W[e] = !1)
            }

            function m() {
                if (null === X && (X = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1")))for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++)X.push(n[i]);
                return X
            }

            function g(e, i, r, a, o, s, c, l) {
                e !== qr ? p(t.BLEND) : f(t.BLEND), e === Y && l === tt || (e === Jr ? l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD),
                    t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === Qr ? l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === Kr ? l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : l ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), Y = e, tt = l), e === $r ? (o = o || i, s = s || r, c = c || a, i === q && o === Q || (t.blendEquationSeparate(n(i), n(o)), q = i, Q = o), r === Z && a === J && s === K && c === $ || (t.blendFuncSeparate(n(r), n(a), n(s), n(c)), Z = r, J = a, K = s, $ = c)) : (q = null, Z = null, J = null, Q = null, K = null, $ = null)
            }

            function v(t) {
                B.setMask(t)
            }

            function y(t) {
                z.setTest(t)
            }

            function _(t) {
                z.setMask(t)
            }

            function x(t) {
                z.setFunc(t)
            }

            function b(t) {
                G.setTest(t)
            }

            function w(t) {
                G.setMask(t)
            }

            function M(t, e, n) {
                G.setFunc(t, e, n)
            }

            function E(t, e, n) {
                G.setOp(t, e, n)
            }

            function T(e) {
                et !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), et = e)
            }

            function S(e) {
                e !== Pr ? (p(t.CULL_FACE), e !== nt && (e === Or ? t.cullFace(t.BACK) : e === Ir ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : f(t.CULL_FACE), nt = e
            }

            function A(e) {
                e !== it && (lt && t.lineWidth(e), it = e)
            }

            function L(e, n, i) {
                e ? (p(t.POLYGON_OFFSET_FILL), rt === n && at === i || (t.polygonOffset(n, i), rt = n, at = i)) : f(t.POLYGON_OFFSET_FILL)
            }

            function R() {
                return ot
            }

            function C(e) {
                ot = e, e ? p(t.SCISSOR_TEST) : f(t.SCISSOR_TEST)
            }

            function P(e) {
                void 0 === e && (e = t.TEXTURE0 + st - 1), ut !== e && (t.activeTexture(e), ut = e)
            }

            function O(e, n) {
                null === ut && P();
                var i = ht[ut];
                void 0 === i && (i = {
                    type: void 0,
                    texture: void 0
                }, ht[ut] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || ft[e]), i.type = e, i.texture = n)
            }

            function I() {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error(t)
                }
            }

            function U() {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error(t)
                }
            }

            function N(e) {
                dt.equals(e) === !1 && (t.scissor(e.x, e.y, e.z, e.w), dt.copy(e))
            }

            function D(e) {
                pt.equals(e) === !1 && (t.viewport(e.x, e.y, e.z, e.w), pt.copy(e))
            }

            function F() {
                for (var e = 0; e < V.length; e++)1 === V[e] && (t.disableVertexAttribArray(e), V[e] = 0);
                W = {}, X = null, ut = null, ht = {}, Y = null, et = null, nt = null, B.reset(), z.reset(), G.reset()
            }

            var B = new i, z = new a, G = new o, k = t.getParameter(t.MAX_VERTEX_ATTRIBS), H = new Uint8Array(k), V = new Uint8Array(k), j = new Uint8Array(k), W = {}, X = null, Y = null, q = null, Z = null, J = null, Q = null, K = null, $ = null, tt = !1, et = null, nt = null, it = null, rt = null, at = null, ot = null, st = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), ct = parseFloat(/^WebGL\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]), lt = parseFloat(ct) >= 1, ut = null, ht = {}, dt = new r, pt = new r, ft = {};
            return ft[t.TEXTURE_2D] = s(t.TEXTURE_2D, t.TEXTURE_2D, 1), ft[t.TEXTURE_CUBE_MAP] = s(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
                buffers: {
                    color: B,
                    depth: z,
                    stencil: G
                },
                init: c,
                initAttributes: l,
                enableAttribute: u,
                enableAttributeAndDivisor: h,
                disableUnusedAttributes: d,
                enable: p,
                disable: f,
                getCompressedTextureFormats: m,
                setBlending: g,
                setColorWrite: v,
                setDepthTest: y,
                setDepthWrite: _,
                setDepthFunc: x,
                setStencilTest: b,
                setStencilWrite: w,
                setStencilFunc: M,
                setStencilOp: E,
                setFlipSided: T,
                setCullFace: S,
                setLineWidth: A,
                setPolygonOffset: L,
                getScissorTest: R,
                setScissorTest: C,
                activeTexture: P,
                bindTexture: O,
                compressedTexImage2D: I,
                texImage2D: U,
                scissor: N,
                viewport: D,
                reset: F
            }
        }

        function ne(t, e, n) {
            function i() {
                if (void 0 !== a)return a;
                var n = e.get("EXT_texture_filter_anisotropic");
                return a = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            }

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }

            var a, o = void 0 !== n.precision ? n.precision : "highp", s = r(o);
            s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
            var c = n.logarithmicDepthBuffer === !0 && !!e.get("EXT_frag_depth"), l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), h = t.getParameter(t.MAX_TEXTURE_SIZE), d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), p = t.getParameter(t.MAX_VERTEX_ATTRIBS), f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), m = t.getParameter(t.MAX_VARYING_VECTORS), g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), v = u > 0, y = !!e.get("OES_texture_float"), _ = v && y;
            return {
                getMaxAnisotropy: i,
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: c,
                maxTextures: l,
                maxVertexTextures: u,
                maxTextureSize: h,
                maxCubemapSize: d,
                maxAttributes: p,
                maxVertexUniforms: f,
                maxVaryings: m,
                maxFragmentUniforms: g,
                vertexTextures: v,
                floatFragmentTextures: y,
                floatVertexTextures: _
            }
        }

        function ie(t) {
            var e = {};
            return {
                get: function (n) {
                    if (void 0 !== e[n])return e[n];
                    var i;
                    switch (n) {
                        case"WEBGL_depth_texture":
                            i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case"EXT_texture_filter_anisotropic":
                            i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case"WEBGL_compressed_texture_s3tc":
                            i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case"WEBGL_compressed_texture_pvrtc":
                            i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case"WEBGL_compressed_texture_etc1":
                            i = t.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            i = t.getExtension(n)
                    }
                    return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = i, i
                }
            }
        }

        function re() {
            function t() {
                l.value !== i && (l.value = i, l.needsUpdate = r > 0), n.numPlanes = r, n.numIntersection = 0
            }

            function e(t, e, i, r) {
                var a = null !== t ? t.length : 0, o = null;
                if (0 !== a) {
                    if (o = l.value, r !== !0 || null === o) {
                        var u = i + 4 * a, h = e.matrixWorldInverse;
                        c.getNormalMatrix(h), (null === o || o.length < u) && (o = new Float32Array(u));
                        for (var d = 0, p = i; d !== a; ++d, p += 4)s.copy(t[d]).applyMatrix4(h, c), s.normal.toArray(o, p), o[p + 3] = s.constant
                    }
                    l.value = o, l.needsUpdate = !0
                }
                return n.numPlanes = a, o
            }

            var n = this, i = null, r = 0, a = !1, o = !1, s = new nt, c = new et, l = {value: null, needsUpdate: !1};
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (t, n, o) {
                var s = 0 !== t.length || n || 0 !== r || a;
                return a = n, i = e(t, o, 0), r = t.length, s
            }, this.beginShadows = function () {
                o = !0, e(null)
            }, this.endShadows = function () {
                o = !1, t()
            }, this.setState = function (n, s, c, u, h, d) {
                if (!a || null === n || 0 === n.length || o && !c)o ? e(null) : t(); else {
                    var p = o ? 0 : r, f = 4 * p, m = h.clippingState || null;
                    l.value = m, m = e(n, u, f, d);
                    for (var g = 0; g !== f; ++g)m[g] = i[g];
                    h.clippingState = m, this.numIntersection = s ? this.numPlanes : 0, this.numPlanes += p
                }
            }
        }

        function ae(t) {
            function e() {
                return null === pt ? Ct : 1
            }

            function n() {
                ce.init(), ce.scissor(yt.copy(Dt).multiplyScalar(Ct)), ce.viewport(xt.copy(Bt).multiplyScalar(Ct)), ce.buffers.color.setClear(wt.r, wt.g, wt.b, Mt, J)
            }

            function i() {
                ht = null, vt = null, gt = "", mt = -1, ce.reset()
            }

            function a(t) {
                t.preventDefault(), i(), n(), le.clear()
            }

            function o(t) {
                var e = t.target;
                e.removeEventListener("dispose", o), s(e)
            }

            function s(t) {
                u(t), le.delete(t)
            }

            function u(t) {
                var e = le.get(t).program;
                t.program = void 0, void 0 !== e && de.releaseProgram(e)
            }

            function h(t, e, n, i) {
                var r;
                if (n && n.isInstancedBufferGeometry && (r = oe.get("ANGLE_instanced_arrays"), null === r))return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                void 0 === i && (i = 0), ce.initAttributes();
                var a = n.attributes, o = e.getAttributes(), s = t.defaultAttributeValues;
                for (var c in o) {
                    var l = o[c];
                    if (l >= 0) {
                        var u = a[c];
                        if (void 0 !== u) {
                            var h = u.normalized, d = u.itemSize, p = he.getAttributeProperties(u), f = p.__webglBuffer, m = p.type, g = p.bytesPerElement;
                            if (u.isInterleavedBufferAttribute) {
                                var v = u.data, y = v.stride, _ = u.offset;
                                v && v.isInstancedInterleavedBuffer ? (ce.enableAttributeAndDivisor(l, v.meshPerAttribute, r), void 0 === n.maxInstancedCount && (n.maxInstancedCount = v.meshPerAttribute * v.count)) : ce.enableAttribute(l), Qt.bindBuffer(Qt.ARRAY_BUFFER, f), Qt.vertexAttribPointer(l, d, m, h, y * g, (i * y + _) * g)
                            } else u.isInstancedBufferAttribute ? (ce.enableAttributeAndDivisor(l, u.meshPerAttribute, r), void 0 === n.maxInstancedCount && (n.maxInstancedCount = u.meshPerAttribute * u.count)) : ce.enableAttribute(l), Qt.bindBuffer(Qt.ARRAY_BUFFER, f), Qt.vertexAttribPointer(l, d, m, h, 0, i * d * g)
                        } else if (void 0 !== s) {
                            var x = s[c];
                            if (void 0 !== x)switch (x.length) {
                                case 2:
                                    Qt.vertexAttrib2fv(l, x);
                                    break;
                                case 3:
                                    Qt.vertexAttrib3fv(l, x);
                                    break;
                                case 4:
                                    Qt.vertexAttrib4fv(l, x);
                                    break;
                                default:
                                    Qt.vertexAttrib1fv(l, x)
                            }
                        }
                    }
                }
                ce.disableUnusedAttributes()
            }

            function d(t, e) {
                return Math.abs(e[0]) - Math.abs(t[0])
            }

            function p(t, e) {
                return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.material.program && e.material.program && t.material.program !== e.material.program ? t.material.program.id - e.material.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function f(t, e) {
                return t.object.renderOrder !== e.object.renderOrder ? t.object.renderOrder - e.object.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function m(t, e, n, i, r) {
                var a, o;
                n.transparent ? (a = at, o = ++ot) : (a = et, o = ++nt);
                var s = a[o];
                void 0 !== s ? (s.id = t.id, s.object = t, s.geometry = e, s.material = n, s.z = Wt.z, s.group = r) : (s = {
                    id: t.id,
                    object: t,
                    geometry: e,
                    material: n,
                    z: Wt.z,
                    group: r
                }, a.push(s))
            }

            function g(t) {
                var e = t.geometry;
                return null === e.boundingSphere && e.computeBoundingSphere(), Vt.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), y(Vt)
            }

            function v(t) {
                return Vt.center.set(0, 0, 0), Vt.radius = .7071067811865476, Vt.applyMatrix4(t.matrixWorld), y(Vt)
            }

            function y(t) {
                if (!zt.intersectsSphere(t))return !1;
                var e = Gt.numPlanes;
                if (0 === e)return !0;
                var n = ut.clippingPlanes, i = t.center, r = -t.radius, a = 0;
                do if (n[a].distanceToPoint(i) < r)return !1; while (++a !== e);
                return !0
            }

            function _(t, e) {
                if (t.visible !== !1) {
                    var n = 0 !== (t.layers.mask & e.layers.mask);
                    if (n)if (t.isLight)$.push(t); else if (t.isSprite)t.frustumCulled !== !1 && v(t) !== !0 || ct.push(t); else if (t.isLensFlare)lt.push(t); else if (t.isImmediateRenderObject)ut.sortObjects === !0 && (Wt.setFromMatrixPosition(t.matrixWorld), Wt.applyProjection(jt)), m(t, null, t.material, Wt.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), t.frustumCulled === !1 || g(t) === !0)) {
                        var i = t.material;
                        if (i.visible === !0) {
                            ut.sortObjects === !0 && (Wt.setFromMatrixPosition(t.matrixWorld), Wt.applyProjection(jt));
                            var r = he.update(t);
                            if (i.isMultiMaterial)for (var a = r.groups, o = i.materials, s = 0, c = a.length; s < c; s++) {
                                var l = a[s], u = o[l.materialIndex];
                                u.visible === !0 && m(t, r, u, Wt.z, l)
                            } else m(t, r, i, Wt.z, null)
                        }
                    }
                    for (var h = t.children, s = 0, c = h.length; s < c; s++)_(h[s], e)
                }
            }

            function x(t, e, n, i) {
                for (var r = 0, a = t.length; r < a; r++) {
                    var o = t[r], s = o.object, c = o.geometry, l = void 0 === i ? o.material : i, u = o.group;
                    if (s.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, s.matrixWorld), s.normalMatrix.getNormalMatrix(s.modelViewMatrix), s.onBeforeRender(ut, e, n, c, l, u), s.isImmediateRenderObject) {
                        w(l);
                        var h = M(n, e.fog, l, s);
                        gt = "", s.render(function (t) {
                            ut.renderBufferImmediate(t, h, l)
                        })
                    } else ut.renderBufferDirect(n, e.fog, c, l, s, u);
                    s.onAfterRender(ut, e, n, c, l, u)
                }
            }

            function b(t, e, n) {
                var i = le.get(t), r = de.getParameters(t, qt, e, Gt.numPlanes, Gt.numIntersection, n), a = de.getProgramCode(t, r), s = i.program, c = !0;
                if (void 0 === s)t.addEventListener("dispose", o); else if (s.code !== a)u(t); else {
                    if (void 0 !== r.shaderID)return;
                    c = !1
                }
                if (c) {
                    if (r.shaderID) {
                        var l = ol[r.shaderID];
                        i.__webglShader = {
                            name: t.type,
                            uniforms: rs.clone(l.uniforms),
                            vertexShader: l.vertexShader,
                            fragmentShader: l.fragmentShader
                        }
                    } else i.__webglShader = {
                        name: t.type,
                        uniforms: t.uniforms,
                        vertexShader: t.vertexShader,
                        fragmentShader: t.fragmentShader
                    };
                    t.__webglShader = i.__webglShader, s = de.acquireProgram(t, r, a), i.program = s, t.program = s
                }
                var h = s.getAttributes();
                if (t.morphTargets) {
                    t.numSupportedMorphTargets = 0;
                    for (var d = 0; d < ut.maxMorphTargets; d++)h["morphTarget" + d] >= 0 && t.numSupportedMorphTargets++
                }
                if (t.morphNormals) {
                    t.numSupportedMorphNormals = 0;
                    for (var d = 0; d < ut.maxMorphNormals; d++)h["morphNormal" + d] >= 0 && t.numSupportedMorphNormals++
                }
                var p = i.__webglShader.uniforms;
                (t.isShaderMaterial || t.isRawShaderMaterial) && t.clipping !== !0 || (i.numClippingPlanes = Gt.numPlanes, i.numIntersection = Gt.numIntersection, p.clippingPlanes = Gt.uniform), i.fog = e, i.lightsHash = qt.hash, t.lights && (p.ambientLightColor.value = qt.ambient, p.directionalLights.value = qt.directional, p.spotLights.value = qt.spot, p.rectAreaLights.value = qt.rectArea, p.pointLights.value = qt.point, p.hemisphereLights.value = qt.hemi, p.directionalShadowMap.value = qt.directionalShadowMap, p.directionalShadowMatrix.value = qt.directionalShadowMatrix, p.spotShadowMap.value = qt.spotShadowMap, p.spotShadowMatrix.value = qt.spotShadowMatrix, p.pointShadowMap.value = qt.pointShadowMap, p.pointShadowMatrix.value = qt.pointShadowMatrix);
                var f = i.program.getUniforms(), m = j.seqWithValue(f.seq, p);
                i.uniformsList = m
            }

            function w(t) {
                t.side === Hr ? ce.disable(Qt.CULL_FACE) : ce.enable(Qt.CULL_FACE), ce.setFlipSided(t.side === kr), t.transparent === !0 ? ce.setBlending(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha) : ce.setBlending(qr), ce.setDepthFunc(t.depthFunc), ce.setDepthTest(t.depthTest), ce.setDepthWrite(t.depthWrite), ce.setColorWrite(t.colorWrite), ce.setPolygonOffset(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            }

            function M(t, e, n, i) {
                bt = 0;
                var r = le.get(n);
                if (kt && (Ht || t !== vt)) {
                    var a = t === vt && n.id === mt;
                    Gt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, r, a)
                }
                n.needsUpdate === !1 && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== e ? n.needsUpdate = !0 : n.lights && r.lightsHash !== qt.hash ? n.needsUpdate = !0 : void 0 === r.numClippingPlanes || r.numClippingPlanes === Gt.numPlanes && r.numIntersection === Gt.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (b(n, e, i), n.needsUpdate = !1);
                var o = !1, s = !1, c = !1, l = r.program, u = l.getUniforms(), h = r.__webglShader.uniforms;
                if (l.id !== ht && (Qt.useProgram(l.program), ht = l.id, o = !0, s = !0, c = !0), n.id !== mt && (mt = n.id, s = !0), o || t !== vt) {
                    if (u.set(Qt, t, "projectionMatrix"), se.logarithmicDepthBuffer && u.setValue(Qt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), t !== vt && (vt = t, s = !0, c = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                        var d = u.map.cameraPosition;
                        void 0 !== d && d.setValue(Qt, Wt.setFromMatrixPosition(t.matrixWorld))
                    }
                    (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && u.setValue(Qt, "viewMatrix", t.matrixWorldInverse), u.set(Qt, ut, "toneMappingExposure"), u.set(Qt, ut, "toneMappingWhitePoint")
                }
                if (n.skinning) {
                    u.setOptional(Qt, i, "bindMatrix"), u.setOptional(Qt, i, "bindMatrixInverse");
                    var p = i.skeleton;
                    p && (se.floatVertexTextures && p.useVertexTexture ? (u.set(Qt, p, "boneTexture"), u.set(Qt, p, "boneTextureWidth"), u.set(Qt, p, "boneTextureHeight")) : u.setOptional(Qt, p, "boneMatrices"))
                }
                return s && (n.lights && N(h, c), e && n.fog && L(h, e), (n.isMeshBasicMaterial || n.isMeshLambertMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.isMeshNormalMaterial || n.isMeshDepthMaterial) && E(h, n), n.isLineBasicMaterial ? T(h, n) : n.isLineDashedMaterial ? (T(h, n), S(h, n)) : n.isPointsMaterial ? A(h, n) : n.isMeshLambertMaterial ? R(h, n) : n.isMeshToonMaterial ? P(h, n) : n.isMeshPhongMaterial ? C(h, n) : n.isMeshPhysicalMaterial ? I(h, n) : n.isMeshStandardMaterial ? O(h, n) : n.isMeshDepthMaterial ? n.displacementMap && (h.displacementMap.value = n.displacementMap, h.displacementScale.value = n.displacementScale, h.displacementBias.value = n.displacementBias) : n.isMeshNormalMaterial && U(h, n), void 0 !== h.ltcMat && (h.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE), void 0 !== h.ltcMag && (h.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE), j.upload(Qt, r.uniformsList, h, ut)), u.set(Qt, i, "modelViewMatrix"), u.set(Qt, i, "normalMatrix"), u.setValue(Qt, "modelMatrix", i.matrixWorld), l
            }

            function E(t, e) {
                t.opacity.value = e.opacity, t.diffuse.value = e.color, e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), t.map.value = e.map, t.specularMap.value = e.specularMap, t.alphaMap.value = e.alphaMap, e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity);
                var n;
                if (e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n) {
                    n.isWebGLRenderTarget && (n = n.texture);
                    var i = n.offset, r = n.repeat;
                    t.offsetRepeat.value.set(i.x, i.y, r.x, r.y)
                }
                t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio
            }

            function T(t, e) {
                t.diffuse.value = e.color, t.opacity.value = e.opacity
            }

            function S(t, e) {
                t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
            }

            function A(t, e) {
                if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * Ct, t.scale.value = .5 * Tt, t.map.value = e.map, null !== e.map) {
                    var n = e.map.offset, i = e.map.repeat;
                    t.offsetRepeat.value.set(n.x, n.y, i.x, i.y)
                }
            }

            function L(t, e) {
                t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
            }

            function R(t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
            }

            function C(t, e) {
                t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function P(t, e) {
                C(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
            }

            function O(t, e) {
                t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
            }

            function I(t, e) {
                t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness, O(t, e)
            }

            function U(t, e) {
                e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
            }

            function N(t, e) {
                t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
            }

            function D(t) {
                for (var e = 0, n = 0, i = t.length; n < i; n++) {
                    var r = t[n];
                    r.castShadow && (qt.shadows[e++] = r)
                }
                qt.shadows.length = e
            }

            function F(t, e) {
                var n, i, r, a, o, s, c, u = 0, h = 0, d = 0, p = e.matrixWorldInverse, f = 0, m = 0, g = 0, v = 0, y = 0;
                for (n = 0, i = t.length; n < i; n++)if (r = t[n], a = r.color, o = r.intensity, s = r.distance, c = r.shadow && r.shadow.map ? r.shadow.map.texture : null, r.isAmbientLight)u += a.r * o, h += a.g * o, d += a.b * o; else if (r.isDirectionalLight) {
                    var _ = pe.get(r);
                    _.color.copy(r.color).multiplyScalar(r.intensity), _.direction.setFromMatrixPosition(r.matrixWorld), Wt.setFromMatrixPosition(r.target.matrixWorld), _.direction.sub(Wt), _.direction.transformDirection(p), _.shadow = r.castShadow, r.castShadow && (_.shadowBias = r.shadow.bias, _.shadowRadius = r.shadow.radius, _.shadowMapSize = r.shadow.mapSize), qt.directionalShadowMap[f] = c, qt.directionalShadowMatrix[f] = r.shadow.matrix, qt.directional[f++] = _
                } else if (r.isSpotLight) {
                    var _ = pe.get(r);
                    _.position.setFromMatrixPosition(r.matrixWorld), _.position.applyMatrix4(p), _.color.copy(a).multiplyScalar(o), _.distance = s, _.direction.setFromMatrixPosition(r.matrixWorld), Wt.setFromMatrixPosition(r.target.matrixWorld), _.direction.sub(Wt), _.direction.transformDirection(p), _.coneCos = Math.cos(r.angle), _.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)), _.decay = 0 === r.distance ? 0 : r.decay, _.shadow = r.castShadow, r.castShadow && (_.shadowBias = r.shadow.bias, _.shadowRadius = r.shadow.radius, _.shadowMapSize = r.shadow.mapSize), qt.spotShadowMap[g] = c, qt.spotShadowMatrix[g] = r.shadow.matrix, qt.spot[g++] = _
                } else if (r.isRectAreaLight) {
                    var _ = pe.get(r);
                    _.color.copy(a).multiplyScalar(o / (r.width * r.height)), _.position.setFromMatrixPosition(r.matrixWorld), _.position.applyMatrix4(p), Yt.identity(), Xt.copy(r.matrixWorld), Xt.premultiply(p), Yt.extractRotation(Xt), _.halfWidth.set(.5 * r.width, 0, 0), _.halfHeight.set(0, .5 * r.height, 0), _.halfWidth.applyMatrix4(Yt), _.halfHeight.applyMatrix4(Yt), qt.rectArea[v++] = _
                } else if (r.isPointLight) {
                    var _ = pe.get(r);
                    _.position.setFromMatrixPosition(r.matrixWorld), _.position.applyMatrix4(p), _.color.copy(r.color).multiplyScalar(r.intensity), _.distance = r.distance, _.decay = 0 === r.distance ? 0 : r.decay, _.shadow = r.castShadow, r.castShadow && (_.shadowBias = r.shadow.bias, _.shadowRadius = r.shadow.radius, _.shadowMapSize = r.shadow.mapSize), qt.pointShadowMap[m] = c, void 0 === qt.pointShadowMatrix[m] && (qt.pointShadowMatrix[m] = new l), Wt.setFromMatrixPosition(r.matrixWorld).negate(), qt.pointShadowMatrix[m].identity().setPosition(Wt), qt.point[m++] = _
                } else if (r.isHemisphereLight) {
                    var _ = pe.get(r);
                    _.direction.setFromMatrixPosition(r.matrixWorld), _.direction.transformDirection(p), _.direction.normalize(), _.skyColor.copy(r.color).multiplyScalar(o), _.groundColor.copy(r.groundColor).multiplyScalar(o), qt.hemi[y++] = _
                }
                qt.ambient[0] = u, qt.ambient[1] = h, qt.ambient[2] = d, qt.directional.length = f, qt.spot.length = g, qt.rectArea.length = v, qt.point.length = m, qt.hemi.length = y, qt.hash = f + "," + m + "," + g + "," + v + "," + y + "," + qt.shadows.length
            }

            function B() {
                var t = bt;
                return t >= se.maxTextures && console.warn("WebGLRenderer: trying to use " + t + " texture units while this GPU supports only " + se.maxTextures), bt += 1, t
            }

            function z(t) {
                var e;
                if (t === Ha)return Qt.REPEAT;
                if (t === Va)return Qt.CLAMP_TO_EDGE;
                if (t === ja)return Qt.MIRRORED_REPEAT;
                if (t === Xa)return Qt.NEAREST;
                if (t === Ya)return Qt.NEAREST_MIPMAP_NEAREST;
                if (t === qa)return Qt.NEAREST_MIPMAP_LINEAR;
                if (t === Za)return Qt.LINEAR;
                if (t === Ja)return Qt.LINEAR_MIPMAP_NEAREST;
                if (t === Qa)return Qt.LINEAR_MIPMAP_LINEAR;
                if (t === $a)return Qt.UNSIGNED_BYTE;
                if (t === so)return Qt.UNSIGNED_SHORT_4_4_4_4;
                if (t === co)return Qt.UNSIGNED_SHORT_5_5_5_1;
                if (t === lo)return Qt.UNSIGNED_SHORT_5_6_5;
                if (t === to)return Qt.BYTE;
                if (t === eo)return Qt.SHORT;
                if (t === no)return Qt.UNSIGNED_SHORT;
                if (t === io)return Qt.INT;
                if (t === ro)return Qt.UNSIGNED_INT;
                if (t === ao)return Qt.FLOAT;
                if (t === oo && (e = oe.get("OES_texture_half_float"), null !== e))return e.HALF_FLOAT_OES;
                if (t === ho)return Qt.ALPHA;
                if (t === po)return Qt.RGB;
                if (t === fo)return Qt.RGBA;
                if (t === mo)return Qt.LUMINANCE;
                if (t === go)return Qt.LUMINANCE_ALPHA;
                if (t === yo)return Qt.DEPTH_COMPONENT;
                if (t === _o)return Qt.DEPTH_STENCIL;
                if (t === ea)return Qt.FUNC_ADD;
                if (t === na)return Qt.FUNC_SUBTRACT;
                if (t === ia)return Qt.FUNC_REVERSE_SUBTRACT;
                if (t === oa)return Qt.ZERO;
                if (t === sa)return Qt.ONE;
                if (t === ca)return Qt.SRC_COLOR;
                if (t === la)return Qt.ONE_MINUS_SRC_COLOR;
                if (t === ua)return Qt.SRC_ALPHA;
                if (t === ha)return Qt.ONE_MINUS_SRC_ALPHA;
                if (t === da)return Qt.DST_ALPHA;
                if (t === pa)return Qt.ONE_MINUS_DST_ALPHA;
                if (t === fa)return Qt.DST_COLOR;
                if (t === ma)return Qt.ONE_MINUS_DST_COLOR;
                if (t === ga)return Qt.SRC_ALPHA_SATURATE;
                if ((t === xo || t === bo || t === wo || t === Mo) && (e = oe.get("WEBGL_compressed_texture_s3tc"), null !== e)) {
                    if (t === xo)return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (t === bo)return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (t === wo)return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (t === Mo)return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((t === Eo || t === To || t === So || t === Ao) && (e = oe.get("WEBGL_compressed_texture_pvrtc"), null !== e)) {
                    if (t === Eo)return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (t === To)return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (t === So)return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (t === Ao)return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (t === Lo && (e = oe.get("WEBGL_compressed_texture_etc1"), null !== e))return e.COMPRESSED_RGB_ETC1_WEBGL;
                if ((t === ra || t === aa) && (e = oe.get("EXT_blend_minmax"), null !== e)) {
                    if (t === ra)return e.MIN_EXT;
                    if (t === aa)return e.MAX_EXT
                }
                return t === uo && (e = oe.get("WEBGL_depth_texture"), null !== e) ? e.UNSIGNED_INT_24_8_WEBGL : 0
            }

            console.log("THREE.WebGLRenderer", Rr), t = t || {};
            var G = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), k = void 0 !== t.context ? t.context : null, H = void 0 !== t.alpha && t.alpha, V = void 0 === t.depth || t.depth, X = void 0 === t.stencil || t.stencil, Y = void 0 !== t.antialias && t.antialias, J = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, K = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, $ = [], et = [], nt = -1, at = [], ot = -1, st = new Float32Array(8), ct = [], lt = [];
            this.domElement = G, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Ra, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var ut = this, ht = null, pt = null, ft = null, mt = -1, gt = "", vt = null, yt = new r, _t = null, xt = new r, bt = 0, wt = new W(0), Mt = 0, Et = G.width, Tt = G.height, Ct = 1, Dt = new r(0, 0, Et, Tt), Ft = !1, Bt = new r(0, 0, Et, Tt), zt = new it, Gt = new re, kt = !1, Ht = !1, Vt = new tt, jt = new l, Wt = new c, Xt = new l, Yt = new l, qt = {
                hash: "",
                ambient: [0, 0, 0],
                directional: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotShadowMap: [],
                spotShadowMatrix: [],
                rectArea: [],
                point: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                shadows: []
            }, Zt = {calls: 0, vertices: 0, faces: 0, points: 0};
            this.info = {render: Zt, memory: {geometries: 0, textures: 0}, programs: null};
            var Qt;
            try {
                var ae = {
                    alpha: H,
                    depth: V,
                    stencil: X,
                    antialias: Y,
                    premultipliedAlpha: J,
                    preserveDrawingBuffer: K
                };
                if (Qt = k || G.getContext("webgl", ae) || G.getContext("experimental-webgl", ae), null === Qt)throw null !== G.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                void 0 === Qt.getShaderPrecisionFormat && (Qt.getShaderPrecisionFormat = function () {
                    return {rangeMin: 1, rangeMax: 1, precision: 1}
                }), G.addEventListener("webglcontextlost", a, !1)
            } catch (t) {
                console.error("THREE.WebGLRenderer: " + t)
            }
            var oe = new ie(Qt);
            oe.get("WEBGL_depth_texture"), oe.get("OES_texture_float"), oe.get("OES_texture_float_linear"), oe.get("OES_texture_half_float"), oe.get("OES_texture_half_float_linear"), oe.get("OES_standard_derivatives"), oe.get("ANGLE_instanced_arrays"), oe.get("OES_element_index_uint") && (St.MaxIndex = 4294967296);
            var se = new ne(Qt, oe, t), ce = new ee(Qt, oe, z), le = new te, ue = new $t(Qt, oe, ce, le, se, z, this.info), he = new Kt(Qt, le, this.info), de = new Jt(this, se), pe = new Nt;
            this.info.programs = de.programs;
            var fe = new Ut(Qt, oe, Zt), me = new It(Qt, oe, Zt), ge = new Ot(-1, 1, 1, -1, 0, 1), ve = new Pt, ye = new At(new Rt(2, 2), new dt({
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), _e = ol.cube, xe = new At(new Lt(5, 5, 5), new Q({
                uniforms: _e.uniforms,
                vertexShader: _e.vertexShader,
                fragmentShader: _e.fragmentShader,
                side: kr,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            }));
            n(), this.context = Qt, this.capabilities = se, this.extensions = oe, this.properties = le, this.state = ce;
            var be = new rt(this, qt, he, se);
            this.shadowMap = be;
            var we = new Z(this, ct), Me = new q(this, lt);
            this.getContext = function () {
                return Qt
            }, this.getContextAttributes = function () {
                return Qt.getContextAttributes()
            }, this.forceContextLoss = function () {
                oe.get("WEBGL_lose_context").loseContext()
            }, this.getMaxAnisotropy = function () {
                return se.getMaxAnisotropy()
            }, this.getPrecision = function () {
                return se.precision
            }, this.getPixelRatio = function () {
                return Ct
            }, this.setPixelRatio = function (t) {
                void 0 !== t && (Ct = t, this.setSize(Bt.z, Bt.w, !1))
            }, this.getSize = function () {
                return {width: Et, height: Tt}
            }, this.setSize = function (t, e, n) {
                Et = t, Tt = e, G.width = t * Ct, G.height = e * Ct, n !== !1 && (G.style.width = t + "px", G.style.height = e + "px"), this.setViewport(0, 0, t, e)
            }, this.setViewport = function (t, e, n, i) {
                ce.viewport(Bt.set(t, e, n, i))
            }, this.setScissor = function (t, e, n, i) {
                ce.scissor(Dt.set(t, e, n, i))
            }, this.setScissorTest = function (t) {
                ce.setScissorTest(Ft = t)
            }, this.getClearColor = function () {
                return wt
            }, this.setClearColor = function (t, e) {
                wt.set(t), Mt = void 0 !== e ? e : 1, ce.buffers.color.setClear(wt.r, wt.g, wt.b, Mt, J)
            }, this.getClearAlpha = function () {
                return Mt
            }, this.setClearAlpha = function (t) {
                Mt = t, ce.buffers.color.setClear(wt.r, wt.g, wt.b, Mt, J)
            }, this.clear = function (t, e, n) {
                var i = 0;
                (void 0 === t || t) && (i |= Qt.COLOR_BUFFER_BIT), (void 0 === e || e) && (i |= Qt.DEPTH_BUFFER_BIT), (void 0 === n || n) && (i |= Qt.STENCIL_BUFFER_BIT), Qt.clear(i)
            }, this.clearColor = function () {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function () {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function () {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function (t, e, n, i) {
                this.setRenderTarget(t), this.clear(e, n, i)
            }, this.resetGLState = i, this.dispose = function () {
                at = [], ot = -1, et = [], nt = -1, G.removeEventListener("webglcontextlost", a, !1)
            }, this.renderBufferImmediate = function (t, e, n) {
                ce.initAttributes();
                var i = le.get(t);
                t.hasPositions && !i.position && (i.position = Qt.createBuffer()), t.hasNormals && !i.normal && (i.normal = Qt.createBuffer()), t.hasUvs && !i.uv && (i.uv = Qt.createBuffer()), t.hasColors && !i.color && (i.color = Qt.createBuffer());
                var r = e.getAttributes();
                if (t.hasPositions && (Qt.bindBuffer(Qt.ARRAY_BUFFER, i.position), Qt.bufferData(Qt.ARRAY_BUFFER, t.positionArray, Qt.DYNAMIC_DRAW), ce.enableAttribute(r.position), Qt.vertexAttribPointer(r.position, 3, Qt.FLOAT, !1, 0, 0)), t.hasNormals) {
                    if (Qt.bindBuffer(Qt.ARRAY_BUFFER, i.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && n.shading === Vr)for (var a = 0, o = 3 * t.count; a < o; a += 9) {
                        var s = t.normalArray, c = (s[a + 0] + s[a + 3] + s[a + 6]) / 3, l = (s[a + 1] + s[a + 4] + s[a + 7]) / 3, u = (s[a + 2] + s[a + 5] + s[a + 8]) / 3;
                        s[a + 0] = c, s[a + 1] = l, s[a + 2] = u, s[a + 3] = c, s[a + 4] = l, s[a + 5] = u, s[a + 6] = c, s[a + 7] = l, s[a + 8] = u
                    }
                    Qt.bufferData(Qt.ARRAY_BUFFER, t.normalArray, Qt.DYNAMIC_DRAW), ce.enableAttribute(r.normal), Qt.vertexAttribPointer(r.normal, 3, Qt.FLOAT, !1, 0, 0)
                }
                t.hasUvs && n.map && (Qt.bindBuffer(Qt.ARRAY_BUFFER, i.uv), Qt.bufferData(Qt.ARRAY_BUFFER, t.uvArray, Qt.DYNAMIC_DRAW), ce.enableAttribute(r.uv), Qt.vertexAttribPointer(r.uv, 2, Qt.FLOAT, !1, 0, 0)), t.hasColors && n.vertexColors !== Wr && (Qt.bindBuffer(Qt.ARRAY_BUFFER, i.color), Qt.bufferData(Qt.ARRAY_BUFFER, t.colorArray, Qt.DYNAMIC_DRAW), ce.enableAttribute(r.color), Qt.vertexAttribPointer(r.color, 3, Qt.FLOAT, !1, 0, 0)), ce.disableUnusedAttributes(), Qt.drawArrays(Qt.TRIANGLES, 0, t.count), t.count = 0
            }, this.renderBufferDirect = function (t, n, i, r, a, o) {
                w(r);
                var s = M(t, n, r, a), c = !1, l = i.id + "_" + s.id + "_" + r.wireframe;
                l !== gt && (gt = l, c = !0);
                var u = a.morphTargetInfluences;
                if (void 0 !== u) {
                    for (var p = [], f = 0, m = u.length; f < m; f++) {
                        var g = u[f];
                        p.push([g, f])
                    }
                    p.sort(d), p.length > 8 && (p.length = 8);
                    for (var v = i.morphAttributes, f = 0, m = p.length; f < m; f++) {
                        var g = p[f];
                        if (st[f] = g[0], 0 !== g[0]) {
                            var y = g[1];
                            r.morphTargets === !0 && v.position && i.addAttribute("morphTarget" + f, v.position[y]), r.morphNormals === !0 && v.normal && i.addAttribute("morphNormal" + f, v.normal[y])
                        } else r.morphTargets === !0 && i.removeAttribute("morphTarget" + f), r.morphNormals === !0 && i.removeAttribute("morphNormal" + f)
                    }
                    for (var f = p.length, _ = st.length; f < _; f++)st[f] = 0;
                    s.getUniforms().setValue(Qt, "morphTargetInfluences", st), c = !0
                }
                var y = i.index, x = i.attributes.position, b = 1;
                r.wireframe === !0 && (y = he.getWireframeAttribute(i), b = 2);
                var E;
                null !== y ? (E = me, E.setIndex(y)) : E = fe, c && (h(r, s, i), null !== y && Qt.bindBuffer(Qt.ELEMENT_ARRAY_BUFFER, he.getAttributeBuffer(y)));
                var T = 0;
                null !== y ? T = y.count : void 0 !== x && (T = x.count);
                var S = i.drawRange.start * b, A = i.drawRange.count * b, L = null !== o ? o.start * b : 0, R = null !== o ? o.count * b : 1 / 0, C = Math.max(S, L), P = Math.min(T, S + A, L + R) - 1, O = Math.max(0, P - C + 1);
                if (0 !== O) {
                    if (a.isMesh)if (r.wireframe === !0)ce.setLineWidth(r.wireframeLinewidth * e()), E.setMode(Qt.LINES); else switch (a.drawMode) {
                        case Bo:
                            E.setMode(Qt.TRIANGLES);
                            break;
                        case zo:
                            E.setMode(Qt.TRIANGLE_STRIP);
                            break;
                        case Go:
                            E.setMode(Qt.TRIANGLE_FAN)
                    } else if (a.isLine) {
                        var I = r.linewidth;
                        void 0 === I && (I = 1), ce.setLineWidth(I * e()), a.isLineSegments ? E.setMode(Qt.LINES) : E.setMode(Qt.LINE_STRIP)
                    } else a.isPoints && E.setMode(Qt.POINTS);
                    i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && E.renderInstances(i, C, O) : E.render(C, O)
                }
            }, this.render = function (t, e, n, i) {
                if (void 0 !== e && e.isCamera !== !0)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                gt = "", mt = -1, vt = null, t.autoUpdate === !0 && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), e.matrixWorldInverse.getInverse(e.matrixWorld), jt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), zt.setFromMatrix(jt), $.length = 0, nt = -1, ot = -1, ct.length = 0, lt.length = 0, Ht = this.localClippingEnabled, kt = Gt.init(this.clippingPlanes, Ht, e), _(t, e), et.length = nt + 1, at.length = ot + 1, ut.sortObjects === !0 && (et.sort(p), at.sort(f)), kt && Gt.beginShadows(), D($), be.render(t, e), F($, e), kt && Gt.endShadows(), Zt.calls = 0, Zt.vertices = 0, Zt.faces = 0, Zt.points = 0, void 0 === n && (n = null), this.setRenderTarget(n);
                var r = t.background;
                if (null === r ? ce.buffers.color.setClear(wt.r, wt.g, wt.b, Mt, J) : r && r.isColor && (ce.buffers.color.setClear(r.r, r.g, r.b, 1, J), i = !0), (this.autoClear || i) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), r && r.isCubeTexture ? (ve.projectionMatrix.copy(e.projectionMatrix), ve.matrixWorld.extractRotation(e.matrixWorld), ve.matrixWorldInverse.getInverse(ve.matrixWorld), xe.material.uniforms.tCube.value = r, xe.modelViewMatrix.multiplyMatrices(ve.matrixWorldInverse, xe.matrixWorld), he.update(xe), ut.renderBufferDirect(ve, null, xe.geometry, xe.material, xe, null)) : r && r.isTexture && (ye.material.map = r, he.update(ye), ut.renderBufferDirect(ge, null, ye.geometry, ye.material, ye, null)), t.overrideMaterial) {
                    var a = t.overrideMaterial;
                    x(et, t, e, a), x(at, t, e, a)
                } else ce.setBlending(qr), x(et, t, e), x(at, t, e);
                we.render(t, e), Me.render(t, e, xt), n && ue.updateRenderTargetMipmap(n), ce.setDepthTest(!0), ce.setDepthWrite(!0), ce.setColorWrite(!0)
            }, this.setFaceCulling = function (t, e) {
                ce.setCullFace(t), ce.setFlipSided(e === Nr)
            }, this.allocTextureUnit = B, this.setTexture2D = function () {
                var t = !1;
                return function (e, n) {
                    e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), ue.setTexture2D(e, n)
                }
            }(), this.setTexture = function () {
                var t = !1;
                return function (e, n) {
                    t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), ue.setTexture2D(e, n)
                }
            }(), this.setTextureCube = function () {
                var t = !1;
                return function (e, n) {
                    e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? ue.setTextureCube(e, n) : ue.setTextureCubeDynamic(e, n)
                }
            }(), this.getCurrentRenderTarget = function () {
                return pt
            }, this.setRenderTarget = function (t) {
                pt = t, t && void 0 === le.get(t).__webglFramebuffer && ue.setupRenderTarget(t);
                var e, n = t && t.isWebGLRenderTargetCube;
                if (t) {
                    var i = le.get(t);
                    e = n ? i.__webglFramebuffer[t.activeCubeFace] : i.__webglFramebuffer, yt.copy(t.scissor), _t = t.scissorTest, xt.copy(t.viewport)
                } else e = null, yt.copy(Dt).multiplyScalar(Ct), _t = Ft, xt.copy(Bt).multiplyScalar(Ct);
                if (ft !== e && (Qt.bindFramebuffer(Qt.FRAMEBUFFER, e), ft = e), ce.scissor(yt), ce.setScissorTest(_t), ce.viewport(xt), n) {
                    var r = le.get(t.texture);
                    Qt.framebufferTexture2D(Qt.FRAMEBUFFER, Qt.COLOR_ATTACHMENT0, Qt.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                }
            }, this.readRenderTargetPixels = function (t, e, n, i, r, a) {
                if ((t && t.isWebGLRenderTarget) === !1)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                var o = le.get(t).__webglFramebuffer;
                if (o) {
                    var s = !1;
                    o !== ft && (Qt.bindFramebuffer(Qt.FRAMEBUFFER, o), s = !0);
                    try {
                        var c = t.texture, l = c.format, u = c.type;
                        if (l !== fo && z(l) !== Qt.getParameter(Qt.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(u === $a || z(u) === Qt.getParameter(Qt.IMPLEMENTATION_COLOR_READ_TYPE) || u === ao && (oe.get("OES_texture_float") || oe.get("WEBGL_color_buffer_float")) || u === oo && oe.get("EXT_color_buffer_half_float")))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        Qt.checkFramebufferStatus(Qt.FRAMEBUFFER) === Qt.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && Qt.readPixels(e, n, i, r, z(l), z(u), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && Qt.bindFramebuffer(Qt.FRAMEBUFFER, ft)
                    }
                }
            }
        }

        function oe(t, e) {
            this.name = "", this.color = new W(t), this.density = void 0 !== e ? e : 25e-5
        }

        function se(t, e, n) {
            this.name = "", this.color = new W(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
        }

        function ce() {
            ct.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
        }

        function le(t, e, n, i, r) {
            ct.call(this), this.lensFlares = [], this.positionScreen = new c, this.customUpdateCallback = void 0, void 0 !== t && this.add(t, e, n, i, r)
        }

        function ue(t) {
            J.call(this), this.type = "SpriteMaterial", this.color = new W(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.lights = !1, this.setValues(t)
        }

        function he(t) {
            ct.call(this), this.type = "Sprite", this.material = void 0 !== t ? t : new ue
        }

        function de() {
            ct.call(this), this.type = "LOD", Object.defineProperties(this, {levels: {enumerable: !0, value: []}})
        }

        function pe(t, e, n) {
            if (this.useVertexTexture = void 0 === n || n, this.identityMatrix = new l, t = t || [], this.bones = t.slice(0), this.useVertexTexture) {
                var i = Math.sqrt(4 * this.bones.length);
                i = Qo.nextPowerOfTwo(Math.ceil(i)), i = Math.max(i, 4), this.boneTextureWidth = i, this.boneTextureHeight = i, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new X(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, fo, ao)
            } else this.boneMatrices = new Float32Array(16 * this.bones.length);
            if (void 0 === e)this.calculateInverses(); else if (this.bones.length === e.length)this.boneInverses = e.slice(0); else {
                console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [];
                for (var r = 0, a = this.bones.length; r < a; r++)this.boneInverses.push(new l)
            }
        }

        function fe() {
            ct.call(this), this.type = "Bone"
        }

        function me(t, e, n) {
            At.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new l, this.bindMatrixInverse = new l;
            var i = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (var r, a, o = 0, s = this.geometry.bones.length; o < s; ++o)a = this.geometry.bones[o], r = new fe, i.push(r), r.name = a.name, r.position.fromArray(a.pos), r.quaternion.fromArray(a.rotq), void 0 !== a.scl && r.scale.fromArray(a.scl);
                for (var o = 0, s = this.geometry.bones.length; o < s; ++o)a = this.geometry.bones[o], a.parent !== -1 && null !== a.parent && void 0 !== i[a.parent] ? i[a.parent].add(i[o]) : this.add(i[o])
            }
            this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new pe(i, void 0, n), this.matrixWorld)
        }

        function ge(t) {
            J.call(this), this.type = "LineBasicMaterial", this.color = new W(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
        }

        function ve(t, e, n) {
            return 1 === n ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new ye(t, e)) : (ct.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new St, void(this.material = void 0 !== e ? e : new ge({color: 16777215 * Math.random()})))
        }

        function ye(t, e) {
            ve.call(this, t, e), this.type = "LineSegments"
        }

        function _e(t) {
            J.call(this), this.type = "PointsMaterial", this.color = new W(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(t)
        }

        function xe(t, e) {
            ct.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new St, this.material = void 0 !== e ? e : new _e({color: 16777215 * Math.random()})
        }

        function be() {
            ct.call(this), this.type = "Group"
        }

        function we(t, e, n, r, a, o, s, c, l) {
            function u() {
                requestAnimationFrame(u), t.readyState >= t.HAVE_CURRENT_DATA && (h.needsUpdate = !0)
            }

            i.call(this, t, e, n, r, a, o, s, c, l), this.generateMipmaps = !1;
            var h = this;
            u()
        }

        function Me(t, e, n, r, a, o, s, c, l, u, h, d) {
            i.call(this, null, o, s, c, l, u, r, a, h, d), this.image = {
                width: e,
                height: n
            }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
        }

        function Ee(t, e, n, r, a, o, s, c, l) {
            i.call(this, t, e, n, r, a, o, s, c, l), this.needsUpdate = !0
        }

        function Te(t, e, n, r, a, o, s, c, l, u) {
            if (u = void 0 !== u ? u : yo, u !== yo && u !== _o)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            void 0 === n && u === yo && (n = no), void 0 === n && u === _o && (n = uo), i.call(this, null, r, a, o, s, c, u, n, l), this.image = {
                width: t,
                height: e
            }, this.magFilter = void 0 !== s ? s : Xa, this.minFilter = void 0 !== c ? c : Xa, this.flipY = !1, this.generateMipmaps = !1
        }

        function Se(t) {
            function e(t, e) {
                return t - e
            }

            St.call(this);
            var n = [0, 0], i = {}, r = ["a", "b", "c"];
            if (t && t.isGeometry) {
                for (var a = t.vertices, o = t.faces, s = 0, c = new Uint32Array(6 * o.length), l = 0, u = o.length; l < u; l++)for (var h = o[l], d = 0; d < 3; d++) {
                    n[0] = h[r[d]], n[1] = h[r[(d + 1) % 3]], n.sort(e);
                    var p = n.toString();
                    void 0 === i[p] && (c[2 * s] = n[0], c[2 * s + 1] = n[1], i[p] = !0, s++)
                }
                for (var f = new Float32Array(2 * s * 3), l = 0, u = s; l < u; l++)for (var d = 0; d < 2; d++) {
                    var m = a[c[2 * l + d]], g = 6 * l + 3 * d;
                    f[g + 0] = m.x, f[g + 1] = m.y, f[g + 2] = m.z
                }
                this.addAttribute("position", new pt(f, 3))
            } else if (t && t.isBufferGeometry)if (null !== t.index) {
                var v = t.index.array, a = t.attributes.position, y = t.groups, s = 0;
                0 === y.length && t.addGroup(0, v.length);
                for (var c = new Uint32Array(2 * v.length), _ = 0, x = y.length; _ < x; ++_)for (var b = y[_], w = b.start, M = b.count, l = w, E = w + M; l < E; l += 3)for (var d = 0; d < 3; d++) {
                    n[0] = v[l + d], n[1] = v[l + (d + 1) % 3], n.sort(e);
                    var p = n.toString();
                    void 0 === i[p] && (c[2 * s] = n[0], c[2 * s + 1] = n[1], i[p] = !0, s++)
                }
                for (var f = new Float32Array(2 * s * 3), l = 0, u = s; l < u; l++)for (var d = 0; d < 2; d++) {
                    var g = 6 * l + 3 * d, T = c[2 * l + d];
                    f[g + 0] = a.getX(T), f[g + 1] = a.getY(T), f[g + 2] = a.getZ(T)
                }
                this.addAttribute("position", new pt(f, 3))
            } else {
                for (var a = t.attributes.position.array, s = a.length / 3, S = s / 3, f = new Float32Array(2 * s * 3), l = 0, u = S; l < u; l++)for (var d = 0; d < 3; d++) {
                    var g = 18 * l + 6 * d, A = 9 * l + 3 * d;
                    f[g + 0] = a[A], f[g + 1] = a[A + 1], f[g + 2] = a[A + 2];
                    var T = 9 * l + 3 * ((d + 1) % 3);
                    f[g + 3] = a[T], f[g + 4] = a[T + 1], f[g + 5] = a[T + 2]
                }
                this.addAttribute("position", new pt(f, 3))
            }
        }

        function Ae(t, e, n) {
            St.call(this), this.type = "ParametricBufferGeometry", this.parameters = {func: t, slices: e, stacks: n};
            var i, r, a, o, s, c = [], l = [], u = e + 1;
            for (i = 0; i <= n; i++)for (s = i / n, r = 0; r <= e; r++)o = r / e, a = t(o, s), c.push(a.x, a.y, a.z), l.push(o, s);
            var h, d, p, f, m = [];
            for (i = 0; i < n; i++)for (r = 0; r < e; r++)h = i * u + r, d = i * u + r + 1, p = (i + 1) * u + r + 1, f = (i + 1) * u + r, m.push(h, d, f), m.push(d, p, f);
            this.setIndex(new (m.length > 65535 ? xt : yt)(m, 1)), this.addAttribute("position", new bt(c, 3)), this.addAttribute("uv", new bt(l, 2)), this.computeVertexNormals()
        }

        function Le(t, e, n) {
            Et.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: t,
                slices: e,
                stacks: n
            }, this.fromBufferGeometry(new Ae(t, e, n)), this.mergeVertices()
        }

        function Re(t, e, i, r) {
            function a(t) {
                for (var n = new c, i = new c, r = new c, a = 0; a < e.length; a += 3)d(e[a + 0], n), d(e[a + 1], i), d(e[a + 2], r), o(n, i, r, t)
            }

            function o(t, e, n, i) {
                var r, a, o = Math.pow(2, i), s = [];
                for (r = 0; r <= o; r++) {
                    s[r] = [];
                    var c = t.clone().lerp(n, r / o), l = e.clone().lerp(n, r / o), u = o - r;
                    for (a = 0; a <= u; a++)0 === a && r === o ? s[r][a] = c : s[r][a] = c.clone().lerp(l, a / u)
                }
                for (r = 0; r < o; r++)for (a = 0; a < 2 * (o - r) - 1; a++) {
                    var d = Math.floor(a / 2);
                    a % 2 === 0 ? (h(s[r][d + 1]), h(s[r + 1][d]), h(s[r][d])) : (h(s[r][d + 1]), h(s[r + 1][d + 1]), h(s[r + 1][d]))
                }
            }

            function s(t) {
                for (var e = new c, n = 0; n < v.length; n += 3)e.x = v[n + 0], e.y = v[n + 1], e.z = v[n + 2], e.normalize().multiplyScalar(t), v[n + 0] = e.x, v[n + 1] = e.y, v[n + 2] = e.z
            }

            function l() {
                for (var t = new c, e = 0; e < v.length; e += 3) {
                    t.x = v[e + 0], t.y = v[e + 1], t.z = v[e + 2];
                    var n = m(t) / 2 / Math.PI + .5, i = g(t) / Math.PI + .5;
                    y.push(n, 1 - i)
                }
                p(), u()
            }

            function u() {
                for (var t = 0; t < y.length; t += 6) {
                    var e = y[t + 0], n = y[t + 2], i = y[t + 4], r = Math.max(e, n, i), a = Math.min(e, n, i);
                    r > .9 && a < .1 && (e < .2 && (y[t + 0] += 1), n < .2 && (y[t + 2] += 1), i < .2 && (y[t + 4] += 1))
                }
            }

            function h(t) {
                v.push(t.x, t.y, t.z)
            }

            function d(e, n) {
                var i = 3 * e;
                n.x = t[i + 0], n.y = t[i + 1], n.z = t[i + 2]
            }

            function p() {
                for (var t = new c, e = new c, i = new c, r = new c, a = new n, o = new n, s = new n, l = 0, u = 0; l < v.length; l += 9, u += 6) {
                    t.set(v[l + 0], v[l + 1], v[l + 2]), e.set(v[l + 3], v[l + 4], v[l + 5]), i.set(v[l + 6], v[l + 7], v[l + 8]), a.set(y[u + 0], y[u + 1]), o.set(y[u + 2], y[u + 3]), s.set(y[u + 4], y[u + 5]), r.copy(t).add(e).add(i).divideScalar(3);
                    var h = m(r);
                    f(a, u + 0, t, h), f(o, u + 2, e, h), f(s, u + 4, i, h)
                }
            }

            function f(t, e, n, i) {
                i < 0 && 1 === t.x && (y[e] = t.x - 1), 0 === n.x && 0 === n.z && (y[e] = i / 2 / Math.PI + .5)
            }

            function m(t) {
                return Math.atan2(t.z, -t.x)
            }

            function g(t) {
                return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
            }

            St.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: i,
                detail: r
            }, i = i || 1, r = r || 0;
            var v = [], y = [];
            a(r), s(i), l(), this.addAttribute("position", new bt(v, 3)), this.addAttribute("normal", new bt(v.slice(), 3)), this.addAttribute("uv", new bt(y, 2)), this.normalizeNormals(), this.boundingSphere = new tt(new c, i)
        }

        function Ce(t, e) {
            var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            Re.call(this, n, i, t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {radius: t, detail: e}
        }

        function Pe(t, e) {
            Et.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ce(t, e)), this.mergeVertices()
        }

        function Oe(t, e) {
            var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
            Re.call(this, n, i, t, e), this.type = "OctahedronBufferGeometry", this.parameters = {radius: t, detail: e}
        }

        function Ie(t, e) {
            Et.call(this), this.type = "OctahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Oe(t, e)), this.mergeVertices()
        }

        function Ue(t, e) {
            var n = (1 + Math.sqrt(5)) / 2, i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
            Re.call(this, i, r, t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {radius: t, detail: e}
        }

        function Ne(t, e) {
            Et.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new Ue(t, e)), this.mergeVertices()
        }

        function De(t, e) {
            var n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
            Re.call(this, r, a, t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                radius: t,
                detail: e
            }
        }

        function Fe(t, e) {
            Et.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                radius: t,
                detail: e
            }, this.fromBufferGeometry(new De(t, e)), this.mergeVertices()
        }

        function Be(t, e, n, i) {
            Et.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: i
            }, this.fromBufferGeometry(new Re(t, e, n, i)), this.mergeVertices()
        }

        function ze(t, e, i, r, a) {
            function o() {
                for (d = 0; d < e; d++)s(d);
                s(a === !1 ? e : 0), u(), l()
            }

            function s(n) {
                var a = t.getPointAt(n / e), o = h.normals[n], s = h.binormals[n];
                for (p = 0; p <= r; p++) {
                    var c = p / r * Math.PI * 2, l = Math.sin(c), u = -Math.cos(c);
                    m.x = u * o.x + l * s.x, m.y = u * o.y + l * s.y, m.z = u * o.z + l * s.z, m.normalize(), y.push(m.x, m.y, m.z), f.x = a.x + i * m.x, f.y = a.y + i * m.y, f.z = a.z + i * m.z, v.push(f.x, f.y, f.z)
                }
            }

            function l() {
                for (p = 1; p <= e; p++)for (d = 1; d <= r; d++) {
                    var t = (r + 1) * (p - 1) + (d - 1), n = (r + 1) * p + (d - 1), i = (r + 1) * p + d, a = (r + 1) * (p - 1) + d;
                    x.push(t, n, a), x.push(n, i, a)
                }
            }

            function u() {
                for (d = 0; d <= e; d++)for (p = 0; p <= r; p++)g.x = d / e, g.y = p / r, _.push(g.x, g.y)
            }

            St.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: i,
                radialSegments: r,
                closed: a
            }, e = e || 64, i = i || 1, r = r || 8, a = a || !1;
            var h = t.computeFrenetFrames(e, a);
            this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals;
            var d, p, f = new c, m = new c, g = new n, v = [], y = [], _ = [], x = [];
            o(), this.setIndex(new (x.length > 65535 ? xt : yt)(x, 1)), this.addAttribute("position", new bt(v, 3)), this.addAttribute("normal", new bt(y, 3)), this.addAttribute("uv", new bt(_, 2))
        }

        function Ge(t, e, n, i, r, a) {
            Et.call(this), this.type = "TubeGeometry", this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: r
            }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
            var o = new ze(t, e, n, i, r);
            this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
        }

        function ke(t, e, i, r, a, o) {
            function s(t, e, n, i, r) {
                var a = Math.cos(t), o = Math.sin(t), s = n / e * t, c = Math.cos(s);
                r.x = i * (2 + c) * .5 * a, r.y = i * (2 + c) * o * .5, r.z = i * Math.sin(s) * .5
            }

            St.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: i,
                radialSegments: r,
                p: a,
                q: o
            }, t = t || 100, e = e || 40, i = Math.floor(i) || 64, r = Math.floor(r) || 8, a = a || 2, o = o || 3;
            var l, u, h = (r + 1) * (i + 1), d = r * i * 2 * 3, p = new pt(new (d > 65535 ? Uint32Array : Uint16Array)(d), 1), f = new pt(new Float32Array(3 * h), 3), m = new pt(new Float32Array(3 * h), 3), g = new pt(new Float32Array(2 * h), 2), v = 0, y = 0, _ = new c, x = new c, b = new n, w = new c, M = new c, E = new c, T = new c, S = new c;
            for (l = 0; l <= i; ++l) {
                var A = l / i * a * Math.PI * 2;
                for (s(A, a, o, t, w), s(A + .01, a, o, t, M), T.subVectors(M, w), S.addVectors(M, w), E.crossVectors(T, S), S.crossVectors(E, T), E.normalize(), S.normalize(), u = 0; u <= r; ++u) {
                    var L = u / r * Math.PI * 2, R = -e * Math.cos(L), C = e * Math.sin(L);
                    _.x = w.x + (R * S.x + C * E.x), _.y = w.y + (R * S.y + C * E.y), _.z = w.z + (R * S.z + C * E.z), f.setXYZ(v, _.x, _.y, _.z), x.subVectors(_, w).normalize(), m.setXYZ(v, x.x, x.y, x.z), b.x = l / i, b.y = u / r, g.setXY(v, b.x, b.y), v++
                }
            }
            for (u = 1; u <= i; u++)for (l = 1; l <= r; l++) {
                var P = (r + 1) * (u - 1) + (l - 1), O = (r + 1) * u + (l - 1), I = (r + 1) * u + l, U = (r + 1) * (u - 1) + l;
                p.setX(y, P), y++, p.setX(y, O), y++, p.setX(y, U), y++, p.setX(y, O), y++, p.setX(y, I), y++, p.setX(y, U), y++
            }
            this.setIndex(p), this.addAttribute("position", f), this.addAttribute("normal", m), this.addAttribute("uv", g)
        }

        function He(t, e, n, i, r, a, o) {
            Et.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: n,
                radialSegments: i,
                p: r,
                q: a
            }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new ke(t, e, n, i, r, a)), this.mergeVertices()
        }

        function Ve(t, e, n, i, r) {
            St.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: n,
                tubularSegments: i,
                arc: r
            }, t = t || 100, e = e || 40, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
            var a, o, s = (n + 1) * (i + 1), l = n * i * 2 * 3, u = new (l > 65535 ? Uint32Array : Uint16Array)(l), h = new Float32Array(3 * s), d = new Float32Array(3 * s), p = new Float32Array(2 * s), f = 0, m = 0, g = 0, v = new c, y = new c, _ = new c;
            for (a = 0; a <= n; a++)for (o = 0; o <= i; o++) {
                var x = o / i * r, b = a / n * Math.PI * 2;
                y.x = (t + e * Math.cos(b)) * Math.cos(x), y.y = (t + e * Math.cos(b)) * Math.sin(x), y.z = e * Math.sin(b), h[f] = y.x, h[f + 1] = y.y, h[f + 2] = y.z, v.x = t * Math.cos(x), v.y = t * Math.sin(x), _.subVectors(y, v).normalize(), d[f] = _.x, d[f + 1] = _.y, d[f + 2] = _.z, p[m] = o / i, p[m + 1] = a / n, f += 3, m += 2
            }
            for (a = 1; a <= n; a++)for (o = 1; o <= i; o++) {
                var w = (i + 1) * a + o - 1, M = (i + 1) * (a - 1) + o - 1, E = (i + 1) * (a - 1) + o, T = (i + 1) * a + o;
                u[g] = w, u[g + 1] = M, u[g + 2] = T, u[g + 3] = M, u[g + 4] = E, u[g + 5] = T, g += 6
            }
            this.setIndex(new pt(u, 1)), this.addAttribute("position", new pt(h, 3)), this.addAttribute("normal", new pt(d, 3)), this.addAttribute("uv", new pt(p, 2))
        }

        function je(t, e, n, i, r) {
            Et.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: t,
                tube: e,
                radialSegments: n,
                tubularSegments: i,
                arc: r
            }, this.fromBufferGeometry(new Ve(t, e, n, i, r))
        }

        function We(t, e) {
            return "undefined" == typeof t ? void(t = []) : (Et.call(this), this.type = "ExtrudeGeometry", t = Array.isArray(t) ? t : [t], this.addShapeList(t, e), void this.computeFaceNormals())
        }

        function Xe(t, e) {
            e = e || {};
            var n = e.font;
            if ((n && n.isFont) === !1)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Et;
            var i = n.generateShapes(t, e.size, e.curveSegments);
            e.amount = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), We.call(this, i, e), this.type = "TextGeometry"
        }

        function Ye(t, e, n, i, r, a, o) {
            St.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: a,
                thetaLength: o
            }, t = t || 50, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : Math.PI;
            for (var s = a + o, l = (e + 1) * (n + 1), u = new pt(new Float32Array(3 * l), 3), h = new pt(new Float32Array(3 * l), 3), d = new pt(new Float32Array(2 * l), 2), p = 0, f = [], m = new c, g = 0; g <= n; g++) {
                for (var v = [], y = g / n, _ = 0; _ <= e; _++) {
                    var x = _ / e, b = -t * Math.cos(i + x * r) * Math.sin(a + y * o), w = t * Math.cos(a + y * o), M = t * Math.sin(i + x * r) * Math.sin(a + y * o);
                    m.set(b, w, M).normalize(), u.setXYZ(p, b, w, M), h.setXYZ(p, m.x, m.y, m.z), d.setXY(p, x, 1 - y), v.push(p), p++
                }
                f.push(v)
            }
            for (var E = [], g = 0; g < n; g++)for (var _ = 0; _ < e; _++) {
                var T = f[g][_ + 1], S = f[g][_], A = f[g + 1][_], L = f[g + 1][_ + 1];
                (0 !== g || a > 0) && E.push(T, S, L), (g !== n - 1 || s < Math.PI) && E.push(S, A, L)
            }
            this.setIndex(new (u.count > 65535 ? xt : yt)(E, 1)), this.addAttribute("position", u), this.addAttribute("normal", h), this.addAttribute("uv", d), this.boundingSphere = new tt(new c, t)
        }

        function qe(t, e, n, i, r, a, o) {
            Et.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: a,
                thetaLength: o
            }, this.fromBufferGeometry(new Ye(t, e, n, i, r, a, o))
        }

        function Ze(t, e, i, r, a, o) {
            St.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: i,
                phiSegments: r,
                thetaStart: a,
                thetaLength: o
            }, t = t || 20, e = e || 50, a = void 0 !== a ? a : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
            var s, l, u, h = (i + 1) * (r + 1), d = i * r * 2 * 3, p = new pt(new (d > 65535 ? Uint32Array : Uint16Array)(d), 1), f = new pt(new Float32Array(3 * h), 3), m = new pt(new Float32Array(3 * h), 3), g = new pt(new Float32Array(2 * h), 2), v = 0, y = 0, _ = t, x = (e - t) / r, b = new c, w = new n;
            for (l = 0; l <= r; l++) {
                for (u = 0; u <= i; u++)s = a + u / i * o, b.x = _ * Math.cos(s), b.y = _ * Math.sin(s), f.setXYZ(v, b.x, b.y, b.z), m.setXYZ(v, 0, 0, 1), w.x = (b.x / e + 1) / 2, w.y = (b.y / e + 1) / 2, g.setXY(v, w.x, w.y), v++;
                _ += x
            }
            for (l = 0; l < r; l++) {
                var M = l * (i + 1);
                for (u = 0; u < i; u++) {
                    s = u + M;
                    var E = s, T = s + i + 1, S = s + i + 2, A = s + 1;
                    p.setX(y, E), y++, p.setX(y, T), y++, p.setX(y, S), y++, p.setX(y, E), y++, p.setX(y, S), y++, p.setX(y, A), y++
                }
            }
            this.setIndex(p), this.addAttribute("position", f), this.addAttribute("normal", m), this.addAttribute("uv", g)
        }

        function Je(t, e, n, i, r, a) {
            Et.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: a
            }, this.fromBufferGeometry(new Ze(t, e, n, i, r, a))
        }

        function Qe(t, e, n, i) {
            Et.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i
            }, this.fromBufferGeometry(new Rt(t, e, n, i))
        }

        function Ke(t, e, i, r) {
            St.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: i,
                phiLength: r
            }, e = Math.floor(e) || 12, i = i || 0, r = r || 2 * Math.PI, r = Qo.clamp(r, 0, 2 * Math.PI);
            var a, o, s, l = (e + 1) * t.length, u = e * t.length * 2 * 3, h = new pt(new (u > 65535 ? Uint32Array : Uint16Array)(u), 1), d = new pt(new Float32Array(3 * l), 3), p = new pt(new Float32Array(2 * l), 2), f = 0, m = 0, g = 1 / e, v = new c, y = new n;
            for (o = 0; o <= e; o++) {
                var _ = i + o * g * r, x = Math.sin(_), b = Math.cos(_);
                for (s = 0; s <= t.length - 1; s++)v.x = t[s].x * x, v.y = t[s].y, v.z = t[s].x * b, d.setXYZ(f, v.x, v.y, v.z), y.x = o / e, y.y = s / (t.length - 1), p.setXY(f, y.x, y.y), f++
            }
            for (o = 0; o < e; o++)for (s = 0; s < t.length - 1; s++) {
                a = s + o * t.length;
                var w = a, M = a + t.length, E = a + t.length + 1, T = a + 1;
                h.setX(m, w), m++, h.setX(m, M), m++, h.setX(m, T), m++, h.setX(m, M), m++, h.setX(m, E), m++, h.setX(m, T), m++
            }
            if (this.setIndex(h), this.addAttribute("position", d), this.addAttribute("uv", p), this.computeVertexNormals(), r === 2 * Math.PI) {
                var S = this.attributes.normal.array, A = new c, L = new c, R = new c;
                for (a = e * t.length * 3, o = 0, s = 0; o < t.length; o++, s += 3)A.x = S[s + 0], A.y = S[s + 1], A.z = S[s + 2], L.x = S[a + s + 0], L.y = S[a + s + 1], L.z = S[a + s + 2], R.addVectors(A, L).normalize(), S[s + 0] = S[a + s + 0] = R.x, S[s + 1] = S[a + s + 1] = R.y, S[s + 2] = S[a + s + 2] = R.z
            }
        }

        function $e(t, e, n, i) {
            Et.call(this), this.type = "LatheGeometry", this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: i
            }, this.fromBufferGeometry(new Ke(t, e, n, i)), this.mergeVertices()
        }

        function tn(t, e) {
            function n(t) {
                var n, s, l, u = i.length / 3, h = t.extractPoints(e), d = h.shape, p = h.holes;
                if (hl.isClockWise(d) === !1)for (d = d.reverse(), n = 0, s = p.length; n < s; n++)l = p[n], hl.isClockWise(l) === !0 && (p[n] = l.reverse());
                var f = hl.triangulateShape(d, p);
                for (n = 0, s = p.length; n < s; n++)l = p[n], d = d.concat(l);
                for (n = 0, s = d.length; n < s; n++) {
                    var m = d[n];
                    i.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y)
                }
                for (n = 0, s = f.length; n < s; n++) {
                    var g = f[n], v = g[0] + u, y = g[1] + u, _ = g[2] + u;
                    o.push(v, y, _), c += 3
                }
            }

            St.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                shapes: t,
                curveSegments: e
            }, e = e || 12;
            var i = [], r = [], a = [], o = [], s = 0, c = 0;
            if (Array.isArray(t) === !1)n(t); else for (var l = 0; l < t.length; l++)n(t[l]), this.addGroup(s, c, l), s += c, c = 0;
            this.setIndex(new (o.length > 65535 ? xt : yt)(o, 1)), this.addAttribute("position", new bt(i, 3)), this.addAttribute("normal", new bt(r, 3)), this.addAttribute("uv", new bt(a, 2))
        }

        function en(t, e) {
            Et.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                shapes: t,
                curveSegments: e
            }, this.fromBufferGeometry(new tn(t, e)), this.mergeVertices()
        }

        function nn(t, e) {
            function n(t, e) {
                return t - e
            }

            St.call(this), e = void 0 !== e ? e : 1;
            var i, r = Math.cos(Qo.DEG2RAD * e), a = [0, 0], o = {}, s = ["a", "b", "c"];
            t.isBufferGeometry ? (i = new Et, i.fromBufferGeometry(t)) : i = t.clone(), i.mergeVertices(), i.computeFaceNormals();
            for (var c = i.vertices, l = i.faces, u = 0, h = l.length; u < h; u++)for (var d = l[u], p = 0; p < 3; p++) {
                a[0] = d[s[p]], a[1] = d[s[(p + 1) % 3]], a.sort(n);
                var f = a.toString();
                void 0 === o[f] ? o[f] = {vert1: a[0], vert2: a[1], face1: u, face2: void 0} : o[f].face2 = u
            }
            var m = [];
            for (var f in o) {
                var g = o[f];
                if (void 0 === g.face2 || l[g.face1].normal.dot(l[g.face2].normal) <= r) {
                    var v = c[g.vert1];
                    m.push(v.x), m.push(v.y), m.push(v.z), v = c[g.vert2], m.push(v.x), m.push(v.y), m.push(v.z)
                }
            }
            this.addAttribute("position", new bt(m, 3))
        }

        function rn(t, e, i, r, a, o, s, l) {
            function u() {
                var t = (r + 1) * (a + 1);
                return o === !1 && (t += (r + 1) * m + r * m), t
            }

            function h() {
                var t = r * a * 2 * 3;
                return o === !1 && (t += r * m * 3), t
            }

            function d() {
                var n, o, u = new c, h = new c, d = 0, p = (e - t) / i;
                for (o = 0; o <= a; o++) {
                    var m = [], g = o / a, v = g * (e - t) + t;
                    for (n = 0; n <= r; n++) {
                        var A = n / r, L = A * l + s, R = Math.sin(L), C = Math.cos(L);
                        h.x = v * R, h.y = -g * i + T, h.z = v * C, _.setXYZ(w, h.x, h.y, h.z), u.set(R, p, C).normalize(), x.setXYZ(w, u.x, u.y, u.z), b.setXY(w, A, 1 - g), m.push(w), w++
                    }
                    E.push(m)
                }
                for (n = 0; n < r; n++)for (o = 0; o < a; o++) {
                    var P = E[o][n], O = E[o + 1][n], I = E[o + 1][n + 1], U = E[o][n + 1];
                    y.setX(M, P), M++, y.setX(M, O), M++, y.setX(M, U), M++, y.setX(M, O), M++, y.setX(M, I), M++, y.setX(M, U), M++, d += 6
                }
                f.addGroup(S, d, 0), S += d
            }

            function p(i) {
                var a, o, u, h = new n, d = new c, p = 0, m = i === !0 ? t : e, g = i === !0 ? 1 : -1;
                for (o = w, a = 1; a <= r; a++)_.setXYZ(w, 0, T * g, 0), x.setXYZ(w, 0, g, 0), h.x = .5, h.y = .5, b.setXY(w, h.x, h.y), w++;
                for (u = w, a = 0; a <= r; a++) {
                    var v = a / r, E = v * l + s, A = Math.cos(E), L = Math.sin(E);
                    d.x = m * L, d.y = T * g, d.z = m * A, _.setXYZ(w, d.x, d.y, d.z), x.setXYZ(w, 0, g, 0), h.x = .5 * A + .5, h.y = .5 * L * g + .5, b.setXY(w, h.x, h.y), w++
                }
                for (a = 0; a < r; a++) {
                    var R = o + a, C = u + a;
                    i === !0 ? (y.setX(M, C), M++, y.setX(M, C + 1), M++, y.setX(M, R), M++) : (y.setX(M, C + 1), M++, y.setX(M, C), M++, y.setX(M, R), M++), p += 3
                }
                f.addGroup(S, p, i === !0 ? 1 : 2), S += p
            }

            St.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: i,
                radialSegments: r,
                heightSegments: a,
                openEnded: o,
                thetaStart: s,
                thetaLength: l
            };
            var f = this;
            t = void 0 !== t ? t : 20, e = void 0 !== e ? e : 20, i = void 0 !== i ? i : 100, r = Math.floor(r) || 8, a = Math.floor(a) || 1, o = void 0 !== o && o, s = void 0 !== s ? s : 0, l = void 0 !== l ? l : 2 * Math.PI;
            var m = 0;
            o === !1 && (t > 0 && m++, e > 0 && m++);
            var g = u(), v = h(), y = new pt(new (v > 65535 ? Uint32Array : Uint16Array)(v), 1), _ = new pt(new Float32Array(3 * g), 3), x = new pt(new Float32Array(3 * g), 3), b = new pt(new Float32Array(2 * g), 2), w = 0, M = 0, E = [], T = i / 2, S = 0;
            d(), o === !1 && (t > 0 && p(!0), e > 0 && p(!1)), this.setIndex(y), this.addAttribute("position", _), this.addAttribute("normal", x), this.addAttribute("uv", b)
        }

        function an(t, e, n, i, r, a, o, s) {
            Et.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: a,
                thetaStart: o,
                thetaLength: s
            }, this.fromBufferGeometry(new rn(t, e, n, i, r, a, o, s)), this.mergeVertices()
        }

        function on(t, e, n, i, r, a, o) {
            an.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: a,
                thetaLength: o
            }
        }

        function sn(t, e, n, i, r, a, o) {
            rn.call(this, 0, t, e, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: a,
                thetaLength: o
            }
        }

        function cn(t, e, n, i) {
            St.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: i
            }, t = t || 50, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, i = void 0 !== i ? i : 2 * Math.PI;
            var r = e + 2, a = new Float32Array(3 * r), o = new Float32Array(3 * r), s = new Float32Array(2 * r);
            o[2] = 1, s[0] = .5, s[1] = .5;
            for (var l = 0, u = 3, h = 2; l <= e; l++, u += 3, h += 2) {
                var d = n + l / e * i;
                a[u] = t * Math.cos(d), a[u + 1] = t * Math.sin(d), o[u + 2] = 1, s[h] = (a[u] / t + 1) / 2, s[h + 1] = (a[u + 1] / t + 1) / 2
            }
            for (var p = [], u = 1; u <= e; u++)p.push(u, u + 1, 0);
            this.setIndex(new pt(new Uint16Array(p), 1)), this.addAttribute("position", new pt(a, 3)), this.addAttribute("normal", new pt(o, 3)), this.addAttribute("uv", new pt(s, 2)), this.boundingSphere = new tt(new c, t)
        }

        function ln(t, e, n, i) {
            Et.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: i
            }, this.fromBufferGeometry(new cn(t, e, n, i))
        }

        function un(t, e, n, i, r, a) {
            Et.call(this), this.type = "BoxGeometry", this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: a
            }, this.fromBufferGeometry(new Lt(t, e, n, i, r, a)), this.mergeVertices()
        }

        function hn() {
            Q.call(this, {
                uniforms: rs.merge([al.lights, {opacity: {value: 1}}]),
                vertexShader: il.shadow_vert,
                fragmentShader: il.shadow_frag
            }), this.lights = !0, this.transparent = !0, Object.defineProperties(this, {
                opacity: {
                    enumerable: !0,
                    get: function () {
                        return this.uniforms.opacity.value
                    },
                    set: function (t) {
                        this.uniforms.opacity.value = t
                    }
                }
            })
        }

        function dn(t) {
            Q.call(this, t), this.type = "RawShaderMaterial"
        }

        function pn(t) {
            this.uuid = Qo.generateUUID(), this.type = "MultiMaterial", this.materials = Array.isArray(t) ? t : [], this.visible = !0
        }

        function fn(t) {
            J.call(this), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new W(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new W(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function mn(t) {
            fn.call(this), this.defines = {PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
        }

        function gn(t) {
            J.call(this), this.type = "MeshPhongMaterial", this.color = new W(16777215), this.specular = new W(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new W(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Ta, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function vn(t) {
            gn.call(this), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
        }

        function yn(t) {
            J.call(this, t), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1,
                this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function _n(t) {
            J.call(this), this.type = "MeshLambertMaterial", this.color = new W(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new W(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Ta, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
        }

        function xn(t) {
            J.call(this), this.type = "LineDashedMaterial", this.color = new W(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(t)
        }

        function bn(t, e, n) {
            var i = this, r = !1, a = 0, o = 0;
            this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (t) {
                o++, r === !1 && void 0 !== i.onStart && i.onStart(t, a, o), r = !0
            }, this.itemEnd = function (t) {
                a++, void 0 !== i.onProgress && i.onProgress(t, a, o), a === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
            }, this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t)
            }
        }

        function wn(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function Mn(t) {
            this.manager = void 0 !== t ? t : ml, this._parser = null
        }

        function En(t) {
            this.manager = void 0 !== t ? t : ml, this._parser = null
        }

        function Tn(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function Sn(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function An(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function Ln(t, e) {
            ct.call(this), this.type = "Light", this.color = new W(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
        }

        function Rn(t, e, n) {
            Ln.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(ct.DefaultUp), this.updateMatrix(), this.groundColor = new W(e)
        }

        function Cn(t) {
            this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.map = null, this.matrix = new l
        }

        function Pn() {
            Cn.call(this, new Pt(50, 1, .5, 500))
        }

        function On(t, e, n, i, r, a) {
            Ln.call(this, t, e), this.type = "SpotLight", this.position.copy(ct.DefaultUp), this.updateMatrix(), this.target = new ct, Object.defineProperty(this, "power", {
                get: function () {
                    return this.intensity * Math.PI
                }, set: function (t) {
                    this.intensity = t / Math.PI
                }
            }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Pn
        }

        function In(t, e, n, i) {
            Ln.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function () {
                    return 4 * this.intensity * Math.PI
                }, set: function (t) {
                    this.intensity = t / (4 * Math.PI)
                }
            }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new Cn(new Pt(90, 1, .5, 500))
        }

        function Un(t) {
            Cn.call(this, new Ot(-5, 5, 5, -5, .5, 500))
        }

        function Nn(t, e) {
            Ln.call(this, t, e), this.type = "DirectionalLight", this.position.copy(ct.DefaultUp), this.updateMatrix(), this.target = new ct, this.shadow = new Un
        }

        function Dn(t, e) {
            Ln.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
        }

        function Fn(t, e, n, i) {
            this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
        }

        function Bn(t, e, n, i) {
            Fn.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
        }

        function zn(t, e, n, i) {
            Fn.call(this, t, e, n, i)
        }

        function Gn(t, e, n, i) {
            Fn.call(this, t, e, n, i)
        }

        function kn(t, e, n, i) {
            if (void 0 === t)throw new Error("track name is undefined");
            if (void 0 === e || 0 === e.length)throw new Error("no keyframes in track named " + t);
            this.name = t, this.times = vl.convertArray(e, this.TimeBufferType), this.values = vl.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation), this.validate(), this.optimize()
        }

        function Hn(t, e, n, i) {
            kn.call(this, t, e, n, i)
        }

        function Vn(t, e, n, i) {
            Fn.call(this, t, e, n, i)
        }

        function jn(t, e, n, i) {
            kn.call(this, t, e, n, i)
        }

        function Wn(t, e, n, i) {
            kn.call(this, t, e, n, i)
        }

        function Xn(t, e, n, i) {
            kn.call(this, t, e, n, i)
        }

        function Yn(t, e, n) {
            kn.call(this, t, e, n)
        }

        function qn(t, e, n, i) {
            kn.call(this, t, e, n, i)
        }

        function Zn(t, e, n, i) {
            kn.apply(this, arguments)
        }

        function Jn(t, e, n) {
            this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = Qo.generateUUID(), this.duration < 0 && this.resetDuration(), this.optimize()
        }

        function Qn(t) {
            this.manager = void 0 !== t ? t : ml, this.textures = {}
        }

        function Kn(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function $n() {
            this.onLoadStart = function () {
            }, this.onLoadProgress = function () {
            }, this.onLoadComplete = function () {
            }
        }

        function ti(t) {
            "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = void 0), this.manager = void 0 !== t ? t : ml, this.withCredentials = !1
        }

        function ei(t) {
            this.manager = void 0 !== t ? t : ml, this.texturePath = ""
        }

        function ni() {
        }

        function ii(t, e) {
            this.v1 = t, this.v2 = e
        }

        function ri() {
            this.curves = [], this.autoClose = !1
        }

        function ai(t, e, n, i, r, a, o, s) {
            this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = s || 0
        }

        function oi(t) {
            this.points = void 0 === t ? [] : t
        }

        function si(t, e, n, i) {
            this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
        }

        function ci(t, e, n) {
            this.v0 = t, this.v1 = e, this.v2 = n
        }

        function li() {
            ui.apply(this, arguments), this.holes = []
        }

        function ui(t) {
            ri.call(this), this.currentPoint = new n, t && this.fromPoints(t)
        }

        function hi() {
            this.subPaths = [], this.currentPath = null
        }

        function di(t) {
            this.data = t
        }

        function pi(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function fi(t) {
            this.manager = void 0 !== t ? t : ml
        }

        function mi(t, e, n, i) {
            Ln.call(this, t, e), this.type = "RectAreaLight", this.position.set(0, 1, 0), this.updateMatrix(), this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
        }

        function gi() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Pt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Pt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        function vi(t, e, n) {
            ct.call(this), this.type = "CubeCamera";
            var i = 90, r = 1, a = new Pt(i, r, t, e);
            a.up.set(0, -1, 0), a.lookAt(new c(1, 0, 0)), this.add(a);
            var s = new Pt(i, r, t, e);
            s.up.set(0, -1, 0), s.lookAt(new c(-1, 0, 0)), this.add(s);
            var l = new Pt(i, r, t, e);
            l.up.set(0, 0, 1), l.lookAt(new c(0, 1, 0)), this.add(l);
            var u = new Pt(i, r, t, e);
            u.up.set(0, 0, -1), u.lookAt(new c(0, -1, 0)), this.add(u);
            var h = new Pt(i, r, t, e);
            h.up.set(0, -1, 0), h.lookAt(new c(0, 0, 1)), this.add(h);
            var d = new Pt(i, r, t, e);
            d.up.set(0, -1, 0), d.lookAt(new c(0, 0, -1)), this.add(d);
            var p = {format: po, magFilter: Za, minFilter: Za};
            this.renderTarget = new o(n, n, p), this.updateCubeMap = function (t, e) {
                null === this.parent && this.updateMatrixWorld();
                var n = this.renderTarget, i = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, a, n), n.activeCubeFace = 1, t.render(e, s, n), n.activeCubeFace = 2, t.render(e, l, n), n.activeCubeFace = 3, t.render(e, u, n), n.activeCubeFace = 4, t.render(e, h, n), n.texture.generateMipmaps = i, n.activeCubeFace = 5, t.render(e, d, n), t.setRenderTarget(null)
            }
        }

        function yi() {
            ct.call(this), this.type = "AudioListener", this.context = wl.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
        }

        function _i(t) {
            ct.call(this), this.type = "Audio", this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function xi(t) {
            _i.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
        }

        function bi(t, e) {
            this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
        }

        function wi(t, e, n) {
            this.binding = t, this.valueSize = n;
            var i, r = Float64Array;
            switch (e) {
                case"quaternion":
                    i = this._slerp;
                    break;
                case"string":
                case"bool":
                    r = Array, i = this._select;
                    break;
                default:
                    i = this._lerp
            }
            this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
        }

        function Mi(t, e, n) {
            this.path = e, this.parsedPath = n || Mi.parseTrackName(e), this.node = Mi.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
        }

        function Ei(t) {
            this.uuid = Qo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var e = {};
            this._indicesByUUID = e;
            for (var n = 0, i = arguments.length; n !== i; ++n)e[arguments[n].uuid] = n;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var r = this;
            this.stats = {
                objects: {
                    get total() {
                        return r._objects.length
                    }, get inUse() {
                        return this.total - r.nCachedObjects_
                    }
                }, get bindingsPerObject() {
                    return r._bindings.length
                }
            }
        }

        function Ti(t, e, n) {
            this._mixer = t, this._clip = e, this._localRoot = n || null;
            for (var i = e.tracks, r = i.length, a = new Array(r), o = {
                endingStart: No,
                endingEnd: No
            }, s = 0; s !== r; ++s) {
                var c = i[s].createInterpolant(null);
                a[s] = c, c.settings = o
            }
            this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Co, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
        }

        function Si(t) {
            this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
        }

        function Ai(t) {
            "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
        }

        function Li() {
            St.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function Ri(t, e, n, i) {
            this.uuid = Qo.generateUUID(), this.data = t, this.itemSize = e, this.offset = n, this.normalized = i === !0
        }

        function Ci(t, e) {
            this.uuid = Qo.generateUUID(), this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.onUploadCallback = function () {
            }, this.version = 0
        }

        function Pi(t, e, n) {
            Ci.call(this, t, e), this.meshPerAttribute = n || 1
        }

        function Oi(t, e, n) {
            pt.call(this, t, e), this.meshPerAttribute = n || 1
        }

        function Ii(t, e, n, i) {
            this.ray = new at(t, e), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {threshold: 1},
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function () {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function Ui(t, e) {
            return t.distance - e.distance
        }

        function Ni(t, e, n, i) {
            if (t.visible !== !1 && (t.raycast(e, n), i === !0))for (var r = t.children, a = 0, o = r.length; a < o; a++)Ni(r[a], e, n, !0)
        }

        function Di(t) {
            this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
        }

        function Fi(t) {
            function e(t, e, n, i, r, a, o) {
                var s = .5 * (n - t), c = .5 * (i - e);
                return (2 * (e - n) + s + c) * o + (-3 * (e - n) - 2 * s - c) * a + s * r + e
            }

            this.points = t;
            var n, i, r, a, o, s, l, u, h, d = [], p = {x: 0, y: 0, z: 0};
            this.initFromArray = function (t) {
                this.points = [];
                for (var e = 0; e < t.length; e++)this.points[e] = {x: t[e][0], y: t[e][1], z: t[e][2]}
            }, this.getPoint = function (t) {
                return n = (this.points.length - 1) * t, i = Math.floor(n), r = n - i, d[0] = 0 === i ? i : i - 1, d[1] = i, d[2] = i > this.points.length - 2 ? this.points.length - 1 : i + 1, d[3] = i > this.points.length - 3 ? this.points.length - 1 : i + 2, s = this.points[d[0]], l = this.points[d[1]], u = this.points[d[2]], h = this.points[d[3]], a = r * r, o = r * a, p.x = e(s.x, l.x, u.x, h.x, r, a, o), p.y = e(s.y, l.y, u.y, h.y, r, a, o), p.z = e(s.z, l.z, u.z, h.z, r, a, o), p
            }, this.getControlPointsArray = function () {
                var t, e, n = this.points.length, i = [];
                for (t = 0; t < n; t++)e = this.points[t], i[t] = [e.x, e.y, e.z];
                return i
            }, this.getLength = function (t) {
                var e, n, i, r, a = 0, o = 0, s = 0, l = new c, u = new c, h = [], d = 0;
                for (h[0] = 0, t || (t = 100), i = this.points.length * t, l.copy(this.points[0]), e = 1; e < i; e++)n = e / i, r = this.getPoint(n), u.copy(r), d += u.distanceTo(l), l.copy(r), a = (this.points.length - 1) * n, o = Math.floor(a), o !== s && (h[o] = d, s = o);
                return h[h.length] = d, {chunks: h, total: d}
            }, this.reparametrizeByArcLength = function (t) {
                var e, n, i, r, a, o, s, l, u = [], h = new c, d = this.getLength();
                for (u.push(h.copy(this.points[0]).clone()), e = 1; e < this.points.length; e++) {
                    for (o = d.chunks[e] - d.chunks[e - 1], s = Math.ceil(t * o / d.total), r = (e - 1) / (this.points.length - 1), a = e / (this.points.length - 1), n = 1; n < s - 1; n++)i = r + n * (1 / s) * (a - r), l = this.getPoint(i), u.push(h.copy(l).clone());
                    u.push(h.copy(this.points[e]).clone())
                }
                this.points = u
            }
        }

        function Bi(t, e, n) {
            return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
        }

        function zi(t, e, n) {
            return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
        }

        function Gi(t, e) {
            At.call(this, t, e), this.animationsMap = {}, this.animationsList = [];
            var n = this.geometry.morphTargets.length, i = "__default", r = 0, a = n - 1, o = n / 1;
            this.createAnimation(i, r, a, o), this.setAnimationWeight(i, 1)
        }

        function ki(t) {
            ct.call(this), this.material = t, this.render = function (t) {
            }
        }

        function Hi(t, e, n, i) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var r = void 0 !== n ? n : 16711680, a = void 0 !== i ? i : 1, o = 0, s = this.object.geometry;
            s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
            var c = new St, l = new bt(2 * o * 3, 3);
            c.addAttribute("position", l), ye.call(this, c, new ge({
                color: r,
                linewidth: a
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Vi(t) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
            for (var e = new St, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, r = 1, a = 32; i < a; i++, r++) {
                var o = i / a * Math.PI * 2, s = r / a * Math.PI * 2;
                n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
            }
            e.addAttribute("position", new bt(n, 3));
            var c = new ge({fog: !1});
            this.cone = new ye(e, c), this.add(this.cone), this.update()
        }

        function ji(t) {
            this.bones = this.getBoneList(t);
            for (var e = new St, n = [], i = [], r = new W(0, 0, 1), a = new W(0, 1, 0), o = 0; o < this.bones.length; o++) {
                var s = this.bones[o];
                s.parent && s.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), i.push(r.r, r.g, r.b), i.push(a.r, a.g, a.b))
            }
            e.addAttribute("position", new bt(n, 3)), e.addAttribute("color", new bt(i, 3));
            var c = new ge({vertexColors: Yr, depthTest: !1, depthWrite: !1, transparent: !0});
            ye.call(this, e, c), this.root = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function Wi(t, e) {
            this.light = t, this.light.updateMatrixWorld();
            var n = new Ye(e, 4, 2), i = new dt({wireframe: !0, fog: !1});
            i.color.copy(this.light.color).multiplyScalar(this.light.intensity), At.call(this, n, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
        }

        function Xi(t) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld();
            var e = new dt({color: t.color, fog: !1}), n = new dt({color: t.color, fog: !1, wireframe: !0}), i = new St;
            i.addAttribute("position", new pt(new Float32Array(18), 3)), this.add(new At(i, e)), this.add(new At(i, n)), this.update()
        }

        function Yi(t, e) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
            var n = new Oe(e);
            n.rotateY(.5 * Math.PI);
            var i = new dt({
                vertexColors: Yr,
                wireframe: !0
            }), r = n.getAttribute("position"), a = new Float32Array(3 * r.count);
            n.addAttribute("color", new pt(a, 3)), this.add(new At(n, i)), this.update()
        }

        function qi(t, e, n, i) {
            t = t || 10, e = e || 10, n = new W(void 0 !== n ? n : 4473924), i = new W(void 0 !== i ? i : 8947848);
            for (var r = e / 2, a = 2 * t / e, o = [], s = [], c = 0, l = 0, u = -t; c <= e; c++, u += a) {
                o.push(-t, 0, u, t, 0, u), o.push(u, 0, -t, u, 0, t);
                var h = c === r ? n : i;
                h.toArray(s, l), l += 3, h.toArray(s, l), l += 3, h.toArray(s, l), l += 3, h.toArray(s, l), l += 3
            }
            var d = new St;
            d.addAttribute("position", new bt(o, 3)), d.addAttribute("color", new bt(s, 3));
            var p = new ge({vertexColors: Yr});
            ye.call(this, d, p)
        }

        function Zi(t, e, n, i, r, a) {
            t = t || 10, e = e || 16, n = n || 8, i = i || 64, r = new W(void 0 !== r ? r : 4473924), a = new W(void 0 !== a ? a : 8947848);
            var o, s, c, l, u, h, d, p = [], f = [];
            for (l = 0; l <= e; l++)c = l / e * (2 * Math.PI), o = Math.sin(c) * t, s = Math.cos(c) * t, p.push(0, 0, 0), p.push(o, 0, s), d = 1 & l ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
            for (l = 0; l <= n; l++)for (d = 1 & l ? r : a, h = t - t / n * l, u = 0; u < i; u++)c = u / i * (2 * Math.PI), o = Math.sin(c) * h, s = Math.cos(c) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b), c = (u + 1) / i * (2 * Math.PI), o = Math.sin(c) * h, s = Math.cos(c) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b);
            var m = new St;
            m.addAttribute("position", new bt(p, 3)), m.addAttribute("color", new bt(f, 3));
            var g = new ge({vertexColors: Yr});
            ye.call(this, m, g)
        }

        function Ji(t, e, n, i) {
            this.object = t, this.size = void 0 !== e ? e : 1;
            var r = void 0 !== n ? n : 16776960, a = void 0 !== i ? i : 1, o = 0, s = this.object.geometry;
            s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            var c = new St, l = new bt(2 * o * 3, 3);
            c.addAttribute("position", l), ye.call(this, c, new ge({
                color: r,
                linewidth: a
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Qi(t, e) {
            ct.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, void 0 === e && (e = 1);
            var n = new St;
            n.addAttribute("position", new bt([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
            var i = new ge({fog: !1});
            this.add(new ve(n, i)), n = new St, n.addAttribute("position", new bt([0, 0, 0, 0, 0, 1], 3)), this.add(new ve(n, i)), this.update()
        }

        function Ki(t) {
            function e(t, e, i) {
                n(t, i), n(e, i)
            }

            function n(t, e) {
                a.push(0, 0, 0), o.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(a.length / 3 - 1)
            }

            var i = new St, r = new ge({
                color: 16777215,
                vertexColors: Xr
            }), a = [], o = [], s = {}, c = new W(16755200), l = new W(16711680), u = new W(43775), h = new W(16777215), d = new W(3355443);
            e("n1", "n2", c), e("n2", "n4", c), e("n4", "n3", c), e("n3", "n1", c), e("f1", "f2", c), e("f2", "f4", c), e("f4", "f3", c), e("f3", "f1", c), e("n1", "f1", c), e("n2", "f2", c), e("n3", "f3", c), e("n4", "f4", c), e("p", "n1", l), e("p", "n2", l), e("p", "n3", l), e("p", "n4", l), e("u1", "u2", u), e("u2", "u3", u), e("u3", "u1", u), e("c", "t", h), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), i.addAttribute("position", new bt(a, 3)), i.addAttribute("color", new bt(o, 3)), ye.call(this, i, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
        }

        function $i(t, e) {
            void 0 === e && (e = 16776960);
            var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), r = new St;
            r.setIndex(new pt(n, 1)), r.addAttribute("position", new pt(i, 3)), ye.call(this, r, new ge({color: e})), void 0 !== t && this.update(t)
        }

        function tr(t, e, n, i, r, a) {
            ct.call(this), void 0 === i && (i = 16776960), void 0 === n && (n = 1), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), this.position.copy(e), this.line = new ve(Ml, new ge({color: i})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new At(El, new dt({color: i})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, r, a)
        }

        function er(t) {
            t = t || 1;
            var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], i = new St;
            i.addAttribute("position", new bt(e, 3)), i.addAttribute("color", new bt(n, 3));
            var r = new ge({vertexColors: Yr});
            ye.call(this, i, r)
        }

        function nr(t, e, n, i, r, a) {
            ai.call(this, t, e, n, n, i, r, a)
        }

        function ir(t, e, n, i, r, a, o) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ht(t, e, n, r, a, o)
        }

        function rr(t) {
            return console.warn("THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial."), new pn(t)
        }

        function ar(t, e) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new xe(t, e)
        }

        function or(t) {
            return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new he(t)
        }

        function sr(t, e) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new xe(t, e)
        }

        function cr(t) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new _e(t)
        }

        function lr(t) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new _e(t)
        }

        function ur(t) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new _e(t)
        }

        function hr(t, e, n) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new c(t, e, n)
        }

        function dr(t, e) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new pt(t, e).setDynamic(!0)
        }

        function pr(t, e) {
            return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new ft(t, e)
        }

        function fr(t, e) {
            return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new mt(t, e)
        }

        function mr(t, e) {
            return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new gt(t, e)
        }

        function gr(t, e) {
            return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new vt(t, e)
        }

        function vr(t, e) {
            return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new yt(t, e)
        }

        function yr(t, e) {
            return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new _t(t, e)
        }

        function _r(t, e) {
            return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new xt(t, e)
        }

        function xr(t, e) {
            return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new bt(t, e)
        }

        function br(t, e) {
            return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new wt(t, e)
        }

        function wr(t) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Tl.call(this, t), this.type = "catmullrom", this.closed = !0
        }

        function Mr(t, e) {
            return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new $i(t, e)
        }

        function Er(t, e) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new ye(new nn(t.geometry), new ge({color: void 0 !== e ? e : 16777215}))
        }

        function Tr(t, e) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new ye(new Se(t.geometry), new ge({color: void 0 !== e ? e : 16777215}))
        }

        function Sr(t) {
            return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new wn(t)
        }

        function Ar() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) {
                console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
            }, this.unprojectVector = function (t, e) {
                console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
            }, this.pickingRay = function () {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }

        function Lr() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function () {
            }, this.render = function () {
            }, this.setClearColor = function () {
            }, this.setSize = function () {
            }
        }

        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function (t) {
            return t < 0 ? -1 : t > 0 ? 1 : +t
        }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
            get: function () {
                return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
            }
        }), void 0 === Object.assign && !function () {
            Object.assign = function (t) {
                if (void 0 === t || null === t)throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (void 0 !== i && null !== i)for (var r in i)Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
                }
                return e
            }
        }(), Object.assign(e.prototype, {
            addEventListener: function (t, e) {
                void 0 === this._listeners && (this._listeners = {});
                var n = this._listeners;
                void 0 === n[t] && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e)
            }, hasEventListener: function (t, e) {
                if (void 0 === this._listeners)return !1;
                var n = this._listeners;
                return void 0 !== n[t] && n[t].indexOf(e) !== -1
            }, removeEventListener: function (t, e) {
                if (void 0 !== this._listeners) {
                    var n = this._listeners, i = n[t];
                    if (void 0 !== i) {
                        var r = i.indexOf(e);
                        r !== -1 && i.splice(r, 1)
                    }
                }
            }, dispatchEvent: function (t) {
                if (void 0 !== this._listeners) {
                    var e = this._listeners, n = e[t.type];
                    if (void 0 !== n) {
                        t.target = this;
                        var i = [], r = 0, a = n.length;
                        for (r = 0; r < a; r++)i[r] = n[r];
                        for (r = 0; r < a; r++)i[r].call(this, t)
                    }
                }
            }
        });
        var Rr = "83", Cr = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        }, Pr = 0, Or = 1, Ir = 2, Ur = 3, Nr = 0, Dr = 1, Fr = 0, Br = 1, zr = 2, Gr = 0, kr = 1, Hr = 2, Vr = 1, jr = 2, Wr = 0, Xr = 1, Yr = 2, qr = 0, Zr = 1, Jr = 2, Qr = 3, Kr = 4, $r = 5, ta = {
            NoBlending: qr,
            NormalBlending: Zr,
            AdditiveBlending: Jr,
            SubtractiveBlending: Qr,
            MultiplyBlending: Kr,
            CustomBlending: $r
        }, ea = 100, na = 101, ia = 102, ra = 103, aa = 104, oa = 200, sa = 201, ca = 202, la = 203, ua = 204, ha = 205, da = 206, pa = 207, fa = 208, ma = 209, ga = 210, va = 0, ya = 1, _a = 2, xa = 3, ba = 4, wa = 5, Ma = 6, Ea = 7, Ta = 0, Sa = 1, Aa = 2, La = 0, Ra = 1, Ca = 2, Pa = 3, Oa = 4, Ia = 300, Ua = 301, Na = 302, Da = 303, Fa = 304, Ba = 305, za = 306, Ga = 307, ka = {
            UVMapping: Ia,
            CubeReflectionMapping: Ua,
            CubeRefractionMapping: Na,
            EquirectangularReflectionMapping: Da,
            EquirectangularRefractionMapping: Fa,
            SphericalReflectionMapping: Ba,
            CubeUVReflectionMapping: za,
            CubeUVRefractionMapping: Ga
        }, Ha = 1e3, Va = 1001, ja = 1002, Wa = {
            RepeatWrapping: Ha,
            ClampToEdgeWrapping: Va,
            MirroredRepeatWrapping: ja
        }, Xa = 1003, Ya = 1004, qa = 1005, Za = 1006, Ja = 1007, Qa = 1008, Ka = {
            NearestFilter: Xa,
            NearestMipMapNearestFilter: Ya,
            NearestMipMapLinearFilter: qa,
            LinearFilter: Za,
            LinearMipMapNearestFilter: Ja,
            LinearMipMapLinearFilter: Qa
        }, $a = 1009, to = 1010, eo = 1011, no = 1012, io = 1013, ro = 1014, ao = 1015, oo = 1016, so = 1017, co = 1018, lo = 1019, uo = 1020, ho = 1021, po = 1022, fo = 1023, mo = 1024, go = 1025, vo = fo, yo = 1026, _o = 1027, xo = 2001, bo = 2002, wo = 2003, Mo = 2004, Eo = 2100, To = 2101, So = 2102, Ao = 2103, Lo = 2151, Ro = 2200, Co = 2201, Po = 2202, Oo = 2300, Io = 2301, Uo = 2302, No = 2400, Do = 2401, Fo = 2402, Bo = 0, zo = 1, Go = 2, ko = 3e3, Ho = 3001, Vo = 3007, jo = 3002, Wo = 3003, Xo = 3004, Yo = 3005, qo = 3006, Zo = 3200, Jo = 3201, Qo = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function () {
                var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), n = new Array(36), i = 0;
                return function () {
                    for (var r = 0; r < 36; r++)8 === r || 13 === r || 18 === r || 23 === r ? n[r] = "-" : 14 === r ? n[r] = "4" : (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0), t = 15 & i, i >>= 4, n[r] = e[19 === r ? 3 & t | 8 : t]);
                    return n.join("")
                }
            }(),
            clamp: function (t, e, n) {
                return Math.max(e, Math.min(n, t))
            },
            euclideanModulo: function (t, e) {
                return (t % e + e) % e
            },
            mapLinear: function (t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            lerp: function (t, e, n) {
                return (1 - n) * t + n * e
            },
            smoothstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t))
            },
            smootherstep: function (t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (6 * t - 15) + 10))
            },
            randInt: function (t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function (t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function (t) {
                return t * (.5 - Math.random())
            },
            degToRad: function (t) {
                return t * Qo.DEG2RAD
            },
            radToDeg: function (t) {
                return t * Qo.RAD2DEG
            },
            isPowerOfTwo: function (t) {
                return 0 === (t & t - 1) && 0 !== t
            },
            nearestPowerOfTwo: function (t) {
                return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
            },
            nextPowerOfTwo: function (t) {
                return t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, t++, t
            }
        };
        n.prototype = {
            constructor: n, isVector2: !0, get width() {
                return this.x
            }, set width(t) {
                this.x = t
            }, get height() {
                return this.y
            }, set height(t) {
                this.y = t
            }, set: function (t, e) {
                return this.x = t, this.y = e, this
            }, setScalar: function (t) {
                return this.x = t, this.y = t, this
            }, setX: function (t) {
                return this.x = t, this
            }, setY: function (t) {
                return this.y = t, this
            }, setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, clone: function () {
                return new this.constructor(this.x, this.y)
            }, copy: function (t) {
                return this.x = t.x, this.y = t.y, this
            }, add: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
            }, addScalar: function (t) {
                return this.x += t, this.y += t, this
            }, addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this
            }, addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this
            }, sub: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
            }, subScalar: function (t) {
                return this.x -= t, this.y -= t, this
            }, subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this
            }, multiply: function (t) {
                return this.x *= t.x, this.y *= t.y, this
            }, multiplyScalar: function (t) {
                return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this
            }, divide: function (t) {
                return this.x /= t.x, this.y /= t.y, this
            }, divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            }, min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
            }, max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
            }, clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
            }, clampScalar: function () {
                var t, e;
                return function (i, r) {
                    return void 0 === t && (t = new n, e = new n), t.set(i, i), e.set(r, r), this.clamp(t, e)
                }
            }(), clampLength: function (t, e) {
                var n = this.length();
                return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n)
            }, floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }, ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }, round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }, roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
            }, negate: function () {
                return this.x = -this.x, this.y = -this.y, this
            }, dot: function (t) {
                return this.x * t.x + this.y * t.y
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }, lengthManhattan: function () {
                return Math.abs(this.x) + Math.abs(this.y)
            }, normalize: function () {
                return this.divideScalar(this.length())
            }, angle: function () {
                var t = Math.atan2(this.y, this.x);
                return t < 0 && (t += 2 * Math.PI), t
            }, distanceTo: function (t) {
                return Math.sqrt(this.distanceToSquared(t))
            }, distanceToSquared: function (t) {
                var e = this.x - t.x, n = this.y - t.y;
                return e * e + n * n
            }, distanceToManhattan: function (t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
            }, setLength: function (t) {
                return this.multiplyScalar(t / this.length())
            }, lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
            }, lerpVectors: function (t, e, n) {
                return this.subVectors(e, t).multiplyScalar(n).add(t)
            }, equals: function (t) {
                return t.x === this.x && t.y === this.y
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
            }, fromAttribute: function (t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
            }, rotateAround: function (t, e) {
                var n = Math.cos(e), i = Math.sin(e), r = this.x - t.x, a = this.y - t.y;
                return this.x = r * n - a * i + t.x, this.y = r * i + a * n + t.y, this
            }
        };
        var Ko = 0;
        i.DEFAULT_IMAGE = void 0, i.DEFAULT_MAPPING = Ia, i.prototype = {
            constructor: i, isTexture: !0, set needsUpdate(t) {
                t === !0 && this.version++
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
            }, toJSON: function (t) {
                function e(t) {
                    var e;
                    return void 0 !== t.toDataURL ? e = t : (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), e.width = t.width, e.height = t.height, e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)), e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                }

                if (void 0 !== t.textures[this.uuid])return t.textures[this.uuid];
                var n = {
                    metadata: {version: 4.4, type: "Texture", generator: "Texture.toJSON"},
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    wrap: [this.wrapS, this.wrapT],
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY
                };
                if (void 0 !== this.image) {
                    var i = this.image;
                    void 0 === i.uuid && (i.uuid = Qo.generateUUID()), void 0 === t.images[i.uuid] && (t.images[i.uuid] = {
                        uuid: i.uuid,
                        url: e(i)
                    }), n.image = i.uuid
                }
                return t.textures[this.uuid] = n, n
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }, transformUv: function (t) {
                if (this.mapping === Ia) {
                    if (t.multiply(this.repeat), t.add(this.offset), t.x < 0 || t.x > 1)switch (this.wrapS) {
                        case Ha:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case Va:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case ja:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1)switch (this.wrapT) {
                        case Ha:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case Va:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case ja:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    this.flipY && (t.y = 1 - t.y)
                }
            }
        }, Object.assign(i.prototype, e.prototype), r.prototype = {
            constructor: r,
            isVector4: !0,
            set: function (t, e, n, i) {
                return this.x = t, this.y = e, this.z = n, this.w = i, this
            },
            setScalar: function (t) {
                return this.x = t, this.y = t, this.z = t, this.w = t, this
            },
            setX: function (t) {
                return this.x = t, this
            },
            setY: function (t) {
                return this.y = t, this
            },
            setZ: function (t) {
                return this.z = t, this
            },
            setW: function (t) {
                return this.w = t, this
            },
            setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    case 3:
                        this.w = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            },
            getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            },
            clone: function () {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function (t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
            },
            add: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
            },
            addScalar: function (t) {
                return this.x += t, this.y += t, this.z += t, this.w += t, this
            },
            addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
            },
            addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
            },
            sub: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
            },
            subScalar: function (t) {
                return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
            },
            subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
            },
            multiplyScalar: function (t) {
                return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t, this.w *= t) : (this.x = 0, this.y = 0, this.z = 0, this.w = 0), this
            },
            applyMatrix4: function (t) {
                var e = this.x, n = this.y, i = this.z, r = this.w, a = t.elements;
                return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r, this
            },
            divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            },
            setAxisAngleFromQuaternion: function (t) {
                this.w = 2 * Math.acos(t.w);
                var e = Math.sqrt(1 - t.w * t.w);
                return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
            },
            setAxisAngleFromRotationMatrix: function (t) {
                var e, n, i, r, a = .01, o = .1, s = t.elements, c = s[0], l = s[4], u = s[8], h = s[1], d = s[5], p = s[9], f = s[2], m = s[6], g = s[10];
                if (Math.abs(l - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                    if (Math.abs(l + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(c + d + g - 3) < o)return this.set(1, 0, 0, 0), this;
                    e = Math.PI;
                    var v = (c + 1) / 2, y = (d + 1) / 2, _ = (g + 1) / 2, x = (l + h) / 4, b = (u + f) / 4, w = (p + m) / 4;
                    return v > y && v > _ ? v < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(v), i = x / n, r = b / n) : y > _ ? y < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(y), n = x / i, r = w / i) : _ < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(_), n = b / r, i = w / r), this.set(n, i, r, e), this
                }
                var M = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));
                return Math.abs(M) < .001 && (M = 1), this.x = (m - p) / M, this.y = (u - f) / M, this.z = (h - l) / M, this.w = Math.acos((c + d + g - 1) / 2), this
            },
            min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
            },
            max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
            },
            clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
            },
            clampScalar: function () {
                var t, e;
                return function (n, i) {
                    return void 0 === t && (t = new r, e = new r), t.set(n, n, n, n), e.set(i, i, i, i), this.clamp(t, e)
                }
            }(),
            floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function (t) {
                return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
            },
            lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            lengthManhattan: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function () {
                return this.divideScalar(this.length())
            },
            setLength: function (t) {
                return this.multiplyScalar(t / this.length())
            },
            lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
            },
            lerpVectors: function (t, e, n) {
                return this.subVectors(e, t).multiplyScalar(n).add(t)
            },
            equals: function (t) {
                return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
            },
            fromAttribute: function (t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
            }
        }, Object.assign(a.prototype, e.prototype, {
            isWebGLRenderTarget: !0, setSize: function (t, e) {
                this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }), o.prototype = Object.create(a.prototype), o.prototype.constructor = o, o.prototype.isWebGLRenderTargetCube = !0, s.prototype = {
            constructor: s,
            get x() {
                return this._x
            },
            set x(t) {
                this._x = t, this.onChangeCallback()
            },
            get y() {
                return this._y
            },
            set y(t) {
                this._y = t, this.onChangeCallback()
            },
            get z() {
                return this._z
            },
            set z(t) {
                this._z = t, this.onChangeCallback()
            },
            get w() {
                return this._w
            },
            set w(t) {
                this._w = t, this.onChangeCallback()
            },
            set: function (t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._w = i, this.onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function (t) {
                return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
            },
            setFromEuler: function (t, e) {
                if ((t && t.isEuler) === !1)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                var n = Math.cos(t._x / 2), i = Math.cos(t._y / 2), r = Math.cos(t._z / 2), a = Math.sin(t._x / 2), o = Math.sin(t._y / 2), s = Math.sin(t._z / 2), c = t.order;
                return "XYZ" === c ? (this._x = a * i * r + n * o * s, this._y = n * o * r - a * i * s, this._z = n * i * s + a * o * r, this._w = n * i * r - a * o * s) : "YXZ" === c ? (this._x = a * i * r + n * o * s, this._y = n * o * r - a * i * s, this._z = n * i * s - a * o * r, this._w = n * i * r + a * o * s) : "ZXY" === c ? (this._x = a * i * r - n * o * s, this._y = n * o * r + a * i * s, this._z = n * i * s + a * o * r, this._w = n * i * r - a * o * s) : "ZYX" === c ? (this._x = a * i * r - n * o * s, this._y = n * o * r + a * i * s, this._z = n * i * s - a * o * r, this._w = n * i * r + a * o * s) : "YZX" === c ? (this._x = a * i * r + n * o * s, this._y = n * o * r + a * i * s, this._z = n * i * s - a * o * r, this._w = n * i * r - a * o * s) : "XZY" === c && (this._x = a * i * r - n * o * s, this._y = n * o * r - a * i * s, this._z = n * i * s + a * o * r, this._w = n * i * r + a * o * s), e !== !1 && this.onChangeCallback(), this
            },
            setFromAxisAngle: function (t, e) {
                var n = e / 2, i = Math.sin(n);
                return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
            },
            setFromRotationMatrix: function (t) {
                var e, n = t.elements, i = n[0], r = n[4], a = n[8], o = n[1], s = n[5], c = n[9], l = n[2], u = n[6], h = n[10], d = i + s + h;
                return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (u - c) * e, this._y = (a - l) * e, this._z = (o - r) * e) : i > s && i > h ? (e = 2 * Math.sqrt(1 + i - s - h), this._w = (u - c) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (a + l) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - i - h), this._w = (a - l) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (c + u) / e) : (e = 2 * Math.sqrt(1 + h - i - s), this._w = (o - r) / e, this._x = (a + l) / e, this._y = (c + u) / e, this._z = .25 * e), this.onChangeCallback(), this
            },
            setFromUnitVectors: function () {
                var t, e, n = 1e-6;
                return function (i, r) {
                    return void 0 === t && (t = new c), e = i.dot(r) + 1, e < n ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, r), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
                }
            }(),
            inverse: function () {
                return this.conjugate().normalize()
            },
            conjugate: function () {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            },
            dot: function (t) {
                return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            },
            lengthSq: function () {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function () {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function () {
                var t = this.length();
                return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
            },
            multiply: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
            },
            premultiply: function (t) {
                return this.multiplyQuaternions(t, this)
            },
            multiplyQuaternions: function (t, e) {
                var n = t._x, i = t._y, r = t._z, a = t._w, o = e._x, s = e._y, c = e._z, l = e._w;
                return this._x = n * l + a * o + i * c - r * s, this._y = i * l + a * s + r * o - n * c, this._z = r * l + a * c + n * s - i * o, this._w = a * l - n * o - i * s - r * c, this.onChangeCallback(), this
            },
            slerp: function (t, e) {
                if (0 === e)return this;
                if (1 === e)return this.copy(t);
                var n = this._x, i = this._y, r = this._z, a = this._w, o = a * t._w + n * t._x + i * t._y + r * t._z;
                if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1)return this._w = a, this._x = n, this._y = i, this._z = r, this;
                var s = Math.sqrt(1 - o * o);
                if (Math.abs(s) < .001)return this._w = .5 * (a + this._w), this._x = .5 * (n + this._x), this._y = .5 * (i + this._y), this._z = .5 * (r + this._z), this;
                var c = Math.atan2(s, o), l = Math.sin((1 - e) * c) / s, u = Math.sin(e * c) / s;
                return this._w = a * l + this._w * u, this._x = n * l + this._x * u, this._y = i * l + this._y * u, this._z = r * l + this._z * u, this.onChangeCallback(), this
            },
            equals: function (t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
            },
            fromArray: function (t, e) {
                return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
            },
            onChange: function (t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function () {
            }
        }, Object.assign(s, {
            slerp: function (t, e, n, i) {
                return n.copy(t).slerp(e, i)
            }, slerpFlat: function (t, e, n, i, r, a, o) {
                var s = n[i + 0], c = n[i + 1], l = n[i + 2], u = n[i + 3], h = r[a + 0], d = r[a + 1], p = r[a + 2], f = r[a + 3];
                if (u !== f || s !== h || c !== d || l !== p) {
                    var m = 1 - o, g = s * h + c * d + l * p + u * f, v = g >= 0 ? 1 : -1, y = 1 - g * g;
                    if (y > Number.EPSILON) {
                        var _ = Math.sqrt(y), x = Math.atan2(_, g * v);
                        m = Math.sin(m * x) / _, o = Math.sin(o * x) / _
                    }
                    var b = o * v;
                    if (s = s * m + h * b, c = c * m + d * b, l = l * m + p * b, u = u * m + f * b, m === 1 - o) {
                        var w = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                        s *= w, c *= w, l *= w, u *= w
                    }
                }
                t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = u
            }
        }), c.prototype = {
            constructor: c, isVector3: !0, set: function (t, e, n) {
                return this.x = t, this.y = e, this.z = n, this
            }, setScalar: function (t) {
                return this.x = t, this.y = t, this.z = t, this
            }, setX: function (t) {
                return this.x = t, this
            }, setY: function (t) {
                return this.y = t, this
            }, setZ: function (t) {
                return this.z = t, this
            }, setComponent: function (t, e) {
                switch (t) {
                    case 0:
                        this.x = e;
                        break;
                    case 1:
                        this.y = e;
                        break;
                    case 2:
                        this.z = e;
                        break;
                    default:
                        throw new Error("index is out of range: " + t)
                }
                return this
            }, getComponent: function (t) {
                switch (t) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + t)
                }
            }, clone: function () {
                return new this.constructor(this.x, this.y, this.z)
            }, copy: function (t) {
                return this.x = t.x, this.y = t.y, this.z = t.z, this
            }, add: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
            }, addScalar: function (t) {
                return this.x += t, this.y += t, this.z += t, this
            }, addVectors: function (t, e) {
                return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
            }, addScaledVector: function (t, e) {
                return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
            }, sub: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
            }, subScalar: function (t) {
                return this.x -= t, this.y -= t, this.z -= t, this
            }, subVectors: function (t, e) {
                return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
            }, multiply: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
            }, multiplyScalar: function (t) {
                return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this
            }, multiplyVectors: function (t, e) {
                return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
            }, applyEuler: function () {
                var t;
                return function (e) {
                    return (e && e.isEuler) === !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), void 0 === t && (t = new s), this.applyQuaternion(t.setFromEuler(e))
                }
            }(), applyAxisAngle: function () {
                var t;
                return function (e, n) {
                    return void 0 === t && (t = new s), this.applyQuaternion(t.setFromAxisAngle(e, n))
                }
            }(), applyMatrix3: function (t) {
                var e = this.x, n = this.y, i = this.z, r = t.elements;
                return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
            }, applyMatrix4: function (t) {
                var e = this.x, n = this.y, i = this.z, r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i + r[12], this.y = r[1] * e + r[5] * n + r[9] * i + r[13], this.z = r[2] * e + r[6] * n + r[10] * i + r[14], this
            }, applyProjection: function (t) {
                var e = this.x, n = this.y, i = this.z, r = t.elements, a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a, this
            }, applyQuaternion: function (t) {
                var e = this.x, n = this.y, i = this.z, r = t.x, a = t.y, o = t.z, s = t.w, c = s * e + a * i - o * n, l = s * n + o * e - r * i, u = s * i + r * n - a * e, h = -r * e - a * n - o * i;
                return this.x = c * s + h * -r + l * -o - u * -a, this.y = l * s + h * -a + u * -r - c * -o, this.z = u * s + h * -o + c * -a - l * -r, this
            }, project: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)), this.applyProjection(t)
                }
            }(), unproject: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)), this.applyProjection(t)
                }
            }(), transformDirection: function (t) {
                var e = this.x, n = this.y, i = this.z, r = t.elements;
                return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
            }, divide: function (t) {
                return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
            }, divideScalar: function (t) {
                return this.multiplyScalar(1 / t)
            }, min: function (t) {
                return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
            }, max: function (t) {
                return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
            }, clamp: function (t, e) {
                return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
            }, clampScalar: function () {
                var t, e;
                return function (n, i) {
                    return void 0 === t && (t = new c, e = new c), t.set(n, n, n), e.set(i, i, i), this.clamp(t, e)
                }
            }(), clampLength: function (t, e) {
                var n = this.length();
                return this.multiplyScalar(Math.max(t, Math.min(e, n)) / n)
            }, floor: function () {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }, ceil: function () {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }, round: function () {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }, roundToZero: function () {
                return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
            }, negate: function () {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }, dot: function (t) {
                return this.x * t.x + this.y * t.y + this.z * t.z
            }, lengthSq: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }, length: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }, lengthManhattan: function () {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }, normalize: function () {
                return this.divideScalar(this.length())
            }, setLength: function (t) {
                return this.multiplyScalar(t / this.length())
            }, lerp: function (t, e) {
                return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
            }, lerpVectors: function (t, e, n) {
                return this.subVectors(e, t).multiplyScalar(n).add(t)
            }, cross: function (t, e) {
                if (void 0 !== e)return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e);
                var n = this.x, i = this.y, r = this.z;
                return this.x = i * t.z - r * t.y, this.y = r * t.x - n * t.z, this.z = n * t.y - i * t.x, this
            }, crossVectors: function (t, e) {
                var n = t.x, i = t.y, r = t.z, a = e.x, o = e.y, s = e.z;
                return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this
            }, projectOnVector: function (t) {
                var e = t.dot(this) / t.lengthSq();
                return this.copy(t).multiplyScalar(e)
            }, projectOnPlane: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new c), t.copy(this).projectOnVector(e), this.sub(t)
                }
            }(), reflect: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new c), this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                }
            }(), angleTo: function (t) {
                var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                return Math.acos(Qo.clamp(e, -1, 1))
            }, distanceTo: function (t) {
                return Math.sqrt(this.distanceToSquared(t))
            }, distanceToSquared: function (t) {
                var e = this.x - t.x, n = this.y - t.y, i = this.z - t.z;
                return e * e + n * n + i * i
            }, distanceToManhattan: function (t) {
                return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
            }, setFromSpherical: function (t) {
                var e = Math.sin(t.phi) * t.radius;
                return this.x = e * Math.sin(t.theta), this.y = Math.cos(t.phi) * t.radius, this.z = e * Math.cos(t.theta), this
            }, setFromCylindrical: function (t) {
                return this.x = t.radius * Math.sin(t.theta), this.y = t.y, this.z = t.radius * Math.cos(t.theta), this
            }, setFromMatrixPosition: function (t) {
                return this.setFromMatrixColumn(t, 3)
            }, setFromMatrixScale: function (t) {
                var e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), i = this.setFromMatrixColumn(t, 2).length();
                return this.x = e, this.y = n, this.z = i, this
            }, setFromMatrixColumn: function (t, e) {
                if ("number" == typeof t) {
                    console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                    var n = t;
                    t = e, e = n
                }
                return this.fromArray(t.elements, 4 * e)
            }, equals: function (t) {
                return t.x === this.x && t.y === this.y && t.z === this.z
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
            }, fromAttribute: function (t, e, n) {
                return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
            }
        }, l.prototype = {
            constructor: l,
            isMatrix4: !0,
            set: function (t, e, n, i, r, a, o, s, c, l, u, h, d, p, f, m) {
                var g = this.elements;
                return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = c, g[6] = l, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
            },
            identity: function () {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function () {
                return (new l).fromArray(this.elements)
            },
            copy: function (t) {
                return this.elements.set(t.elements), this
            },
            copyPosition: function (t) {
                var e = this.elements, n = t.elements;
                return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
            },
            extractBasis: function (t, e, n) {
                return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function (t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function () {
                var t;
                return function (e) {
                    void 0 === t && (t = new c);
                    var n = this.elements, i = e.elements, r = 1 / t.setFromMatrixColumn(e, 0).length(), a = 1 / t.setFromMatrixColumn(e, 1).length(), o = 1 / t.setFromMatrixColumn(e, 2).length();
                    return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[4] = i[4] * a, n[5] = i[5] * a, n[6] = i[6] * a, n[8] = i[8] * o, n[9] = i[9] * o, n[10] = i[10] * o, this
                }
            }(),
            makeRotationFromEuler: function (t) {
                (t && t.isEuler) === !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements, n = t.x, i = t.y, r = t.z, a = Math.cos(n), o = Math.sin(n), s = Math.cos(i), c = Math.sin(i), l = Math.cos(r), u = Math.sin(r);
                if ("XYZ" === t.order) {
                    var h = a * l, d = a * u, p = o * l, f = o * u;
                    e[0] = s * l, e[4] = -s * u, e[8] = c, e[1] = d + p * c, e[5] = h - f * c, e[9] = -o * s, e[2] = f - h * c, e[6] = p + d * c, e[10] = a * s
                } else if ("YXZ" === t.order) {
                    var m = s * l, g = s * u, v = c * l, y = c * u;
                    e[0] = m + y * o, e[4] = v * o - g, e[8] = a * c, e[1] = a * u, e[5] = a * l, e[9] = -o, e[2] = g * o - v, e[6] = y + m * o, e[10] = a * s
                } else if ("ZXY" === t.order) {
                    var m = s * l, g = s * u, v = c * l, y = c * u;
                    e[0] = m - y * o, e[4] = -a * u, e[8] = v + g * o, e[1] = g + v * o, e[5] = a * l, e[9] = y - m * o, e[2] = -a * c, e[6] = o, e[10] = a * s
                } else if ("ZYX" === t.order) {
                    var h = a * l, d = a * u, p = o * l, f = o * u;
                    e[0] = s * l, e[4] = p * c - d, e[8] = h * c + f, e[1] = s * u, e[5] = f * c + h, e[9] = d * c - p, e[2] = -c, e[6] = o * s, e[10] = a * s
                } else if ("YZX" === t.order) {
                    var _ = a * s, x = a * c, b = o * s, w = o * c;
                    e[0] = s * l, e[4] = w - _ * u, e[8] = b * u + x, e[1] = u, e[5] = a * l, e[9] = -o * l, e[2] = -c * l, e[6] = x * u + b, e[10] = _ - w * u
                } else if ("XZY" === t.order) {
                    var _ = a * s, x = a * c, b = o * s, w = o * c;
                    e[0] = s * l, e[4] = -u, e[8] = c * l, e[1] = _ * u + w, e[5] = a * l, e[9] = x * u - b, e[2] = b * u - x, e[6] = o * l, e[10] = w * u + _
                }
                return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            makeRotationFromQuaternion: function (t) {
                var e = this.elements, n = t.x, i = t.y, r = t.z, a = t.w, o = n + n, s = i + i, c = r + r, l = n * o, u = n * s, h = n * c, d = i * s, p = i * c, f = r * c, m = a * o, g = a * s, v = a * c;
                return e[0] = 1 - (d + f), e[4] = u - v, e[8] = h + g, e[1] = u + v, e[5] = 1 - (l + f), e[9] = p - m, e[2] = h - g, e[6] = p + m, e[10] = 1 - (l + d), e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
            },
            lookAt: function () {
                var t, e, n;
                return function (i, r, a) {
                    void 0 === t && (t = new c, e = new c, n = new c);
                    var o = this.elements;
                    return n.subVectors(i, r).normalize(), 0 === n.lengthSq() && (n.z = 1), t.crossVectors(a, n).normalize(), 0 === t.lengthSq() && (n.z += 1e-4, t.crossVectors(a, n).normalize()), e.crossVectors(n, t), o[0] = t.x, o[4] = e.x, o[8] = n.x, o[1] = t.y, o[5] = e.y, o[9] = n.y, o[2] = t.z, o[6] = e.z, o[10] = n.z, this
                }
            }(),
            multiply: function (t, e) {
                return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function (t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function (t, e) {
                var n = t.elements, i = e.elements, r = this.elements, a = n[0], o = n[4], s = n[8], c = n[12], l = n[1], u = n[5], h = n[9], d = n[13], p = n[2], f = n[6], m = n[10], g = n[14], v = n[3], y = n[7], _ = n[11], x = n[15], b = i[0], w = i[4], M = i[8], E = i[12], T = i[1], S = i[5], A = i[9], L = i[13], R = i[2], C = i[6], P = i[10], O = i[14], I = i[3], U = i[7], N = i[11], D = i[15];
                return r[0] = a * b + o * T + s * R + c * I, r[4] = a * w + o * S + s * C + c * U, r[8] = a * M + o * A + s * P + c * N, r[12] = a * E + o * L + s * O + c * D, r[1] = l * b + u * T + h * R + d * I, r[5] = l * w + u * S + h * C + d * U, r[9] = l * M + u * A + h * P + d * N, r[13] = l * E + u * L + h * O + d * D, r[2] = p * b + f * T + m * R + g * I, r[6] = p * w + f * S + m * C + g * U, r[10] = p * M + f * A + m * P + g * N, r[14] = p * E + f * L + m * O + g * D, r[3] = v * b + y * T + _ * R + x * I, r[7] = v * w + y * S + _ * C + x * U, r[11] = v * M + y * A + _ * P + x * N, r[15] = v * E + y * L + _ * O + x * D, this
            },
            multiplyToArray: function (t, e, n) {
                var i = this.elements;
                return this.multiplyMatrices(t, e), n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this
            },
            multiplyScalar: function (t) {
                var e = this.elements;
                return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
            },
            applyToVector3Array: function () {
                var t;
                return function (e, n, i) {
                    void 0 === t && (t = new c), void 0 === n && (n = 0), void 0 === i && (i = e.length);
                    for (var r = 0, a = n; r < i; r += 3, a += 3)t.fromArray(e, a), t.applyMatrix4(this), t.toArray(e, a);
                    return e
                }
            }(),
            applyToBufferAttribute: function () {
                var t;
                return function (e) {
                    void 0 === t && (t = new c);
                    for (var n = 0, i = e.count; n < i; n++)t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(n, t.x, t.y, t.z);
                    return e
                }
            }(),
            determinant: function () {
                var t = this.elements, e = t[0], n = t[4], i = t[8], r = t[12], a = t[1], o = t[5], s = t[9], c = t[13], l = t[2], u = t[6], h = t[10], d = t[14], p = t[3], f = t[7], m = t[11], g = t[15];
                return p * (+r * s * u - i * c * u - r * o * h + n * c * h + i * o * d - n * s * d) + f * (+e * s * d - e * c * h + r * a * h - i * a * d + i * c * l - r * s * l) + m * (+e * c * u - e * o * d - r * a * u + n * a * d + r * o * l - n * c * l) + g * (-i * o * l - e * s * u + e * o * h + i * a * u - n * a * h + n * s * l)
            },
            transpose: function () {
                var t, e = this.elements;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            },
            setPosition: function (t) {
                var e = this.elements;
                return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
            },
            getInverse: function (t, e) {
                var n = this.elements, i = t.elements, r = i[0], a = i[1], o = i[2], s = i[3], c = i[4], l = i[5], u = i[6], h = i[7], d = i[8], p = i[9], f = i[10], m = i[11], g = i[12], v = i[13], y = i[14], _ = i[15], x = p * y * h - v * f * h + v * u * m - l * y * m - p * u * _ + l * f * _, b = g * f * h - d * y * h - g * u * m + c * y * m + d * u * _ - c * f * _, w = d * v * h - g * p * h + g * l * m - c * v * m - d * l * _ + c * p * _, M = g * p * u - d * v * u - g * l * f + c * v * f + d * l * y - c * p * y, E = r * x + a * b + o * w + s * M;
                if (0 === E) {
                    var T = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                    if (e === !0)throw new Error(T);
                    return console.warn(T), this.identity()
                }
                var S = 1 / E;
                return n[0] = x * S, n[1] = (v * f * s - p * y * s - v * o * m + a * y * m + p * o * _ - a * f * _) * S, n[2] = (l * y * s - v * u * s + v * o * h - a * y * h - l * o * _ + a * u * _) * S, n[3] = (p * u * s - l * f * s - p * o * h + a * f * h + l * o * m - a * u * m) * S, n[4] = b * S, n[5] = (d * y * s - g * f * s + g * o * m - r * y * m - d * o * _ + r * f * _) * S, n[6] = (g * u * s - c * y * s - g * o * h + r * y * h + c * o * _ - r * u * _) * S, n[7] = (c * f * s - d * u * s + d * o * h - r * f * h - c * o * m + r * u * m) * S, n[8] = w * S, n[9] = (g * p * s - d * v * s - g * a * m + r * v * m + d * a * _ - r * p * _) * S, n[10] = (c * v * s - g * l * s + g * a * h - r * v * h - c * a * _ + r * l * _) * S, n[11] = (d * l * s - c * p * s - d * a * h + r * p * h + c * a * m - r * l * m) * S, n[12] = M * S, n[13] = (d * v * o - g * p * o + g * a * f - r * v * f - d * a * y + r * p * y) * S, n[14] = (g * l * o - c * v * o - g * a * u + r * v * u + c * a * y - r * l * y) * S, n[15] = (c * p * o - d * l * o + d * a * u - r * p * u - c * a * f + r * l * f) * S, this
            },
            scale: function (t) {
                var e = this.elements, n = t.x, i = t.y, r = t.z;
                return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
            },
            getMaxScaleOnAxis: function () {
                var t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            },
            makeTranslation: function (t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            },
            makeRotationX: function (t) {
                var e = Math.cos(t), n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function (t) {
                var e = Math.cos(t), n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function (t) {
                var e = Math.cos(t), n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function (t, e) {
                var n = Math.cos(e), i = Math.sin(e), r = 1 - n, a = t.x, o = t.y, s = t.z, c = r * a, l = r * o;
                return this.set(c * a + n, c * o - i * s, c * s + i * o, 0, c * o + i * s, l * o + n, l * s - i * a, 0, c * s - i * o, l * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this
            },
            makeScale: function (t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            },
            makeShear: function (t, e, n) {
                return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
            },
            compose: function (t, e, n) {
                return this.makeRotationFromQuaternion(e), this.scale(n), this.setPosition(t), this
            },
            decompose: function () {
                var t, e;
                return function (n, i, r) {
                    void 0 === t && (t = new c, e = new l);
                    var a = this.elements, o = t.set(a[0], a[1], a[2]).length(), s = t.set(a[4], a[5], a[6]).length(), u = t.set(a[8], a[9], a[10]).length(), h = this.determinant();
                    h < 0 && (o = -o), n.x = a[12], n.y = a[13], n.z = a[14], e.elements.set(this.elements);
                    var d = 1 / o, p = 1 / s, f = 1 / u;
                    return e.elements[0] *= d, e.elements[1] *= d, e.elements[2] *= d, e.elements[4] *= p, e.elements[5] *= p, e.elements[6] *= p, e.elements[8] *= f, e.elements[9] *= f, e.elements[10] *= f, i.setFromRotationMatrix(e), r.x = o, r.y = s, r.z = u, this
                }
            }(),
            makeFrustum: function (t, e, n, i, r, a) {
                var o = this.elements, s = 2 * r / (e - t), c = 2 * r / (i - n), l = (e + t) / (e - t), u = (i + n) / (i - n), h = -(a + r) / (a - r), d = -2 * a * r / (a - r);
                return o[0] = s, o[4] = 0, o[8] = l, o[12] = 0, o[1] = 0, o[5] = c, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
            },
            makePerspective: function (t, e, n, i) {
                var r = n * Math.tan(Qo.DEG2RAD * t * .5), a = -r, o = a * e, s = r * e;
                return this.makeFrustum(o, s, a, r, n, i)
            },
            makeOrthographic: function (t, e, n, i, r, a) {
                var o = this.elements, s = 1 / (e - t), c = 1 / (n - i), l = 1 / (a - r), u = (e + t) * s, h = (n + i) * c, d = (a + r) * l;
                return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * l, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
            },
            equals: function (t) {
                for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)if (e[i] !== n[i])return !1;
                return !0
            },
            fromArray: function (t, e) {
                void 0 === e && (e = 0);
                for (var n = 0; n < 16; n++)this.elements[n] = t[n + e];
                return this
            },
            toArray: function (t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
            }
        }, u.prototype = Object.create(i.prototype), u.prototype.constructor = u, u.prototype.isCubeTexture = !0, Object.defineProperty(u.prototype, "images", {
            get: function () {
                return this.image
            }, set: function (t) {
                this.image = t
            }
        });
        var $o = new i, ts = new u, es = [], ns = [];
        k.prototype.setValue = function (t, e) {
            for (var n = this.seq, i = 0, r = n.length; i !== r; ++i) {
                var a = n[i];
                a.setValue(t, e[a.id])
            }
        };
        var is = /([\w\d_]+)(\])?(\[|\.)?/g;
        j.prototype.setValue = function (t, e, n) {
            var i = this.map[e];
            void 0 !== i && i.setValue(t, n, this.renderer)
        }, j.prototype.set = function (t, e, n) {
            var i = this.map[n];
            void 0 !== i && i.setValue(t, e[n], this.renderer)
        }, j.prototype.setOptional = function (t, e, n) {
            var i = e[n];
            void 0 !== i && this.setValue(t, n, i)
        }, j.upload = function (t, e, n, i) {
            for (var r = 0, a = e.length; r !== a; ++r) {
                var o = e[r], s = n[o.id];
                s.needsUpdate !== !1 && o.setValue(t, s.value, i)
            }
        }, j.seqWithValue = function (t, e) {
            for (var n = [], i = 0, r = t.length; i !== r; ++i) {
                var a = t[i];
                a.id in e && n.push(a)
            }
            return n
        };
        var rs = {
            merge: function (t) {
                for (var e = {}, n = 0; n < t.length; n++) {
                    var i = this.clone(t[n]);
                    for (var r in i)e[r] = i[r]
                }
                return e
            }, clone: function (t) {
                var e = {};
                for (var n in t) {
                    e[n] = {};
                    for (var i in t[n]) {
                        var r = t[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                    }
                }
                return e
            }
        }, as = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", os = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n", ss = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", cs = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n", ls = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", us = "\nvec3 transformed = vec3( position );\n", hs = "\nvec3 objectNormal = vec3( normal );\n", ds = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", ps = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n", fs = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n", ms = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n", gs = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n", vs = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n", ys = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", _s = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n", xs = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", bs = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", ws = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n", Ms = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n", Es = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", Ts = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n", Ss = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", As = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", Ls = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n", Rs = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", Cs = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n", Ps = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n", Os = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n", Is = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n", Us = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n", Ns = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", Ds = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", Fs = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n", Bs = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", zs = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", Gs = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n", ks = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n", Hs = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", Vs = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n    }\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n", js = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n", Ws = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = material.specularRoughness;\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n    }\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", Xs = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n", Ys = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", qs = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n", Zs = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif", Js = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n", Qs = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n", Ks = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n", $s = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", tc = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n", ec = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n", nc = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", ic = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", rc = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", ac = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n", oc = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n", sc = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", cc = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n", lc = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n", uc = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", hc = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", dc = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n", pc = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", fc = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n", mc = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n", gc = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n", vc = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\t#endif\n\t#endif\n\treturn shadow;\n}\n", yc = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", _c = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n", xc = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n", bc = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", wc = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", Mc = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", Ec = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", Tc = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", Sc = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", Ac = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n", Lc = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", Rc = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", Cc = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", Pc = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", Oc = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n", Ic = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n", Uc = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", Nc = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n", Dc = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", Fc = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n", Bc = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n", zc = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n", Gc = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n", kc = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", Hc = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n", Vc = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", jc = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n", Wc = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", Xc = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n", Yc = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", qc = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n", Zc = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", Jc = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", Qc = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#include <premultiplied_alpha_fragment>\n\t#include <encodings_fragment>\n}\n", Kc = "#define NORMAL\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n", $c = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n", tl = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", el = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n", nl = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n", il = {
            alphamap_fragment: as,
            alphamap_pars_fragment: os,
            alphatest_fragment: ss,
            aomap_fragment: cs,
            aomap_pars_fragment: ls,
            begin_vertex: us,
            beginnormal_vertex: hs,
            bsdfs: ds,
            bumpmap_pars_fragment: ps,
            clipping_planes_fragment: fs,
            clipping_planes_pars_fragment: ms,
            clipping_planes_pars_vertex: gs,
            clipping_planes_vertex: vs,
            color_fragment: ys,
            color_pars_fragment: _s,
            color_pars_vertex: xs,
            color_vertex: bs,
            common: ws,
            cube_uv_reflection_fragment: Ms,
            defaultnormal_vertex: Es,
            displacementmap_pars_vertex: Ts,
            displacementmap_vertex: Ss,
            emissivemap_fragment: As,
            emissivemap_pars_fragment: Ls,
            encodings_fragment: Rs,
            encodings_pars_fragment: Cs,
            envmap_fragment: Ps,
            envmap_pars_fragment: Os,
            envmap_pars_vertex: Is,
            envmap_vertex: Us,
            fog_fragment: Ns,
            fog_pars_fragment: Ds,
            gradientmap_pars_fragment: Fs,
            lightmap_fragment: Bs,
            lightmap_pars_fragment: zs,
            lights_lambert_vertex: Gs,
            lights_pars: ks,
            lights_phong_fragment: Hs,
            lights_phong_pars_fragment: Vs,
            lights_physical_fragment: js,
            lights_physical_pars_fragment: Ws,
            lights_template: Xs,
            logdepthbuf_fragment: Ys,
            logdepthbuf_pars_fragment: qs,
            logdepthbuf_pars_vertex: Zs,
            logdepthbuf_vertex: Js,
            map_fragment: Qs,
            map_pars_fragment: Ks,
            map_particle_fragment: $s,
            map_particle_pars_fragment: tc,
            metalnessmap_fragment: ec,
            metalnessmap_pars_fragment: nc,
            morphnormal_vertex: ic,
            morphtarget_pars_vertex: rc,
            morphtarget_vertex: ac,
            normal_flip: oc,
            normal_fragment: sc,
            normalmap_pars_fragment: cc,
            packing: lc,
            premultiplied_alpha_fragment: uc,
            project_vertex: hc,
            roughnessmap_fragment: dc,
            roughnessmap_pars_fragment: pc,
            shadowmap_pars_fragment: fc,
            shadowmap_pars_vertex: mc,
            shadowmap_vertex: gc,
            shadowmask_pars_fragment: vc,
            skinbase_vertex: yc,
            skinning_pars_vertex: _c,
            skinning_vertex: xc,
            skinnormal_vertex: bc,
            specularmap_fragment: wc,
            specularmap_pars_fragment: Mc,
            tonemapping_fragment: Ec,
            tonemapping_pars_fragment: Tc,
            uv_pars_fragment: Sc,
            uv_pars_vertex: Ac,
            uv_vertex: Lc,
            uv2_pars_fragment: Rc,
            uv2_pars_vertex: Cc,
            uv2_vertex: Pc,
            worldpos_vertex: Oc,
            cube_frag: Ic,
            cube_vert: Uc,
            depth_frag: Nc,
            depth_vert: Dc,
            distanceRGBA_frag: Fc,
            distanceRGBA_vert: Bc,
            equirect_frag: zc,
            equirect_vert: Gc,
            linedashed_frag: kc,
            linedashed_vert: Hc,
            meshbasic_frag: Vc,
            meshbasic_vert: jc,
            meshlambert_frag: Wc,
            meshlambert_vert: Xc,
            meshphong_frag: Yc,
            meshphong_vert: qc,
            meshphysical_frag: Zc,
            meshphysical_vert: Jc,
            normal_frag: Qc,
            normal_vert: Kc,
            points_frag: $c,
            points_vert: tl,
            shadow_frag: el,
            shadow_vert: nl
        };
        W.prototype = {
            constructor: W, isColor: !0, r: 1, g: 1, b: 1, set: function (t) {
                return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
            }, setScalar: function (t) {
                return this.r = t, this.g = t, this.b = t, this
            }, setHex: function (t) {
                return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
            }, setRGB: function (t, e, n) {
                return this.r = t, this.g = e, this.b = n, this
            }, setHSL: function () {
                function t(t, e, n) {
                    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
                }

                return function (e, n, i) {
                    if (e = Qo.euclideanModulo(e, 1), n = Qo.clamp(n, 0, 1), i = Qo.clamp(i, 0, 1), 0 === n)this.r = this.g = this.b = i; else {
                        var r = i <= .5 ? i * (1 + n) : i + n - i * n, a = 2 * i - r;
                        this.r = t(a, r, e + 1 / 3), this.g = t(a, r, e), this.b = t(a, r, e - 1 / 3)
                    }
                    return this
                }
            }(), setStyle: function (t) {
                function e(e) {
                    void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                }

                var n;
                if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                    var i, r = n[1], a = n[2];
                    switch (r) {
                        case"rgb":
                        case"rgba":
                            if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                            if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                            break;
                        case"hsl":
                        case"hsla":
                            if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                var o = parseFloat(i[1]) / 360, s = parseInt(i[2], 10) / 100, c = parseInt(i[3], 10) / 100;
                                return e(i[5]), this.setHSL(o, s, c)
                            }
                    }
                } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                    var l = n[1], u = l.length;
                    if (3 === u)return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                    if (6 === u)return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                }
                if (t && t.length > 0) {
                    var l = rl[t];
                    void 0 !== l ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t)
                }
                return this
            }, clone: function () {
                return new this.constructor(this.r, this.g, this.b)
            }, copy: function (t) {
                return this.r = t.r, this.g = t.g, this.b = t.b, this
            }, copyGammaToLinear: function (t, e) {
                return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
            }, copyLinearToGamma: function (t, e) {
                void 0 === e && (e = 2);
                var n = e > 0 ? 1 / e : 1;
                return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
            }, convertGammaToLinear: function () {
                var t = this.r, e = this.g, n = this.b;
                return this.r = t * t, this.g = e * e, this.b = n * n, this
            }, convertLinearToGamma: function () {
                return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
            }, getHex: function () {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            }, getHexString: function () {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            }, getHSL: function (t) {
                var e, n, i = t || {
                        h: 0,
                        s: 0,
                        l: 0
                    }, r = this.r, a = this.g, o = this.b, s = Math.max(r, a, o), c = Math.min(r, a, o), l = (c + s) / 2;
                if (c === s)e = 0, n = 0; else {
                    var u = s - c;
                    switch (n = l <= .5 ? u / (s + c) : u / (2 - s - c), s) {
                        case r:
                            e = (a - o) / u + (a < o ? 6 : 0);
                            break;
                        case a:
                            e = (o - r) / u + 2;
                            break;
                        case o:
                            e = (r - a) / u + 4
                    }
                    e /= 6
                }
                return i.h = e, i.s = n, i.l = l, i
            }, getStyle: function () {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            }, offsetHSL: function (t, e, n) {
                var i = this.getHSL();
                return i.h += t, i.s += e, i.l += n, this.setHSL(i.h, i.s, i.l), this
            }, add: function (t) {
                return this.r += t.r, this.g += t.g, this.b += t.b, this
            }, addColors: function (t, e) {
                return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
            }, addScalar: function (t) {
                return this.r += t, this.g += t, this.b += t, this
            }, sub: function (t) {
                return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
            }, multiply: function (t) {
                return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
            }, multiplyScalar: function (t) {
                return this.r *= t, this.g *= t, this.b *= t, this
            }, lerp: function (t, e) {
                return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
            }, equals: function (t) {
                return t.r === this.r && t.g === this.g && t.b === this.b
            }, fromArray: function (t, e) {
                return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
            }, toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
            }, toJSON: function () {
                return this.getHex()
            }
        };
        var rl = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        X.prototype = Object.create(i.prototype), X.prototype.constructor = X, X.prototype.isDataTexture = !0;
        var al = {
            common: {
                diffuse: {value: new W(15658734)},
                opacity: {value: 1},
                map: {value: null},
                offsetRepeat: {value: new r(0, 0, 1, 1)},
                specularMap: {value: null},
                alphaMap: {value: null},
                envMap: {value: null},
                flipEnvMap: {value: -1},
                reflectivity: {value: 1},
                refractionRatio: {value: .98}
            },
            aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
            lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
            emissivemap: {emissiveMap: {value: null}},
            bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
            normalmap: {normalMap: {value: null}, normalScale: {value: new n(1, 1)}},
            displacementmap: {
                displacementMap: {value: null},
                displacementScale: {value: 1},
                displacementBias: {value: 0}
            },
            roughnessmap: {roughnessMap: {value: null}},
            metalnessmap: {metalnessMap: {value: null}},
            gradientmap: {gradientMap: {value: null}},
            fog: {
                fogDensity: {value: 25e-5},
                fogNear: {value: 1},
                fogFar: {value: 2e3},
                fogColor: {value: new W(16777215)}
            },
            lights: {
                ambientLightColor: {value: []},
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {value: []},
                directionalShadowMatrix: {value: []},
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotShadowMap: {value: []},
                spotShadowMatrix: {value: []},
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {},
                        shadow: {},
                        shadowBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                pointShadowMap: {value: []},
                pointShadowMatrix: {value: []},
                hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
                rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}
            },
            points: {
                diffuse: {value: new W(15658734)},
                opacity: {value: 1},
                size: {value: 1},
                scale: {value: 1},
                map: {value: null},
                offsetRepeat: {value: new r(0, 0, 1, 1)}
            }
        }, ol = {
            basic: {
                uniforms: rs.merge([al.common, al.aomap, al.lightmap, al.fog]),
                vertexShader: il.meshbasic_vert,
                fragmentShader: il.meshbasic_frag
            },
            lambert: {
                uniforms: rs.merge([al.common, al.aomap, al.lightmap, al.emissivemap, al.fog, al.lights, {emissive: {value: new W(0)}}]),
                vertexShader: il.meshlambert_vert,
                fragmentShader: il.meshlambert_frag
            },
            phong: {
                uniforms: rs.merge([al.common, al.aomap, al.lightmap, al.emissivemap, al.bumpmap, al.normalmap, al.displacementmap, al.gradientmap, al.fog, al.lights, {
                    emissive: {value: new W(0)},
                    specular: {value: new W(1118481)},
                    shininess: {value: 30}
                }]), vertexShader: il.meshphong_vert, fragmentShader: il.meshphong_frag
            },
            standard: {
                uniforms: rs.merge([al.common, al.aomap, al.lightmap, al.emissivemap, al.bumpmap, al.normalmap, al.displacementmap, al.roughnessmap, al.metalnessmap, al.fog, al.lights, {
                    emissive: {value: new W(0)},
                    roughness: {value: .5},
                    metalness: {value: 0},
                    envMapIntensity: {value: 1}
                }]), vertexShader: il.meshphysical_vert, fragmentShader: il.meshphysical_frag
            },
            points: {
                uniforms: rs.merge([al.points, al.fog]),
                vertexShader: il.points_vert,
                fragmentShader: il.points_frag
            },
            dashed: {
                uniforms: rs.merge([al.common, al.fog, {
                    scale: {value: 1},
                    dashSize: {value: 1},
                    totalSize: {value: 2}
                }]), vertexShader: il.linedashed_vert, fragmentShader: il.linedashed_frag
            },
            depth: {
                uniforms: rs.merge([al.common, al.displacementmap]),
                vertexShader: il.depth_vert,
                fragmentShader: il.depth_frag
            },
            normal: {
                uniforms: rs.merge([al.common, al.bumpmap, al.normalmap, al.displacementmap, {opacity: {value: 1}}]),
                vertexShader: il.normal_vert,
                fragmentShader: il.normal_frag
            },
            cube: {
                uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
                vertexShader: il.cube_vert,
                fragmentShader: il.cube_frag
            },
            equirect: {
                uniforms: {tEquirect: {value: null}, tFlip: {value: -1}},
                vertexShader: il.equirect_vert,
                fragmentShader: il.equirect_frag
            },
            distanceRGBA: {
                uniforms: {lightPos: {value: new c}},
                vertexShader: il.distanceRGBA_vert,
                fragmentShader: il.distanceRGBA_frag
            }
        };
        ol.physical = {
            uniforms: rs.merge([ol.standard.uniforms, {
                clearCoat: {value: 0},
                clearCoatRoughness: {value: 0}
            }]), vertexShader: il.meshphysical_vert, fragmentShader: il.meshphysical_frag
        }, Y.prototype = {
            constructor: Y, set: function (t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }, setFromPoints: function (t) {
                this.makeEmpty();
                for (var e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]);
                return this
            }, setFromCenterAndSize: function () {
                var t = new n;
                return function (e, n) {
                    var i = t.copy(n).multiplyScalar(.5);
                    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                }
            }(), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }, makeEmpty: function () {
                return this.min.x = this.min.y = +(1 / 0), this.max.x = this.max.y = -(1 / 0), this
            }, isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }, getCenter: function (t) {
                var e = t || new n;
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }, getSize: function (t) {
                var e = t || new n;
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            }, expandByPoint: function (t) {
                return this.min.min(t), this.max.max(t), this
            }, expandByVector: function (t) {
                return this.min.sub(t), this.max.add(t), this
            }, expandByScalar: function (t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }, containsPoint: function (t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            }, containsBox: function (t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            }, getParameter: function (t, e) {
                var i = e || new n;
                return i.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            }, intersectsBox: function (t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            }, clampPoint: function (t, e) {
                var i = e || new n;
                return i.copy(t).clamp(this.min, this.max)
            }, distanceToPoint: function () {
                var t = new n;
                return function (e) {
                    var n = t.copy(e).clamp(this.min, this.max);
                    return n.sub(e).length()
                }
            }(), intersect: function (t) {
                return this.min.max(t.min), this.max.min(t.max), this
            }, union: function (t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }, translate: function (t) {
                return this.min.add(t), this.max.add(t), this
            }, equals: function (t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        };
        var sl = 0;
        J.prototype = {
            constructor: J, isMaterial: !0, get needsUpdate() {
                return this._needsUpdate
            }, set needsUpdate(t) {
                t === !0 && this.update(), this._needsUpdate = t
            }, setValues: function (t) {
                if (void 0 !== t)for (var e in t) {
                    var n = t[e];
                    if (void 0 !== n) {
                        var i = this[e];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : "overdraw" === e ? this[e] = Number(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                    } else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                }
            }, toJSON: function (t) {
                function e(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }

                var n = void 0 === t;
                n && (t = {textures: {}, images: {}});
                var i = {metadata: {version: 4.4, type: "Material", generator: "Material.toJSON"}};
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Zr && (i.blending = this.blending), this.shading !== jr && (i.shading = this.shading), this.side !== Gr && (i.side = this.side), this.vertexColors !== Wr && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), i.skinning = this.skinning, i.morphTargets = this.morphTargets, n) {
                    var r = e(t.textures), a = e(t.images);
                    r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a)
                }
                return i
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.shading = t.shading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.overdraw = t.overdraw, this.visible = t.visible, this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                var e = t.clippingPlanes, n = null;
                if (null !== e) {
                    var i = e.length;
                    n = new Array(i);
                    for (var r = 0; r !== i; ++r)n[r] = e[r].clone()
                }
                return this.clippingPlanes = n, this
            }, update: function () {
                this.dispatchEvent({type: "update"})
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }, Object.assign(J.prototype, e.prototype), Q.prototype = Object.create(J.prototype), Q.prototype.constructor = Q, Q.prototype.isShaderMaterial = !0, Q.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = rs.clone(t.uniforms), this.defines = t.defines, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
        }, Q.prototype.toJSON = function (t) {
            var e = J.prototype.toJSON.call(this, t);
            return e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
        }, K.prototype = Object.create(J.prototype), K.prototype.constructor = K, K.prototype.isMeshDepthMaterial = !0, K.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
        }, $.prototype = {
            constructor: $, isBox3: !0, set: function (t, e) {
                return this.min.copy(t), this.max.copy(e), this
            }, setFromArray: function (t) {
                for (var e = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, c = t.length; s < c; s += 3) {
                    var l = t[s], u = t[s + 1], h = t[s + 2];
                    l < e && (e = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > a && (a = u), h > o && (o = h)
                }
                this.min.set(e, n, i), this.max.set(r, a, o)
            }, setFromBufferAttribute: function (t) {
                for (var e = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, c = t.count; s < c; s++) {
                    var l = t.getX(s), u = t.getY(s), h = t.getZ(s);
                    l < e && (e = l), u < n && (n = u), h < i && (i = h), l > r && (r = l), u > a && (a = u), h > o && (o = h)
                }
                this.min.set(e, n, i), this.max.set(r, a, o)
            }, setFromPoints: function (t) {
                this.makeEmpty();
                for (var e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]);
                return this
            }, setFromCenterAndSize: function () {
                var t = new c;
                return function (e, n) {
                    var i = t.copy(n).multiplyScalar(.5);
                    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
                }
            }(), setFromObject: function () {
                var t = new c;
                return function (e) {
                    var n = this;
                    return e.updateMatrixWorld(!0), this.makeEmpty(), e.traverse(function (e) {
                        var i, r, a = e.geometry;
                        if (void 0 !== a)if (a.isGeometry) {
                            var o = a.vertices;
                            for (i = 0, r = o.length; i < r; i++)t.copy(o[i]), t.applyMatrix4(e.matrixWorld), n.expandByPoint(t)
                        } else if (a.isBufferGeometry) {
                            var s = a.attributes.position;
                            if (void 0 !== s)for (i = 0, r = s.count; i < r; i++)t.fromAttribute(s, i).applyMatrix4(e.matrixWorld), n.expandByPoint(t)
                        }
                    }), this
                }
            }(), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.min.copy(t.min), this.max.copy(t.max), this
            }, makeEmpty: function () {
                return this.min.x = this.min.y = this.min.z = +(1 / 0), this.max.x = this.max.y = this.max.z = -(1 / 0), this
            }, isEmpty: function () {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }, getCenter: function (t) {
                var e = t || new c;
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }, getSize: function (t) {
                var e = t || new c;
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }, expandByPoint: function (t) {
                return this.min.min(t), this.max.max(t), this
            }, expandByVector: function (t) {
                return this.min.sub(t), this.max.add(t), this
            }, expandByScalar: function (t) {
                return this.min.addScalar(-t), this.max.addScalar(t), this
            }, containsPoint: function (t) {
                return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            }, containsBox: function (t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            }, getParameter: function (t, e) {
                var n = e || new c;
                return n.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            }, intersectsBox: function (t) {
                return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            }, intersectsSphere: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new c), this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                }
            }(), intersectsPlane: function (t) {
                var e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= t.constant && n >= t.constant
            }, clampPoint: function (t, e) {
                var n = e || new c;
                return n.copy(t).clamp(this.min, this.max)
            }, distanceToPoint: function () {
                var t = new c;
                return function (e) {
                    var n = t.copy(e).clamp(this.min, this.max);
                    return n.sub(e).length()
                }
            }(), getBoundingSphere: function () {
                var t = new c;
                return function (e) {
                    var n = e || new tt;
                    return this.getCenter(n.center), n.radius = .5 * this.getSize(t).length(), n
                }
            }(), intersect: function (t) {
                return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
            }, union: function (t) {
                return this.min.min(t.min), this.max.max(t.max), this
            }, applyMatrix4: function () {
                var t = [new c, new c, new c, new c, new c, new c, new c, new c];
                return function (e) {
                    return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                }
            }(), translate: function (t) {
                return this.min.add(t), this.max.add(t), this
            }, equals: function (t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        }, tt.prototype = {
            constructor: tt, set: function (t, e) {
                return this.center.copy(t), this.radius = e, this
            }, setFromPoints: function () {
                var t = new $;
                return function (e, n) {
                    var i = this.center;
                    void 0 !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i);
                    for (var r = 0, a = 0, o = e.length; a < o; a++)r = Math.max(r, i.distanceToSquared(e[a]));
                    return this.radius = Math.sqrt(r), this
                }
            }(), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.center.copy(t.center), this.radius = t.radius, this
            }, empty: function () {
                return this.radius <= 0
            }, containsPoint: function (t) {
                return t.distanceToSquared(this.center) <= this.radius * this.radius
            }, distanceToPoint: function (t) {
                return t.distanceTo(this.center) - this.radius
            }, intersectsSphere: function (t) {
                var e = this.radius + t.radius;
                return t.center.distanceToSquared(this.center) <= e * e
            }, intersectsBox: function (t) {
                return t.intersectsSphere(this)
            }, intersectsPlane: function (t) {
                return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
            }, clampPoint: function (t, e) {
                var n = this.center.distanceToSquared(t), i = e || new c;
                return i.copy(t), n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)), i
            }, getBoundingBox: function (t) {
                var e = t || new $;
                return e.set(this.center, this.center), e.expandByScalar(this.radius), e
            }, applyMatrix4: function (t) {
                return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
            }, translate: function (t) {
                return this.center.add(t), this
            }, equals: function (t) {
                return t.center.equals(this.center) && t.radius === this.radius
            }
        }, et.prototype = {
            constructor: et, isMatrix3: !0, set: function (t, e, n, i, r, a, o, s, c) {
                var l = this.elements;
                return l[0] = t, l[1] = i, l[2] = o, l[3] = e, l[4] = r, l[5] = s, l[6] = n, l[7] = a, l[8] = c, this
            }, identity: function () {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }, clone: function () {
                return (new this.constructor).fromArray(this.elements)
            }, copy: function (t) {
                var e = t.elements;
                return this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]), this
            }, setFromMatrix4: function (t) {
                var e = t.elements;
                return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
            }, applyToVector3Array: function () {
                var t;
                return function (e, n, i) {
                    void 0 === t && (t = new c), void 0 === n && (n = 0), void 0 === i && (i = e.length);
                    for (var r = 0, a = n; r < i; r += 3, a += 3)t.fromArray(e, a), t.applyMatrix3(this), t.toArray(e, a);
                    return e
                }
            }(), applyToBufferAttribute: function () {
                var t;
                return function (e) {
                    void 0 === t && (t = new c);
                    for (var n = 0, i = e.count; n < i; n++)t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(n, t.x, t.y, t.z);
                    return e
                }
            }(), multiplyScalar: function (t) {
                var e = this.elements;
                return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
            }, determinant: function () {
                var t = this.elements, e = t[0], n = t[1], i = t[2], r = t[3], a = t[4], o = t[5], s = t[6], c = t[7], l = t[8];
                return e * a * l - e * o * c - n * r * l + n * o * s + i * r * c - i * a * s
            }, getInverse: function (t, e) {
                t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                var n = t.elements, i = this.elements, r = n[0], a = n[1], o = n[2], s = n[3], c = n[4], l = n[5], u = n[6], h = n[7], d = n[8], p = d * c - l * h, f = l * u - d * s, m = h * s - c * u, g = r * p + a * f + o * m;
                if (0 === g) {
                    var v = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                    if (e === !0)throw new Error(v);
                    return console.warn(v), this.identity()
                }
                var y = 1 / g;
                return i[0] = p * y, i[1] = (o * h - d * a) * y, i[2] = (l * a - o * c) * y, i[3] = f * y, i[4] = (d * r - o * u) * y, i[5] = (o * s - l * r) * y, i[6] = m * y, i[7] = (a * u - h * r) * y, i[8] = (c * r - a * s) * y, this
            }, transpose: function () {
                var t, e = this.elements;
                return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
            }, getNormalMatrix: function (t) {
                return this.setFromMatrix4(t).getInverse(this).transpose()
            }, transposeIntoArray: function (t) {
                var e = this.elements;
                return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
            }, fromArray: function (t, e) {
                void 0 === e && (e = 0);
                for (var n = 0; n < 9; n++)this.elements[n] = t[n + e];
                return this
            }, toArray: function (t, e) {
                void 0 === t && (t = []), void 0 === e && (e = 0);
                var n = this.elements;
                return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
            }
        }, nt.prototype = {
            constructor: nt, set: function (t, e) {
                return this.normal.copy(t), this.constant = e, this
            }, setComponents: function (t, e, n, i) {
                return this.normal.set(t, e, n), this.constant = i, this
            }, setFromNormalAndCoplanarPoint: function (t, e) {
                return this.normal.copy(t), this.constant = -e.dot(this.normal), this
            }, setFromCoplanarPoints: function () {
                var t = new c, e = new c;
                return function (n, i, r) {
                    var a = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
                    return this.setFromNormalAndCoplanarPoint(a, n), this
                }
            }(), clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.normal.copy(t.normal), this.constant = t.constant, this
            }, normalize: function () {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t), this.constant *= t, this
            }, negate: function () {
                return this.constant *= -1, this.normal.negate(), this
            }, distanceToPoint: function (t) {
                return this.normal.dot(t) + this.constant
            }, distanceToSphere: function (t) {
                return this.distanceToPoint(t.center) - t.radius
            }, projectPoint: function (t, e) {
                return this.orthoPoint(t, e).sub(t).negate()
            }, orthoPoint: function (t, e) {
                var n = this.distanceToPoint(t), i = e || new c;
                return i.copy(this.normal).multiplyScalar(n)
            }, intersectLine: function () {
                var t = new c;
                return function (e, n) {
                    var i = n || new c, r = e.delta(t), a = this.normal.dot(r);
                    if (0 !== a) {
                        var o = -(e.start.dot(this.normal) + this.constant) / a;
                        if (!(o < 0 || o > 1))return i.copy(r).multiplyScalar(o).add(e.start)
                    } else if (0 === this.distanceToPoint(e.start))return i.copy(e.start)
                }
            }(), intersectsLine: function (t) {
                var e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            }, intersectsBox: function (t) {
                return t.intersectsPlane(this)
            }, intersectsSphere: function (t) {
                return t.intersectsPlane(this)
            }, coplanarPoint: function (t) {
                var e = t || new c;
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }, applyMatrix4: function () {
                var t = new c, e = new et;
                return function (n, i) {
                    var r = this.coplanarPoint(t).applyMatrix4(n), a = i || e.getNormalMatrix(n), o = this.normal.applyMatrix3(a).normalize();
                    return this.constant = -r.dot(o), this
                }
            }(), translate: function (t) {
                return this.constant = this.constant - t.dot(this.normal), this
            }, equals: function (t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        }, it.prototype = {
            constructor: it, set: function (t, e, n, i, r, a) {
                var o = this.planes;
                return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                for (var e = this.planes, n = 0; n < 6; n++)e[n].copy(t.planes[n]);
                return this
            }, setFromMatrix: function (t) {
                var e = this.planes, n = t.elements, i = n[0], r = n[1], a = n[2], o = n[3], s = n[4], c = n[5], l = n[6], u = n[7], h = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], y = n[15];
                return e[0].setComponents(o - i, u - s, f - h, y - m).normalize(), e[1].setComponents(o + i, u + s, f + h, y + m).normalize(), e[2].setComponents(o + r, u + c, f + d, y + g).normalize(), e[3].setComponents(o - r, u - c, f - d, y - g).normalize(), e[4].setComponents(o - a, u - l, f - p, y - v).normalize(), e[5].setComponents(o + a, u + l, f + p, y + v).normalize(), this
            }, intersectsObject: function () {
                var t = new tt;
                return function (e) {
                    var n = e.geometry;
                    return null === n.boundingSphere && n.computeBoundingSphere(), t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(), intersectsSprite: function () {
                var t = new tt;
                return function (e) {
                    return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                }
            }(), intersectsSphere: function (t) {
                for (var e = this.planes, n = t.center, i = -t.radius, r = 0; r < 6; r++) {
                    var a = e[r].distanceToPoint(n);
                    if (a < i)return !1
                }
                return !0
            }, intersectsBox: function () {
                var t = new c, e = new c;
                return function (n) {
                    for (var i = this.planes, r = 0; r < 6; r++) {
                        var a = i[r];
                        t.x = a.normal.x > 0 ? n.min.x : n.max.x, e.x = a.normal.x > 0 ? n.max.x : n.min.x, t.y = a.normal.y > 0 ? n.min.y : n.max.y, e.y = a.normal.y > 0 ? n.max.y : n.min.y, t.z = a.normal.z > 0 ? n.min.z : n.max.z, e.z = a.normal.z > 0 ? n.max.z : n.min.z;
                        var o = a.distanceToPoint(t), s = a.distanceToPoint(e);
                        if (o < 0 && s < 0)return !1
                    }
                    return !0
                }
            }(), containsPoint: function (t) {
                for (var e = this.planes, n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0)return !1;
                return !0
            }
        }, at.prototype = {
            constructor: at, set: function (t, e) {
                return this.origin.copy(t), this.direction.copy(e), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.origin.copy(t.origin), this.direction.copy(t.direction), this
            }, at: function (t, e) {
                var n = e || new c;
                return n.copy(this.direction).multiplyScalar(t).add(this.origin)
            }, lookAt: function (t) {
                return this.direction.copy(t).sub(this.origin).normalize(), this
            }, recast: function () {
                var t = new c;
                return function (e) {
                    return this.origin.copy(this.at(e, t)), this
                }
            }(), closestPointToPoint: function (t, e) {
                var n = e || new c;
                n.subVectors(t, this.origin);
                var i = n.dot(this.direction);
                return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin)
            }, distanceToPoint: function (t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            }, distanceSqToPoint: function () {
                var t = new c;
                return function (e) {
                    var n = t.subVectors(e, this.origin).dot(this.direction);
                    return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
                }
            }(), distanceSqToSegment: function () {
                var t = new c, e = new c, n = new c;
                return function (i, r, a, o) {
                    t.copy(i).add(r).multiplyScalar(.5), e.copy(r).sub(i).normalize(), n.copy(this.origin).sub(t);
                    var s, c, l, u, h = .5 * i.distanceTo(r), d = -this.direction.dot(e), p = n.dot(this.direction), f = -n.dot(e), m = n.lengthSq(), g = Math.abs(1 - d * d);
                    if (g > 0)if (s = d * f - p, c = d * p - f, u = h * g, s >= 0)if (c >= -u)if (c <= u) {
                        var v = 1 / g;
                        s *= v, c *= v, l = s * (s + d * c + 2 * p) + c * (d * s + c + 2 * f) + m
                    } else c = h, s = Math.max(0, -(d * c + p)), l = -s * s + c * (c + 2 * f) + m; else c = -h, s = Math.max(0, -(d * c + p)), l = -s * s + c * (c + 2 * f) + m; else c <= -u ? (s = Math.max(0, -(-d * h + p)), c = s > 0 ? -h : Math.min(Math.max(-h, -f), h), l = -s * s + c * (c + 2 * f) + m) : c <= u ? (s = 0, c = Math.min(Math.max(-h, -f), h), l = c * (c + 2 * f) + m) : (s = Math.max(0, -(d * h + p)), c = s > 0 ? h : Math.min(Math.max(-h, -f), h), l = -s * s + c * (c + 2 * f) + m); else c = d > 0 ? -h : h, s = Math.max(0, -(d * c + p)), l = -s * s + c * (c + 2 * f) + m;
                    return a && a.copy(this.direction).multiplyScalar(s).add(this.origin), o && o.copy(e).multiplyScalar(c).add(t), l
                }
            }(), intersectSphere: function () {
                var t = new c;
                return function (e, n) {
                    t.subVectors(e.center, this.origin);
                    var i = t.dot(this.direction), r = t.dot(t) - i * i, a = e.radius * e.radius;
                    if (r > a)return null;
                    var o = Math.sqrt(a - r), s = i - o, c = i + o;
                    return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
                }
            }(), intersectsSphere: function (t) {
                return this.distanceToPoint(t.center) <= t.radius
            }, distanceToPlane: function (t) {
                var e = t.normal.dot(this.direction);
                if (0 === e)return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n : null
            }, intersectPlane: function (t, e) {
                var n = this.distanceToPlane(t);
                return null === n ? null : this.at(n, e)
            }, intersectsPlane: function (t) {
                var e = t.distanceToPoint(this.origin);
                if (0 === e)return !0;
                var n = t.normal.dot(this.direction);
                return n * e < 0
            }, intersectBox: function (t, e) {
                var n, i, r, a, o, s, c = 1 / this.direction.x, l = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin;
                return c >= 0 ? (n = (t.min.x - h.x) * c, i = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, i = (t.min.x - h.x) * c), l >= 0 ? (r = (t.min.y - h.y) * l, a = (t.max.y - h.y) * l) : (r = (t.max.y - h.y) * l, a = (t.min.y - h.y) * l), n > a || r > i ? null : ((r > n || n !== n) && (n = r), (a < i || i !== i) && (i = a), u >= 0 ? (o = (t.min.z - h.z) * u, s = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, s = (t.min.z - h.z) * u), n > s || o > i ? null : ((o > n || n !== n) && (n = o), (s < i || i !== i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            }, intersectsBox: function () {
                var t = new c;
                return function (e) {
                    return null !== this.intersectBox(e, t)
                }
            }(), intersectTriangle: function () {
                var t = new c, e = new c, n = new c, i = new c;
                return function (r, a, o, s, c) {
                    e.subVectors(a, r), n.subVectors(o, r), i.crossVectors(e, n);
                    var l, u = this.direction.dot(i);
                    if (u > 0) {
                        if (s)return null;
                        l = 1
                    } else {
                        if (!(u < 0))return null;
                        l = -1, u = -u
                    }
                    t.subVectors(this.origin, r);
                    var h = l * this.direction.dot(n.crossVectors(t, n));
                    if (h < 0)return null;
                    var d = l * this.direction.dot(e.cross(t));
                    if (d < 0)return null;
                    if (h + d > u)return null;
                    var p = -l * t.dot(i);
                    return p < 0 ? null : this.at(p / u, c)
                }
            }(), applyMatrix4: function (t) {
                return this.direction.add(this.origin).applyMatrix4(t), this.origin.applyMatrix4(t), this.direction.sub(this.origin), this.direction.normalize(), this
            }, equals: function (t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        }, ot.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ot.DefaultOrder = "XYZ", ot.prototype = {
            constructor: ot,
            isEuler: !0,
            get x() {
                return this._x
            },
            set x(t) {
                this._x = t, this.onChangeCallback()
            },
            get y() {
                return this._y
            },
            set y(t) {
                this._y = t, this.onChangeCallback()
            },
            get z() {
                return this._z
            },
            set z(t) {
                this._z = t, this.onChangeCallback()
            },
            get order() {
                return this._order
            },
            set order(t) {
                this._order = t, this.onChangeCallback()
            },
            set: function (t, e, n, i) {
                return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
            },
            clone: function () {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function (t) {
                return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
            },
            setFromRotationMatrix: function (t, e, n) {
                var i = Qo.clamp, r = t.elements, a = r[0], o = r[4], s = r[8], c = r[1], l = r[5], u = r[9], h = r[2], d = r[6], p = r[10];
                return e = e || this._order, "XYZ" === e ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-o, l))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, n !== !1 && this.onChangeCallback(), this
            },
            setFromQuaternion: function () {
                var t;
                return function (e, n, i) {
                    return void 0 === t && (t = new l), t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, i)
                }
            }(),
            setFromVector3: function (t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function () {
                var t = new s;
                return function (e) {
                    return t.setFromEuler(this), this.setFromQuaternion(t, e)
                }
            }(),
            equals: function (t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function (t) {
                return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
            },
            toArray: function (t, e) {
                return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
            },
            toVector3: function (t) {
                return t ? t.set(this._x, this._y, this._z) : new c(this._x, this._y, this._z)
            },
            onChange: function (t) {
                return this.onChangeCallback = t, this
            },
            onChangeCallback: function () {
            }
        }, st.prototype = {
            constructor: st, set: function (t) {
                this.mask = 1 << t
            }, enable: function (t) {
                this.mask |= 1 << t
            }, toggle: function (t) {
                this.mask ^= 1 << t
            }, disable: function (t) {
                this.mask &= ~(1 << t)
            }, test: function (t) {
                return 0 !== (this.mask & t.mask)
            }
        };
        var cl = 0;
        ct.DefaultUp = new c(0, 1, 0), ct.DefaultMatrixAutoUpdate = !0, Object.assign(ct.prototype, e.prototype, {
            isObject3D: !0,
            applyMatrix: function (t) {
                this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            setRotationFromAxisAngle: function (t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function (t) {
                this.quaternion.setFromEuler(t, !0)
            },
            setRotationFromMatrix: function (t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function (t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function () {
                var t = new s;
                return function (e, n) {
                    return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this
                }
            }(),
            rotateX: function () {
                var t = new c(1, 0, 0);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateY: function () {
                var t = new c(0, 1, 0);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            rotateZ: function () {
                var t = new c(0, 0, 1);
                return function (e) {
                    return this.rotateOnAxis(t, e)
                }
            }(),
            translateOnAxis: function () {
                var t = new c;
                return function (e, n) {
                    return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this
                }
            }(),
            translateX: function () {
                var t = new c(1, 0, 0);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateY: function () {
                var t = new c(0, 1, 0);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            translateZ: function () {
                var t = new c(0, 0, 1);
                return function (e) {
                    return this.translateOnAxis(t, e)
                }
            }(),
            localToWorld: function (t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function () {
                var t = new l;
                return function (e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld))
                }
            }(),
            lookAt: function () {
                var t = new l;
                return function (e) {
                    t.lookAt(e, this.position, this.up), this.quaternion.setFromRotationMatrix(t)
                }
            }(),
            add: function (t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++)this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({type: "added"}), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function (t) {
                if (arguments.length > 1)for (var e = 0; e < arguments.length; e++)this.remove(arguments[e]);
                var n = this.children.indexOf(t);
                n !== -1 && (t.parent = null, t.dispatchEvent({type: "removed"}), this.children.splice(n, 1))
            },
            getObjectById: function (t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function (t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function (t, e) {
                if (this[t] === e)return this;
                for (var n = 0, i = this.children.length; n < i; n++) {
                    var r = this.children[n], a = r.getObjectByProperty(t, e);
                    if (void 0 !== a)return a
                }
            },
            getWorldPosition: function (t) {
                var e = t || new c;
                return this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function () {
                var t = new c, e = new c;
                return function (n) {
                    var i = n || new s;
                    return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
                }
            }(),
            getWorldRotation: function () {
                var t = new s;
                return function (e) {
                    var n = e || new ot;
                    return this.getWorldQuaternion(t), n.setFromQuaternion(t, this.rotation.order, !1)
                }
            }(),
            getWorldScale: function () {
                var t = new c, e = new s;
                return function (n) {
                    var i = n || new c;
                    return this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
                }
            }(),
            getWorldDirection: function () {
                var t = new s;
                return function (e) {
                    var n = e || new c;
                    return this.getWorldQuaternion(t), n.set(0, 0, 1).applyQuaternion(t)
                }
            }(),
            raycast: function () {
            },
            traverse: function (t) {
                t(this);
                for (var e = this.children, n = 0, i = e.length; n < i; n++)e[n].traverse(t)
            },
            traverseVisible: function (t) {
                if (this.visible !== !1) {
                    t(this);
                    for (var e = this.children, n = 0, i = e.length; n < i; n++)e[n].traverseVisible(t)
                }
            },
            traverseAncestors: function (t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function () {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function (t) {
                this.matrixAutoUpdate === !0 && this.updateMatrix(), this.matrixWorldNeedsUpdate !== !0 && t !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                for (var e = this.children, n = 0, i = e.length; n < i; n++)e[n].updateMatrixWorld(t)
            },
            toJSON: function (t) {
                function e(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        delete i.metadata, e.push(i)
                    }
                    return e
                }

                var n = void 0 === t || "" === t, i = {};
                n && (t = {geometries: {}, materials: {}, textures: {}, images: {}}, i.metadata = {
                    version: 4.4,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var r = {};
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), r.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === t.geometries[this.geometry.uuid] && (t.geometries[this.geometry.uuid] = this.geometry.toJSON(t)), r.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === t.materials[this.material.uuid] && (t.materials[this.material.uuid] = this.material.toJSON(t)), r.material = this.material.uuid), this.children.length > 0) {
                    r.children = [];
                    for (var a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(t).object)
                }
                if (n) {
                    var o = e(t.geometries), s = e(t.materials), c = e(t.textures), l = e(t.images);
                    o.length > 0 && (i.geometries = o), s.length > 0 && (i.materials = s), c.length > 0 && (i.textures = c), l.length > 0 && (i.images = l)
                }
                return i.object = r, i
            },
            clone: function (t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function (t, e) {
                if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0)for (var n = 0; n < t.children.length; n++) {
                    var i = t.children[n];
                    this.add(i.clone())
                }
                return this
            }
        }), lt.prototype = {
            constructor: lt, set: function (t, e) {
                return this.start.copy(t), this.end.copy(e), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.start.copy(t.start), this.end.copy(t.end), this
            }, getCenter: function (t) {
                var e = t || new c;
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            }, delta: function (t) {
                var e = t || new c;
                return e.subVectors(this.end, this.start)
            }, distanceSq: function () {
                return this.start.distanceToSquared(this.end)
            }, distance: function () {
                return this.start.distanceTo(this.end)
            }, at: function (t, e) {
                var n = e || new c;
                return this.delta(n).multiplyScalar(t).add(this.start)
            }, closestPointToPointParameter: function () {
                var t = new c, e = new c;
                return function (n, i) {
                    t.subVectors(n, this.start), e.subVectors(this.end, this.start);
                    var r = e.dot(e), a = e.dot(t), o = a / r;
                    return i && (o = Qo.clamp(o, 0, 1)), o
                }
            }(), closestPointToPoint: function (t, e, n) {
                var i = this.closestPointToPointParameter(t, e), r = n || new c;
                return this.delta(r).multiplyScalar(i).add(this.start)
            }, applyMatrix4: function (t) {
                return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
            }, equals: function (t) {
                return t.start.equals(this.start) && t.end.equals(this.end)
            }
        }, ut.normal = function () {
            var t = new c;
            return function (e, n, i, r) {
                var a = r || new c;
                a.subVectors(i, n), t.subVectors(e, n), a.cross(t);
                var o = a.lengthSq();
                return o > 0 ? a.multiplyScalar(1 / Math.sqrt(o)) : a.set(0, 0, 0)
            }
        }(), ut.barycoordFromPoint = function () {
            var t = new c, e = new c, n = new c;
            return function (i, r, a, o, s) {
                t.subVectors(o, r), e.subVectors(a, r), n.subVectors(i, r);
                var l = t.dot(t), u = t.dot(e), h = t.dot(n), d = e.dot(e), p = e.dot(n), f = l * d - u * u, m = s || new c;
                if (0 === f)return m.set(-2, -1, -1);
                var g = 1 / f, v = (d * h - u * p) * g, y = (l * p - u * h) * g;
                return m.set(1 - v - y, y, v)
            }
        }(), ut.containsPoint = function () {
            var t = new c;
            return function (e, n, i, r) {
                var a = ut.barycoordFromPoint(e, n, i, r, t);
                return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1
            }
        }(), ut.prototype = {
            constructor: ut, set: function (t, e, n) {
                return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
            }, setFromPointsAndIndices: function (t, e, n, i) {
                return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
            }, area: function () {
                var t = new c, e = new c;
                return function () {
                    return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                }
            }(), midpoint: function (t) {
                var e = t || new c;
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }, normal: function (t) {
                return ut.normal(this.a, this.b, this.c, t)
            }, plane: function (t) {
                var e = t || new nt;
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }, barycoordFromPoint: function (t, e) {
                return ut.barycoordFromPoint(t, this.a, this.b, this.c, e)
            }, containsPoint: function (t) {
                return ut.containsPoint(t, this.a, this.b, this.c)
            }, closestPointToPoint: function () {
                var t, e, n, i;
                return function (r, a) {
                    void 0 === t && (t = new nt, e = [new lt, new lt, new lt], n = new c, i = new c);
                    var o = a || new c, s = 1 / 0;
                    if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(r, n), this.containsPoint(n) === !0)o.copy(n); else {
                        e[0].set(this.a, this.b), e[1].set(this.b, this.c), e[2].set(this.c, this.a);
                        for (var l = 0; l < e.length; l++) {
                            e[l].closestPointToPoint(n, !0, i);
                            var u = n.distanceToSquared(i);
                            u < s && (s = u, o.copy(i))
                        }
                    }
                    return o
                }
            }(), equals: function (t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        }, ht.prototype = {
            constructor: ht, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                for (var e = 0, n = t.vertexNormals.length; e < n; e++)this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (var e = 0, n = t.vertexColors.length; e < n; e++)this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        }, dt.prototype = Object.create(J.prototype), dt.prototype.constructor = dt, dt.prototype.isMeshBasicMaterial = !0, dt.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
        }, pt.prototype = {
            constructor: pt, isBufferAttribute: !0, set needsUpdate(t) {
                t === !0 && this.version++
            }, setArray: function (t) {
                if (Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t
            }, setDynamic: function (t) {
                return this.dynamic = t, this
            }, copy: function (t) {
                return this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
            }, copyAt: function (t, e, n) {
                t *= this.itemSize, n *= e.itemSize;
                for (var i = 0, r = this.itemSize; i < r; i++)this.array[t + i] = e.array[n + i];
                return this
            }, copyArray: function (t) {
                return this.array.set(t), this
            }, copyColorsArray: function (t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new W), e[n++] = a.r, e[n++] = a.g, e[n++] = a.b
                }
                return this
            }, copyIndicesArray: function (t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    e[n++] = a.a, e[n++] = a.b, e[n++] = a.c
                }
                return this
            }, copyVector2sArray: function (t) {
                for (var e = this.array, i = 0, r = 0, a = t.length; r < a; r++) {
                    var o = t[r];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new n), e[i++] = o.x, e[i++] = o.y
                }
                return this
            }, copyVector3sArray: function (t) {
                for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
                    var a = t[i];
                    void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), a = new c), e[n++] = a.x, e[n++] = a.y, e[n++] = a.z
                }
                return this
            }, copyVector4sArray: function (t) {
                for (var e = this.array, n = 0, i = 0, a = t.length; i < a; i++) {
                    var o = t[i];
                    void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), o = new r), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
                }
                return this
            }, set: function (t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            }, getX: function (t) {
                return this.array[t * this.itemSize]
            }, setX: function (t, e) {
                return this.array[t * this.itemSize] = e, this
            }, getY: function (t) {
                return this.array[t * this.itemSize + 1]
            }, setY: function (t, e) {
                return this.array[t * this.itemSize + 1] = e, this
            }, getZ: function (t) {
                return this.array[t * this.itemSize + 2]
            }, setZ: function (t, e) {
                return this.array[t * this.itemSize + 2] = e, this
            }, getW: function (t) {
                return this.array[t * this.itemSize + 3]
            }, setW: function (t, e) {
                return this.array[t * this.itemSize + 3] = e, this
            }, setXY: function (t, e, n) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
            }, setXYZ: function (t, e, n, i) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
            }, setXYZW: function (t, e, n, i, r) {
                return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
            }, onUpload: function (t) {
                return this.onUploadCallback = t, this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }
        }, ft.prototype = Object.create(pt.prototype), ft.prototype.constructor = ft, mt.prototype = Object.create(pt.prototype), mt.prototype.constructor = mt, gt.prototype = Object.create(pt.prototype), gt.prototype.constructor = gt, vt.prototype = Object.create(pt.prototype), vt.prototype.constructor = vt, yt.prototype = Object.create(pt.prototype), yt.prototype.constructor = yt, _t.prototype = Object.create(pt.prototype), _t.prototype.constructor = _t, xt.prototype = Object.create(pt.prototype), xt.prototype.constructor = xt, bt.prototype = Object.create(pt.prototype), bt.prototype.constructor = bt, wt.prototype = Object.create(pt.prototype), wt.prototype.constructor = wt, Object.assign(Mt.prototype, {
            computeGroups: function (t) {
                for (var e, n = [], i = void 0, r = t.faces, a = 0; a < r.length; a++) {
                    var o = r[a];
                    o.materialIndex !== i && (i = o.materialIndex, void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), e = {
                        start: 3 * a,
                        materialIndex: i
                    })
                }
                void 0 !== e && (e.count = 3 * a - e.start, n.push(e)), this.groups = n
            }, fromGeometry: function (t) {
                var e, i = t.faces, r = t.vertices, a = t.faceVertexUvs, o = a[0] && a[0].length > 0, s = a[1] && a[1].length > 0, c = t.morphTargets, l = c.length;
                if (l > 0) {
                    e = [];
                    for (var u = 0; u < l; u++)e[u] = [];
                    this.morphTargets.position = e
                }
                var h, d = t.morphNormals, p = d.length;
                if (p > 0) {
                    h = [];
                    for (var u = 0; u < p; u++)h[u] = [];
                    this.morphTargets.normal = h
                }
                for (var f = t.skinIndices, m = t.skinWeights, g = f.length === r.length, v = m.length === r.length, u = 0; u < i.length; u++) {
                    var y = i[u];
                    this.vertices.push(r[y.a], r[y.b], r[y.c]);
                    var _ = y.vertexNormals;
                    if (3 === _.length)this.normals.push(_[0], _[1], _[2]); else {
                        var x = y.normal;
                        this.normals.push(x, x, x)
                    }
                    var b = y.vertexColors;
                    if (3 === b.length)this.colors.push(b[0], b[1], b[2]); else {
                        var w = y.color;
                        this.colors.push(w, w, w)
                    }
                    if (o === !0) {
                        var M = a[0][u];
                        void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new n, new n, new n))
                    }
                    if (s === !0) {
                        var M = a[1][u];
                        void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new n, new n, new n))
                    }
                    for (var E = 0; E < l; E++) {
                        var T = c[E].vertices;
                        e[E].push(T[y.a], T[y.b], T[y.c])
                    }
                    for (var E = 0; E < p; E++) {
                        var S = d[E].vertexNormals[u];
                        h[E].push(S.a, S.b, S.c)
                    }
                    g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                }
                return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
            }
        }), Object.assign(Et.prototype, e.prototype, {
            isGeometry: !0, applyMatrix: function (t) {
                for (var e = (new et).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                    var r = this.vertices[n];
                    r.applyMatrix4(t)
                }
                for (var n = 0, i = this.faces.length; n < i; n++) {
                    var a = this.faces[n];
                    a.normal.applyMatrix3(e).normalize();
                    for (var o = 0, s = a.vertexNormals.length; o < s; o++)a.vertexNormals[o].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
            }, rotateX: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(), rotateY: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(), rotateZ: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(), translate: function () {
                var t;
                return function (e, n, i) {
                    return void 0 === t && (t = new l), t.makeTranslation(e, n, i), this.applyMatrix(t), this
                }
            }(), scale: function () {
                var t;
                return function (e, n, i) {
                    return void 0 === t && (t = new l), t.makeScale(e, n, i), this.applyMatrix(t), this
                }
            }(), lookAt: function () {
                var t;
                return function (e) {
                    void 0 === t && (t = new ct), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(), fromBufferGeometry: function (t) {
                function e(t, e, n, r) {
                    var a = void 0 !== s ? [d[t].clone(), d[e].clone(), d[n].clone()] : [], o = void 0 !== l ? [i.colors[t].clone(), i.colors[e].clone(), i.colors[n].clone()] : [], c = new ht(t, e, n, a, o, r);
                    i.faces.push(c), void 0 !== u && i.faceVertexUvs[0].push([p[t].clone(), p[e].clone(), p[n].clone()]), void 0 !== h && i.faceVertexUvs[1].push([f[t].clone(), f[e].clone(), f[n].clone()])
                }

                var i = this, r = null !== t.index ? t.index.array : void 0, a = t.attributes, o = a.position.array, s = void 0 !== a.normal ? a.normal.array : void 0, l = void 0 !== a.color ? a.color.array : void 0, u = void 0 !== a.uv ? a.uv.array : void 0, h = void 0 !== a.uv2 ? a.uv2.array : void 0;
                void 0 !== h && (this.faceVertexUvs[1] = []);
                for (var d = [], p = [], f = [], m = 0, g = 0; m < o.length; m += 3, g += 2)i.vertices.push(new c(o[m], o[m + 1], o[m + 2])), void 0 !== s && d.push(new c(s[m], s[m + 1], s[m + 2])), void 0 !== l && i.colors.push(new W(l[m], l[m + 1], l[m + 2])), void 0 !== u && p.push(new n(u[g], u[g + 1])), void 0 !== h && f.push(new n(h[g], h[g + 1]));
                if (void 0 !== r) {
                    var v = t.groups;
                    if (v.length > 0)for (var m = 0; m < v.length; m++)for (var y = v[m], _ = y.start, x = y.count, g = _, b = _ + x; g < b; g += 3)e(r[g], r[g + 1], r[g + 2], y.materialIndex); else for (var m = 0; m < r.length; m += 3)e(r[m], r[m + 1], r[m + 2])
                } else for (var m = 0; m < o.length / 3; m += 3)e(m, m + 1, m + 2);
                return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
            }, center: function () {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            }, normalize: function () {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center, e = this.boundingSphere.radius, n = 0 === e ? 1 : 1 / e, i = new l;
                return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
            }, computeFaceNormals: function () {
                for (var t = new c, e = new c, n = 0, i = this.faces.length; n < i; n++) {
                    var r = this.faces[n], a = this.vertices[r.a], o = this.vertices[r.b], s = this.vertices[r.c];
                    t.subVectors(s, o), e.subVectors(a, o), t.cross(e), t.normalize(), r.normal.copy(t)
                }
            }, computeVertexNormals: function (t) {
                void 0 === t && (t = !0);
                var e, n, i, r, a, o;
                for (o = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++)o[e] = new c;
                if (t) {
                    var s, l, u, h = new c, d = new c;
                    for (i = 0, r = this.faces.length; i < r; i++)a = this.faces[i], s = this.vertices[a.a], l = this.vertices[a.b], u = this.vertices[a.c], h.subVectors(u, l), d.subVectors(s, l), h.cross(d), o[a.a].add(h), o[a.b].add(h), o[a.c].add(h)
                } else for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++)a = this.faces[i], o[a.a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
                for (e = 0, n = this.vertices.length; e < n; e++)o[e].normalize();
                for (i = 0, r = this.faces.length; i < r; i++) {
                    a = this.faces[i];
                    var p = a.vertexNormals;
                    3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            }, computeFlatVertexNormals: function () {
                var t, e, n;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    n = this.faces[t];
                    var i = n.vertexNormals;
                    3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = !0)
            }, computeMorphNormals: function () {
                var t, e, n, i, r;
                for (n = 0, i = this.faces.length; n < i; n++)for (r = this.faces[n], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++)r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                var a = new Et;
                for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                        var o, s, l = this.morphNormals[t].faceNormals, u = this.morphNormals[t].vertexNormals;
                        for (n = 0, i = this.faces.length; n < i; n++)o = new c, s = {
                            a: new c,
                            b: new c,
                            c: new c
                        }, l.push(o), u.push(s)
                    }
                    var h = this.morphNormals[t];
                    a.vertices = this.morphTargets[t].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                    var o, s;
                    for (n = 0, i = this.faces.length; n < i; n++)r = this.faces[n], o = h.faceNormals[n], s = h.vertexNormals[n], o.copy(r.normal), s.a.copy(r.vertexNormals[0]), s.b.copy(r.vertexNormals[1]), s.c.copy(r.vertexNormals[2])
                }
                for (n = 0, i = this.faces.length; n < i; n++)r = this.faces[n], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
            }, computeLineDistances: function () {
                for (var t = 0, e = this.vertices, n = 0, i = e.length; n < i; n++)n > 0 && (t += e[n].distanceTo(e[n - 1])), this.lineDistances[n] = t
            }, computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new $), this.boundingBox.setFromPoints(this.vertices)
            }, computeBoundingSphere: function () {
                null === this.boundingSphere && (this.boundingSphere = new tt), this.boundingSphere.setFromPoints(this.vertices)
            }, merge: function (t, e, n) {
                if ((t && t.isGeometry) === !1)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                var i, r = this.vertices.length, a = this.vertices, o = t.vertices, s = this.faces, c = t.faces, l = this.faceVertexUvs[0], u = t.faceVertexUvs[0], h = this.colors, d = t.colors;
                void 0 === n && (n = 0), void 0 !== e && (i = (new et).getNormalMatrix(e));
                for (var p = 0, f = o.length; p < f; p++) {
                    var m = o[p], g = m.clone();
                    void 0 !== e && g.applyMatrix4(e), a.push(g)
                }
                for (var p = 0, f = d.length; p < f; p++)h.push(d[p].clone());
                for (p = 0, f = c.length; p < f; p++) {
                    var v, y, _, x = c[p], b = x.vertexNormals, w = x.vertexColors;
                    v = new ht(x.a + r, x.b + r, x.c + r), v.normal.copy(x.normal), void 0 !== i && v.normal.applyMatrix3(i).normalize();
                    for (var M = 0, E = b.length; M < E; M++)y = b[M].clone(), void 0 !== i && y.applyMatrix3(i).normalize(), v.vertexNormals.push(y);
                    v.color.copy(x.color);
                    for (var M = 0, E = w.length; M < E; M++)_ = w[M], v.vertexColors.push(_.clone());
                    v.materialIndex = x.materialIndex + n, s.push(v)
                }
                for (p = 0, f = u.length; p < f; p++) {
                    var T = u[p], S = [];
                    if (void 0 !== T) {
                        for (var M = 0, E = T.length; M < E; M++)S.push(T[M].clone());
                        l.push(S);
                    }
                }
            }, mergeMesh: function (t) {
                return (t && t.isMesh) === !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) : (t.matrixAutoUpdate && t.updateMatrix(), void this.merge(t.geometry, t.matrix))
            }, mergeVertices: function () {
                var t, e, n, i, r, a, o, s, c = {}, l = [], u = [], h = 4, d = Math.pow(10, h);
                for (n = 0, i = this.vertices.length; n < i; n++)t = this.vertices[n], e = Math.round(t.x * d) + "_" + Math.round(t.y * d) + "_" + Math.round(t.z * d), void 0 === c[e] ? (c[e] = n, l.push(this.vertices[n]), u[n] = l.length - 1) : u[n] = u[c[e]];
                var p = [];
                for (n = 0, i = this.faces.length; n < i; n++) {
                    r = this.faces[n], r.a = u[r.a], r.b = u[r.b], r.c = u[r.c], a = [r.a, r.b, r.c];
                    for (var f = -1, m = 0; m < 3; m++)if (a[m] === a[(m + 1) % 3]) {
                        f = m, p.push(n);
                        break
                    }
                }
                for (n = p.length - 1; n >= 0; n--) {
                    var g = p[n];
                    for (this.faces.splice(g, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++)this.faceVertexUvs[o].splice(g, 1)
                }
                var v = this.vertices.length - l.length;
                return this.vertices = l, v
            }, sortFacesByMaterialIndex: function () {
                function t(t, e) {
                    return t.materialIndex - e.materialIndex
                }

                for (var e = this.faces, n = e.length, i = 0; i < n; i++)e[i]._id = i;
                e.sort(t);
                var r, a, o = this.faceVertexUvs[0], s = this.faceVertexUvs[1];
                o && o.length === n && (r = []), s && s.length === n && (a = []);
                for (var i = 0; i < n; i++) {
                    var c = e[i]._id;
                    r && r.push(o[c]), a && a.push(s[c])
                }
                r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a)
            }, toJSON: function () {
                function t(t, e, n) {
                    return n ? t | 1 << e : t & ~(1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return void 0 !== d[e] ? d[e] : (d[e] = h.length / 3, h.push(t.x, t.y, t.z), d[e])
                }

                function n(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return void 0 !== f[e] ? f[e] : (f[e] = p.length, p.push(t.getHex()), f[e])
                }

                function i(t) {
                    var e = t.x.toString() + t.y.toString();
                    return void 0 !== g[e] ? g[e] : (g[e] = m.length / 2, m.push(t.x, t.y), g[e])
                }

                var r = {metadata: {version: 4.4, type: "Geometry", generator: "Geometry.toJSON"}};
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                    var a = this.parameters;
                    for (var o in a)void 0 !== a[o] && (r[o] = a[o]);
                    return r
                }
                for (var s = [], c = 0; c < this.vertices.length; c++) {
                    var l = this.vertices[c];
                    s.push(l.x, l.y, l.z)
                }
                for (var u = [], h = [], d = {}, p = [], f = {}, m = [], g = {}, c = 0; c < this.faces.length; c++) {
                    var v = this.faces[c], y = !0, _ = !1, x = void 0 !== this.faceVertexUvs[0][c], b = v.normal.length() > 0, w = v.vertexNormals.length > 0, M = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b, E = v.vertexColors.length > 0, T = 0;
                    if (T = t(T, 0, 0), T = t(T, 1, y), T = t(T, 2, _), T = t(T, 3, x), T = t(T, 4, b), T = t(T, 5, w), T = t(T, 6, M), T = t(T, 7, E), u.push(T), u.push(v.a, v.b, v.c), u.push(v.materialIndex), x) {
                        var S = this.faceVertexUvs[0][c];
                        u.push(i(S[0]), i(S[1]), i(S[2]))
                    }
                    if (b && u.push(e(v.normal)), w) {
                        var A = v.vertexNormals;
                        u.push(e(A[0]), e(A[1]), e(A[2]))
                    }
                    if (M && u.push(n(v.color)), E) {
                        var L = v.vertexColors;
                        u.push(n(L[0]), n(L[1]), n(L[2]))
                    }
                }
                return r.data = {}, r.data.vertices = s, r.data.normals = h, p.length > 0 && (r.data.colors = p), m.length > 0 && (r.data.uvs = [m]), r.data.faces = u, r
            }, clone: function () {
                return (new Et).copy(this)
            }, copy: function (t) {
                this.vertices = [], this.faces = [], this.faceVertexUvs = [[]], this.colors = [];
                for (var e = t.vertices, n = 0, i = e.length; n < i; n++)this.vertices.push(e[n].clone());
                for (var r = t.colors, n = 0, i = r.length; n < i; n++)this.colors.push(r[n].clone());
                for (var a = t.faces, n = 0, i = a.length; n < i; n++)this.faces.push(a[n].clone());
                for (var n = 0, i = t.faceVertexUvs.length; n < i; n++) {
                    var o = t.faceVertexUvs[n];
                    void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []);
                    for (var s = 0, c = o.length; s < c; s++) {
                        for (var l = o[s], u = [], h = 0, d = l.length; h < d; h++) {
                            var p = l[h];
                            u.push(p.clone())
                        }
                        this.faceVertexUvs[n].push(u)
                    }
                }
                return this
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        });
        var ll = 0;
        Object.assign(St.prototype, e.prototype, {
            isBufferGeometry: !0, getIndex: function () {
                return this.index
            }, setIndex: function (t) {
                this.index = t
            }, addAttribute: function (t, e) {
                return (e && e.isBufferAttribute) === !1 && (e && e.isInterleavedBufferAttribute) === !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new pt(arguments[1], arguments[2]))) : "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this)
            }, getAttribute: function (t) {
                return this.attributes[t]
            }, removeAttribute: function (t) {
                return delete this.attributes[t], this
            }, addGroup: function (t, e, n) {
                this.groups.push({start: t, count: e, materialIndex: void 0 !== n ? n : 0})
            }, clearGroups: function () {
                this.groups = []
            }, setDrawRange: function (t, e) {
                this.drawRange.start = t, this.drawRange.count = e
            }, applyMatrix: function (t) {
                var e = this.attributes.position;
                void 0 !== e && (t.applyToVector3Array(e.array), e.needsUpdate = !0);
                var n = this.attributes.normal;
                if (void 0 !== n) {
                    var i = (new et).getNormalMatrix(t);
                    i.applyToVector3Array(n.array), n.needsUpdate = !0
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }, rotateX: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.makeRotationX(e), this.applyMatrix(t), this
                }
            }(), rotateY: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.makeRotationY(e), this.applyMatrix(t), this
                }
            }(), rotateZ: function () {
                var t;
                return function (e) {
                    return void 0 === t && (t = new l), t.makeRotationZ(e), this.applyMatrix(t), this
                }
            }(), translate: function () {
                var t;
                return function (e, n, i) {
                    return void 0 === t && (t = new l), t.makeTranslation(e, n, i), this.applyMatrix(t), this
                }
            }(), scale: function () {
                var t;
                return function (e, n, i) {
                    return void 0 === t && (t = new l), t.makeScale(e, n, i), this.applyMatrix(t), this
                }
            }(), lookAt: function () {
                var t;
                return function (e) {
                    void 0 === t && (t = new ct), t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                }
            }(), center: function () {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z), t
            }, setFromObject: function (t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    var n = new bt(3 * e.vertices.length, 3), i = new bt(3 * e.colors.length, 3);
                    if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var r = new bt(e.lineDistances.length, 1);
                        this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            }, updateFromObject: function (t) {
                var e = t.geometry;
                if (t.isMesh) {
                    var n = e.__directGeometry;
                    if (e.elementsNeedUpdate === !0 && (n = void 0, e.elementsNeedUpdate = !1), void 0 === n)return this.fromGeometry(e);
                    n.verticesNeedUpdate = e.verticesNeedUpdate, n.normalsNeedUpdate = e.normalsNeedUpdate, n.colorsNeedUpdate = e.colorsNeedUpdate, n.uvsNeedUpdate = e.uvsNeedUpdate, n.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = n
                }
                var i;
                return e.verticesNeedUpdate === !0 && (i = this.attributes.position, void 0 !== i && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), e.normalsNeedUpdate === !0 && (i = this.attributes.normal, void 0 !== i && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), e.colorsNeedUpdate === !0 && (i = this.attributes.color, void 0 !== i && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, void 0 !== i && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, void 0 !== i && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
            }, fromGeometry: function (t) {
                return t.__directGeometry = (new Mt).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
            }, fromDirectGeometry: function (t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.addAttribute("position", new pt(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    var n = new Float32Array(3 * t.normals.length);
                    this.addAttribute("normal", new pt(n, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var i = new Float32Array(3 * t.colors.length);
                    this.addAttribute("color", new pt(i, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var r = new Float32Array(2 * t.uvs.length);
                    this.addAttribute("uv", new pt(r, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var a = new Float32Array(2 * t.uvs2.length);
                    this.addAttribute("uv2", new pt(a, 2).copyVector2sArray(t.uvs2))
                }
                if (t.indices.length > 0) {
                    var o = t.vertices.length > 65535 ? Uint32Array : Uint16Array, s = new o(3 * t.indices.length);
                    this.setIndex(new pt(s, 1).copyIndicesArray(t.indices))
                }
                this.groups = t.groups;
                for (var c in t.morphTargets) {
                    for (var l = [], u = t.morphTargets[c], h = 0, d = u.length; h < d; h++) {
                        var p = u[h], f = new bt(3 * p.length, 3);
                        l.push(f.copyVector3sArray(p))
                    }
                    this.morphAttributes[c] = l
                }
                if (t.skinIndices.length > 0) {
                    var m = new bt(4 * t.skinIndices.length, 4);
                    this.addAttribute("skinIndex", m.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var g = new bt(4 * t.skinWeights.length, 4);
                    this.addAttribute("skinWeight", g.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
            }, computeBoundingBox: function () {
                null === this.boundingBox && (this.boundingBox = new $);
                var t = this.attributes.position;
                void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }, computeBoundingSphere: function () {
                var t = new $, e = new c;
                return function () {
                    null === this.boundingSphere && (this.boundingSphere = new tt);
                    var n = this.attributes.position;
                    if (n) {
                        var i = this.boundingSphere.center;
                        t.setFromBufferAttribute(n), t.getCenter(i);
                        for (var r = 0, a = 0, o = n.count; a < o; a++)e.x = n.getX(a), e.y = n.getY(a), e.z = n.getZ(a), r = Math.max(r, i.distanceToSquared(e));
                        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(), computeFaceNormals: function () {
            }, computeVertexNormals: function () {
                var t = this.index, e = this.attributes, n = this.groups;
                if (e.position) {
                    var i = e.position.array;
                    if (void 0 === e.normal)this.addAttribute("normal", new pt(new Float32Array(i.length), 3)); else for (var r = e.normal.array, a = 0, o = r.length; a < o; a++)r[a] = 0;
                    var s, l, u, h = e.normal.array, d = new c, p = new c, f = new c, m = new c, g = new c;
                    if (t) {
                        var v = t.array;
                        0 === n.length && this.addGroup(0, v.length);
                        for (var y = 0, _ = n.length; y < _; ++y)for (var x = n[y], b = x.start, w = x.count, a = b, o = b + w; a < o; a += 3)s = 3 * v[a + 0], l = 3 * v[a + 1], u = 3 * v[a + 2], d.fromArray(i, s), p.fromArray(i, l), f.fromArray(i, u), m.subVectors(f, p), g.subVectors(d, p), m.cross(g), h[s] += m.x, h[s + 1] += m.y, h[s + 2] += m.z, h[l] += m.x, h[l + 1] += m.y, h[l + 2] += m.z, h[u] += m.x, h[u + 1] += m.y, h[u + 2] += m.z
                    } else for (var a = 0, o = i.length; a < o; a += 9)d.fromArray(i, a), p.fromArray(i, a + 3), f.fromArray(i, a + 6), m.subVectors(f, p), g.subVectors(d, p), m.cross(g), h[a] = m.x, h[a + 1] = m.y, h[a + 2] = m.z, h[a + 3] = m.x, h[a + 4] = m.y, h[a + 5] = m.z, h[a + 6] = m.x, h[a + 7] = m.y, h[a + 8] = m.z;
                    this.normalizeNormals(), e.normal.needsUpdate = !0
                }
            }, merge: function (t, e) {
                if ((t && t.isBufferGeometry) === !1)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                void 0 === e && (e = 0);
                var n = this.attributes;
                for (var i in n)if (void 0 !== t.attributes[i])for (var r = n[i], a = r.array, o = t.attributes[i], s = o.array, c = o.itemSize, l = 0, u = c * e; l < s.length; l++, u++)a[u] = s[l];
                return this
            }, normalizeNormals: function () {
                for (var t, e, n, i, r = this.attributes.normal.array, a = 0, o = r.length; a < o; a += 3)t = r[a], e = r[a + 1], n = r[a + 2], i = 1 / Math.sqrt(t * t + e * e + n * n), r[a] *= i, r[a + 1] *= i, r[a + 2] *= i
            }, toNonIndexed: function () {
                if (null === this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var t = new St, e = this.index.array, n = this.attributes;
                for (var i in n) {
                    for (var r = n[i], a = r.array, o = r.itemSize, s = new a.constructor(e.length * o), c = 0, l = 0, u = 0, h = e.length; u < h; u++) {
                        c = e[u] * o;
                        for (var d = 0; d < o; d++)s[l++] = a[c++]
                    }
                    t.addAttribute(i, new pt(s, o))
                }
                return t
            }, toJSON: function () {
                var t = {metadata: {version: 4.4, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                    var e = this.parameters;
                    for (var n in e)void 0 !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {attributes: {}};
                var i = this.index;
                if (null !== i) {
                    var r = Array.prototype.slice.call(i.array);
                    t.data.index = {type: i.array.constructor.name, array: r}
                }
                var a = this.attributes;
                for (var n in a) {
                    var o = a[n], r = Array.prototype.slice.call(o.array);
                    t.data.attributes[n] = {
                        itemSize: o.itemSize,
                        type: o.array.constructor.name,
                        array: r,
                        normalized: o.normalized
                    }
                }
                var s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                var c = this.boundingSphere;
                return null !== c && (t.data.boundingSphere = {center: c.center.toArray(), radius: c.radius}), t
            }, clone: function () {
                return (new St).copy(this)
            }, copy: function (t) {
                var e = t.index;
                null !== e && this.setIndex(e.clone());
                var n = t.attributes;
                for (var i in n) {
                    var r = n[i];
                    this.addAttribute(i, r.clone())
                }
                for (var a = t.groups, o = 0, s = a.length; o < s; o++) {
                    var c = a[o];
                    this.addGroup(c.start, c.count, c.materialIndex)
                }
                return this
            }, dispose: function () {
                this.dispatchEvent({type: "dispose"})
            }
        }), St.MaxIndex = 65535, At.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: At,
            isMesh: !0,
            setDrawMode: function (t) {
                this.drawMode = t
            },
            copy: function (t) {
                return ct.prototype.copy.call(this, t), this.drawMode = t.drawMode, this
            },
            updateMorphTargets: function () {
                var t = this.geometry.morphTargets;
                if (void 0 !== t && t.length > 0) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (var e = 0, n = t.length; e < n; e++)this.morphTargetInfluences.push(0), this.morphTargetDictionary[t[e].name] = e
                }
            },
            raycast: function () {
                function t(t, e, n, i, r, a, o) {
                    return ut.barycoordFromPoint(t, e, n, i, y), r.multiplyScalar(y.x), a.multiplyScalar(y.y), o.multiplyScalar(y.z), r.add(a).add(o), r.clone()
                }

                function e(t, e, n, i, r, a, o) {
                    var s, c = t.material;
                    if (s = c.side === kr ? n.intersectTriangle(a, r, i, !0, o) : n.intersectTriangle(i, r, a, c.side !== Hr, o), null === s)return null;
                    x.copy(o), x.applyMatrix4(t.matrixWorld);
                    var l = e.ray.origin.distanceTo(x);
                    return l < e.near || l > e.far ? null : {distance: l, point: x.clone(), object: t}
                }

                function i(n, i, r, a, o, c, l, d) {
                    s.fromArray(a, 3 * c), u.fromArray(a, 3 * l), h.fromArray(a, 3 * d);
                    var p = e(n, i, r, s, u, h, _);
                    return p && (o && (m.fromArray(o, 2 * c), g.fromArray(o, 2 * l), v.fromArray(o, 2 * d), p.uv = t(_, s, u, h, m, g, v)), p.face = new ht(c, l, d, ut.normal(s, u, h)), p.faceIndex = c), p
                }

                var r = new l, a = new at, o = new tt, s = new c, u = new c, h = new c, d = new c, p = new c, f = new c, m = new n, g = new n, v = new n, y = new c, _ = new c, x = new c;
                return function (n, c) {
                    var l = this.geometry, y = this.material, x = this.matrixWorld;
                    if (void 0 !== y && (null === l.boundingSphere && l.computeBoundingSphere(), o.copy(l.boundingSphere), o.applyMatrix4(x), n.ray.intersectsSphere(o) !== !1 && (r.getInverse(x), a.copy(n.ray).applyMatrix4(r), null === l.boundingBox || a.intersectsBox(l.boundingBox) !== !1))) {
                        var b, w;
                        if (l.isBufferGeometry) {
                            var M, E, T, S = l.index, A = l.attributes, L = A.position.array;
                            if (void 0 !== A.uv && (b = A.uv.array), null !== S)for (var R = S.array, C = 0, P = R.length; C < P; C += 3)M = R[C], E = R[C + 1], T = R[C + 2], w = i(this, n, a, L, b, M, E, T), w && (w.faceIndex = Math.floor(C / 3), c.push(w)); else for (var C = 0, P = L.length; C < P; C += 9)M = C / 3, E = M + 1, T = M + 2, w = i(this, n, a, L, b, M, E, T), w && (w.index = M, c.push(w))
                        } else if (l.isGeometry) {
                            var O, I, U, N = y && y.isMultiMaterial, D = N === !0 ? y.materials : null, F = l.vertices, B = l.faces, z = l.faceVertexUvs[0];
                            z.length > 0 && (b = z);
                            for (var G = 0, k = B.length; G < k; G++) {
                                var H = B[G], V = N === !0 ? D[H.materialIndex] : y;
                                if (void 0 !== V) {
                                    if (O = F[H.a], I = F[H.b], U = F[H.c], V.morphTargets === !0) {
                                        var j = l.morphTargets, W = this.morphTargetInfluences;
                                        s.set(0, 0, 0), u.set(0, 0, 0), h.set(0, 0, 0);
                                        for (var X = 0, Y = j.length; X < Y; X++) {
                                            var q = W[X];
                                            if (0 !== q) {
                                                var Z = j[X].vertices;
                                                s.addScaledVector(d.subVectors(Z[H.a], O), q), u.addScaledVector(p.subVectors(Z[H.b], I), q), h.addScaledVector(f.subVectors(Z[H.c], U), q)
                                            }
                                        }
                                        s.add(O), u.add(I), h.add(U), O = s, I = u, U = h
                                    }
                                    if (w = e(this, n, a, O, I, U, _)) {
                                        if (b) {
                                            var J = b[G];
                                            m.copy(J[0]), g.copy(J[1]), v.copy(J[2]), w.uv = t(_, O, I, U, m, g, v)
                                        }
                                        w.face = H, w.faceIndex = G, c.push(w)
                                    }
                                }
                            }
                        }
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), Lt.prototype = Object.create(St.prototype), Lt.prototype.constructor = Lt, Rt.prototype = Object.create(St.prototype), Rt.prototype.constructor = Rt, Ct.prototype = Object.create(ct.prototype), Ct.prototype.constructor = Ct, Ct.prototype.isCamera = !0, Ct.prototype.getWorldDirection = function () {
            var t = new s;
            return function (e) {
                var n = e || new c;
                return this.getWorldQuaternion(t), n.set(0, 0, -1).applyQuaternion(t)
            }
        }(), Ct.prototype.lookAt = function () {
            var t = new l;
            return function (e) {
                t.lookAt(this.position, e, this.up), this.quaternion.setFromRotationMatrix(t)
            }
        }(), Ct.prototype.clone = function () {
            return (new this.constructor).copy(this)
        }, Ct.prototype.copy = function (t) {
            return ct.prototype.copy.call(this, t), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this
        }, Pt.prototype = Object.assign(Object.create(Ct.prototype), {
            constructor: Pt,
            isPerspectiveCamera: !0,
            copy: function (t) {
                return Ct.prototype.copy.call(this, t), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
            },
            setFocalLength: function (t) {
                var e = .5 * this.getFilmHeight() / t;
                this.fov = 2 * Qo.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
            },
            getFocalLength: function () {
                var t = Math.tan(.5 * Qo.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / t
            },
            getEffectiveFOV: function () {
                return 2 * Qo.RAD2DEG * Math.atan(Math.tan(.5 * Qo.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function () {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function () {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function (t, e, n, i, r, a) {
                this.aspect = t / e, this.view = {
                    fullWidth: t,
                    fullHeight: e,
                    offsetX: n,
                    offsetY: i,
                    width: r,
                    height: a
                }, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                this.view = null, this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var t = this.near, e = t * Math.tan(.5 * Qo.DEG2RAD * this.fov) / this.zoom, n = 2 * e, i = this.aspect * n, r = -.5 * i, a = this.view;
                if (null !== a) {
                    var o = a.fullWidth, s = a.fullHeight;
                    r += a.offsetX * i / o, e -= a.offsetY * n / s, i *= a.width / o, n *= a.height / s
                }
                var c = this.filmOffset;
                0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makeFrustum(r, r + i, e - n, e, t, this.far)
            },
            toJSON: function (t) {
                var e = ct.prototype.toJSON.call(this, t);
                return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
            }
        }), Ot.prototype = Object.assign(Object.create(Ct.prototype), {
            constructor: Ot,
            isOrthographicCamera: !0,
            copy: function (t) {
                return Ct.prototype.copy.call(this, t), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
            },
            setViewOffset: function (t, e, n, i, r, a) {
                this.view = {
                    fullWidth: t,
                    fullHeight: e,
                    offsetX: n,
                    offsetY: i,
                    width: r,
                    height: a
                }, this.updateProjectionMatrix()
            },
            clearViewOffset: function () {
                this.view = null, this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function () {
                var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2, r = n - t, a = n + t, o = i + e, s = i - e;
                if (null !== this.view) {
                    var c = this.zoom / (this.view.width / this.view.fullWidth), l = this.zoom / (this.view.height / this.view.fullHeight), u = (this.right - this.left) / this.view.width, h = (this.top - this.bottom) / this.view.height;
                    r += u * (this.view.offsetX / c), a = r + u * (this.view.width / c), o -= h * (this.view.offsetY / l), s = o - h * (this.view.height / l)
                }
                this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far)
            },
            toJSON: function (t) {
                var e = ct.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
            }
        });
        var ul = 0;
        oe.prototype.isFogExp2 = !0, oe.prototype.clone = function () {
            return new oe(this.color.getHex(), this.density)
        }, oe.prototype.toJSON = function (t) {
            return {type: "FogExp2", color: this.color.getHex(), density: this.density}
        }, se.prototype.isFog = !0, se.prototype.clone = function () {
            return new se(this.color.getHex(), this.near, this.far)
        }, se.prototype.toJSON = function (t) {
            return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
        }, ce.prototype = Object.create(ct.prototype), ce.prototype.constructor = ce, ce.prototype.copy = function (t, e) {
            return ct.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        }, ce.prototype.toJSON = function (t) {
            var e = ct.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }, le.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: le,
            isLensFlare: !0,
            copy: function (t) {
                ct.prototype.copy.call(this, t), this.positionScreen.copy(t.positionScreen), this.customUpdateCallback = t.customUpdateCallback;
                for (var e = 0, n = t.lensFlares.length; e < n; e++)this.lensFlares.push(t.lensFlares[e]);
                return this
            },
            add: function (t, e, n, i, r, a) {
                void 0 === e && (e = -1), void 0 === n && (n = 0), void 0 === a && (a = 1), void 0 === r && (r = new W(16777215)), void 0 === i && (i = Zr), n = Math.min(n, Math.max(0, n)), this.lensFlares.push({
                    texture: t,
                    size: e,
                    distance: n,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 0,
                    opacity: a,
                    color: r,
                    blending: i
                })
            },
            updateLensFlares: function () {
                var t, e, n = this.lensFlares.length, i = 2 * -this.positionScreen.x, r = 2 * -this.positionScreen.y;
                for (t = 0; t < n; t++)e = this.lensFlares[t], e.x = this.positionScreen.x + i * e.distance, e.y = this.positionScreen.y + r * e.distance, e.wantedRotation = e.x * Math.PI * .25, e.rotation += .25 * (e.wantedRotation - e.rotation)
            }
        }), ue.prototype = Object.create(J.prototype), ue.prototype.constructor = ue, ue.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this
        }, he.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: he,
            isSprite: !0,
            raycast: function () {
                var t = new c;
                return function (e, n) {
                    t.setFromMatrixPosition(this.matrixWorld);
                    var i = e.ray.distanceSqToPoint(t), r = this.scale.x * this.scale.y / 4;
                    i > r || n.push({distance: Math.sqrt(i), point: this.position, face: null, object: this})
                }
            }(),
            clone: function () {
                return new this.constructor(this.material).copy(this)
            }
        }), de.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: de, copy: function (t) {
                ct.prototype.copy.call(this, t, !1);
                for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
                    var r = e[n];
                    this.addLevel(r.object.clone(), r.distance)
                }
                return this
            }, addLevel: function (t, e) {
                void 0 === e && (e = 0), e = Math.abs(e);
                for (var n = this.levels, i = 0; i < n.length && !(e < n[i].distance); i++);
                n.splice(i, 0, {distance: e, object: t}), this.add(t)
            }, getObjectForDistance: function (t) {
                for (var e = this.levels, n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                return e[n - 1].object
            }, raycast: function () {
                var t = new c;
                return function (e, n) {
                    t.setFromMatrixPosition(this.matrixWorld);
                    var i = e.ray.origin.distanceTo(t);
                    this.getObjectForDistance(i).raycast(e, n)
                }
            }(), update: function () {
                var t = new c, e = new c;
                return function (n) {
                    var i = this.levels;
                    if (i.length > 1) {
                        t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                        var r = t.distanceTo(e);
                        i[0].object.visible = !0;
                        for (var a = 1, o = i.length; a < o && r >= i[a].distance; a++)i[a - 1].object.visible = !1, i[a].object.visible = !0;
                        for (; a < o; a++)i[a].object.visible = !1
                    }
                }
            }(), toJSON: function (t) {
                var e = ct.prototype.toJSON.call(this, t);
                e.object.levels = [];
                for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                    var a = n[i];
                    e.object.levels.push({object: a.object.uuid, distance: a.distance})
                }
                return e
            }
        }), Object.assign(pe.prototype, {
            calculateInverses: function () {
                this.boneInverses = [];
                for (var t = 0, e = this.bones.length; t < e; t++) {
                    var n = new l;
                    this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
                }
            }, pose: function () {
                for (var t, e = 0, n = this.bones.length; e < n; e++)t = this.bones[e], t && t.matrixWorld.getInverse(this.boneInverses[e]);
                for (var e = 0, n = this.bones.length; e < n; e++)t = this.bones[e], t && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
            }, update: function () {
                var t = new l;
                return function () {
                    for (var e = 0, n = this.bones.length; e < n; e++) {
                        var i = this.bones[e] ? this.bones[e].matrixWorld : this.identityMatrix;
                        t.multiplyMatrices(i, this.boneInverses[e]), t.toArray(this.boneMatrices, 16 * e)
                    }
                    this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                }
            }(), clone: function () {
                return new pe(this.bones, this.boneInverses, this.useVertexTexture)
            }
        }), fe.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: fe,
            isBone: !0
        }), me.prototype = Object.assign(Object.create(At.prototype), {
            constructor: me,
            isSkinnedMesh: !0,
            bind: function (t, e) {
                this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
            },
            pose: function () {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function () {
                if (this.geometry && this.geometry.isGeometry)for (var t = 0; t < this.geometry.skinWeights.length; t++) {
                    var e = this.geometry.skinWeights[t], n = 1 / e.lengthManhattan();
                    n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0)
                } else if (this.geometry && this.geometry.isBufferGeometry)for (var i = new r, a = this.geometry.attributes.skinWeight, t = 0; t < a.count; t++) {
                    i.x = a.getX(t), i.y = a.getY(t), i.z = a.getZ(t), i.w = a.getW(t);
                    var n = 1 / i.lengthManhattan();
                    n !== 1 / 0 ? i.multiplyScalar(n) : i.set(1, 0, 0, 0), a.setXYZW(t, i.x, i.y, i.z, i.w)
                }
            },
            updateMatrixWorld: function (t) {
                At.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
            },
            clone: function () {
                return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this)
            }
        }), ge.prototype = Object.create(J.prototype), ge.prototype.constructor = ge, ge.prototype.isLineBasicMaterial = !0, ge.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
        }, ve.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: ve,
            isLine: !0,
            raycast: function () {
                var t = new l, e = new at, n = new tt;
                return function (i, r) {
                    var a = i.linePrecision, o = a * a, s = this.geometry, l = this.matrixWorld;
                    if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(l), i.ray.intersectsSphere(n) !== !1) {
                        t.getInverse(l), e.copy(i.ray).applyMatrix4(t);
                        var u = new c, h = new c, d = new c, p = new c, f = this && this.isLineSegments ? 2 : 1;
                        if (s.isBufferGeometry) {
                            var m = s.index, g = s.attributes, v = g.position.array;
                            if (null !== m)for (var y = m.array, _ = 0, x = y.length - 1; _ < x; _ += f) {
                                var b = y[_], w = y[_ + 1];
                                u.fromArray(v, 3 * b), h.fromArray(v, 3 * w);
                                var M = e.distanceSqToSegment(u, h, p, d);
                                if (!(M > o)) {
                                    p.applyMatrix4(this.matrixWorld);
                                    var E = i.ray.origin.distanceTo(p);
                                    E < i.near || E > i.far || r.push({
                                        distance: E,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: _,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            } else for (var _ = 0, x = v.length / 3 - 1; _ < x; _ += f) {
                                u.fromArray(v, 3 * _), h.fromArray(v, 3 * _ + 3);
                                var M = e.distanceSqToSegment(u, h, p, d);
                                if (!(M > o)) {
                                    p.applyMatrix4(this.matrixWorld);
                                    var E = i.ray.origin.distanceTo(p);
                                    E < i.near || E > i.far || r.push({
                                        distance: E,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: _,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        } else if (s.isGeometry)for (var T = s.vertices, S = T.length, _ = 0; _ < S - 1; _ += f) {
                            var M = e.distanceSqToSegment(T[_], T[_ + 1], p, d);
                            if (!(M > o)) {
                                p.applyMatrix4(this.matrixWorld);
                                var E = i.ray.origin.distanceTo(p);
                                E < i.near || E > i.far || r.push({
                                    distance: E,
                                    point: d.clone().applyMatrix4(this.matrixWorld),
                                    index: _,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), ye.prototype = Object.assign(Object.create(ve.prototype), {
            constructor: ye,
            isLineSegments: !0
        }), _e.prototype = Object.create(J.prototype), _e.prototype.constructor = _e, _e.prototype.isPointsMaterial = !0, _e.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this
        }, xe.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: xe,
            isPoints: !0,
            raycast: function () {
                var t = new l, e = new at, n = new tt;
                return function (i, r) {
                    function a(t, n) {
                        var a = e.distanceSqToPoint(t);
                        if (a < d) {
                            var s = e.closestPointToPoint(t);
                            s.applyMatrix4(l);
                            var c = i.ray.origin.distanceTo(s);
                            if (c < i.near || c > i.far)return;
                            r.push({
                                distance: c,
                                distanceToRay: Math.sqrt(a),
                                point: s.clone(),
                                index: n,
                                face: null,
                                object: o
                            })
                        }
                    }

                    var o = this, s = this.geometry, l = this.matrixWorld, u = i.params.Points.threshold;
                    if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(l), i.ray.intersectsSphere(n) !== !1) {
                        t.getInverse(l), e.copy(i.ray).applyMatrix4(t);
                        var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3), d = h * h, p = new c;
                        if (s.isBufferGeometry) {
                            var f = s.index, m = s.attributes, g = m.position.array;
                            if (null !== f)for (var v = f.array, y = 0, _ = v.length; y < _; y++) {
                                var x = v[y];
                                p.fromArray(g, 3 * x), a(p, x)
                            } else for (var y = 0, b = g.length / 3; y < b; y++)p.fromArray(g, 3 * y), a(p, y)
                        } else for (var w = s.vertices, y = 0, b = w.length; y < b; y++)a(w[y], y)
                    }
                }
            }(),
            clone: function () {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), be.prototype = Object.assign(Object.create(ct.prototype), {constructor: be}), we.prototype = Object.create(i.prototype), we.prototype.constructor = we, Me.prototype = Object.create(i.prototype), Me.prototype.constructor = Me, Me.prototype.isCompressedTexture = !0, Ee.prototype = Object.create(i.prototype), Ee.prototype.constructor = Ee, Te.prototype = Object.create(i.prototype), Te.prototype.constructor = Te, Te.prototype.isDepthTexture = !0, Se.prototype = Object.create(St.prototype), Se.prototype.constructor = Se, Ae.prototype = Object.create(St.prototype), Ae.prototype.constructor = Ae, Le.prototype = Object.create(Et.prototype), Le.prototype.constructor = Le, Re.prototype = Object.create(St.prototype), Re.prototype.constructor = Re, Ce.prototype = Object.create(Re.prototype), Ce.prototype.constructor = Ce, Pe.prototype = Object.create(Et.prototype), Pe.prototype.constructor = Pe, Oe.prototype = Object.create(Re.prototype), Oe.prototype.constructor = Oe, Ie.prototype = Object.create(Et.prototype), Ie.prototype.constructor = Ie, Ue.prototype = Object.create(Re.prototype), Ue.prototype.constructor = Ue, Ne.prototype = Object.create(Et.prototype), Ne.prototype.constructor = Ne, De.prototype = Object.create(Re.prototype), De.prototype.constructor = De, Fe.prototype = Object.create(Et.prototype), Fe.prototype.constructor = Fe, Be.prototype = Object.create(Et.prototype), Be.prototype.constructor = Be, ze.prototype = Object.create(St.prototype), ze.prototype.constructor = ze, Ge.prototype = Object.create(Et.prototype), Ge.prototype.constructor = Ge, ke.prototype = Object.create(St.prototype), ke.prototype.constructor = ke, He.prototype = Object.create(Et.prototype), He.prototype.constructor = He, Ve.prototype = Object.create(St.prototype), Ve.prototype.constructor = Ve, je.prototype = Object.create(Et.prototype), je.prototype.constructor = je;
        var hl = {
            area: function (t) {
                for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)n += t[i].x * t[r].y - t[r].x * t[i].y;
                return .5 * n
            }, triangulate: function () {
                function t(t, e, n, i, r, a) {
                    var o, s, c, l, u, h, d, p, f;
                    if (s = t[a[e]].x, c = t[a[e]].y, l = t[a[n]].x, u = t[a[n]].y, h = t[a[i]].x, d = t[a[i]].y, (l - s) * (d - c) - (u - c) * (h - s) <= 0)return !1;
                    var m, g, v, y, _, x, b, w, M, E, T, S, A, L, R;
                    for (m = h - l, g = d - u, v = s - h, y = c - d, _ = l - s, x = u - c, o = 0; o < r; o++)if (p = t[a[o]].x, f = t[a[o]].y, !(p === s && f === c || p === l && f === u || p === h && f === d) && (b = p - s, w = f - c, M = p - l, E = f - u, T = p - h, S = f - d, R = m * E - g * M, A = _ * w - x * b, L = v * S - y * T, R >= -Number.EPSILON && L >= -Number.EPSILON && A >= -Number.EPSILON))return !1;
                    return !0
                }

                return function (e, n) {
                    var i = e.length;
                    if (i < 3)return null;
                    var r, a, o, s = [], c = [], l = [];
                    if (hl.area(e) > 0)for (a = 0; a < i; a++)c[a] = a; else for (a = 0; a < i; a++)c[a] = i - 1 - a;
                    var u = i, h = 2 * u;
                    for (a = u - 1; u > 2;) {
                        if (h-- <= 0)return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), n ? l : s;
                        if (r = a, u <= r && (r = 0), a = r + 1, u <= a && (a = 0), o = a + 1, u <= o && (o = 0), t(e, r, a, o, u, c)) {
                            var d, p, f, m, g;
                            for (d = c[r], p = c[a], f = c[o], s.push([e[d], e[p], e[f]]), l.push([c[r], c[a], c[o]]), m = a, g = a + 1; g < u; m++, g++)c[m] = c[g];
                            u--, h = 2 * u
                        }
                    }
                    return n ? l : s
                }
            }(), triangulateShape: function (t, e) {
                function n(t) {
                    var e = t.length;
                    e > 2 && t[e - 1].equals(t[0]) && t.pop()
                }

                function i(t, e, n) {
                    return t.x !== e.x ? t.x < e.x ? t.x <= n.x && n.x <= e.x : e.x <= n.x && n.x <= t.x : t.y < e.y ? t.y <= n.y && n.y <= e.y : e.y <= n.y && n.y <= t.y
                }

                function r(t, e, n, r, a) {
                    var o = e.x - t.x, s = e.y - t.y, c = r.x - n.x, l = r.y - n.y, u = t.x - n.x, h = t.y - n.y, d = s * c - o * l, p = s * u - o * h;
                    if (Math.abs(d) > Number.EPSILON) {
                        var f;
                        if (d > 0) {
                            if (p < 0 || p > d)return [];
                            if (f = l * u - c * h, f < 0 || f > d)return []
                        } else {
                            if (p > 0 || p < d)return [];
                            if (f = l * u - c * h, f > 0 || f < d)return []
                        }
                        if (0 === f)return !a || 0 !== p && p !== d ? [t] : [];
                        if (f === d)return !a || 0 !== p && p !== d ? [e] : [];
                        if (0 === p)return [n];
                        if (p === d)return [r];
                        var m = f / d;
                        return [{x: t.x + m * o, y: t.y + m * s}]
                    }
                    if (0 !== p || l * u !== c * h)return [];
                    var g = 0 === o && 0 === s, v = 0 === c && 0 === l;
                    if (g && v)return t.x !== n.x || t.y !== n.y ? [] : [t];
                    if (g)return i(n, r, t) ? [t] : [];
                    if (v)return i(t, e, n) ? [n] : [];
                    var y, _, x, b, w, M, E, T;
                    return 0 !== o ? (t.x < e.x ? (y = t, x = t.x, _ = e, b = e.x) : (y = e, x = e.x, _ = t, b = t.x), n.x < r.x ? (w = n, E = n.x, M = r, T = r.x) : (w = r, E = r.x, M = n, T = n.x)) : (t.y < e.y ? (y = t, x = t.y, _ = e, b = e.y) : (y = e, x = e.y, _ = t, b = t.y), n.y < r.y ? (w = n, E = n.y, M = r, T = r.y) : (w = r, E = r.y, M = n, T = n.y)), x <= E ? b < E ? [] : b === E ? a ? [] : [w] : b <= T ? [w, _] : [w, M] : x > T ? [] : x === T ? a ? [] : [y] : b <= T ? [y, _] : [y, M]
                }

                function a(t, e, n, i) {
                    var r = e.x - t.x, a = e.y - t.y, o = n.x - t.x, s = n.y - t.y, c = i.x - t.x, l = i.y - t.y, u = r * s - a * o, h = r * l - a * c;
                    if (Math.abs(u) > Number.EPSILON) {
                        var d = c * s - l * o;
                        return u > 0 ? h >= 0 && d >= 0 : h >= 0 || d >= 0
                    }
                    return h > 0
                }

                function o(t, e) {
                    function n(t, e) {
                        var n = y.length - 1, i = t - 1;
                        i < 0 && (i = n);
                        var r = t + 1;
                        r > n && (r = 0);
                        var o = a(y[t], y[i], y[r], s[e]);
                        if (!o)return !1;
                        var c = s.length - 1, l = e - 1;
                        l < 0 && (l = c);
                        var u = e + 1;
                        return u > c && (u = 0), o = a(s[e], s[l], s[u], y[t]), !!o
                    }

                    function i(t, e) {
                        var n, i, a;
                        for (n = 0; n < y.length; n++)if (i = n + 1, i %= y.length, a = r(t, e, y[n], y[i], !0), a.length > 0)return !0;
                        return !1
                    }

                    function o(t, n) {
                        var i, a, o, s, c;
                        for (i = 0; i < _.length; i++)for (a = e[_[i]], o = 0; o < a.length; o++)if (s = o + 1, s %= a.length, c = r(t, n, a[o], a[s], !0), c.length > 0)return !0;
                        return !1
                    }

                    for (var s, c, l, u, h, d, p, f, m, g, v, y = t.concat(), _ = [], x = [], b = 0, w = e.length; b < w; b++)_.push(b);
                    for (var M = 0, E = 2 * _.length; _.length > 0;) {
                        if (E--, E < 0) {
                            console.log("Infinite Loop! Holes left:" + _.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (l = M; l < y.length; l++) {
                            u = y[l], c = -1;
                            for (var b = 0; b < _.length; b++)if (d = _[b], p = u.x + ":" + u.y + ":" + d, void 0 === x[p]) {
                                s = e[d];
                                for (var T = 0; T < s.length; T++)if (h = s[T], n(l, T) && !i(u, h) && !o(u, h)) {
                                    c = T, _.splice(b, 1), f = y.slice(0, l + 1), m = y.slice(l), g = s.slice(c), v = s.slice(0, c + 1), y = f.concat(g).concat(v).concat(m), M = l;
                                    break
                                }
                                if (c >= 0)break;
                                x[p] = !0
                            }
                            if (c >= 0)break
                        }
                    }
                    return y
                }

                n(t), e.forEach(n);
                for (var s, c, l, u, h, d, p = {}, f = t.concat(), m = 0, g = e.length; m < g; m++)Array.prototype.push.apply(f, e[m]);
                for (s = 0, c = f.length; s < c; s++)h = f[s].x + ":" + f[s].y, void 0 !== p[h] && console.warn("THREE.ShapeUtils: Duplicate point", h, s), p[h] = s;
                var v = o(t, e), y = hl.triangulate(v, !1);
                for (s = 0, c = y.length; s < c; s++)for (u = y[s], l = 0; l < 3; l++)h = u[l].x + ":" + u[l].y, d = p[h], void 0 !== d && (u[l] = d);
                return y.concat()
            }, isClockWise: function (t) {
                return hl.area(t) < 0
            }, b2: function () {
                function t(t, e) {
                    var n = 1 - t;
                    return n * n * e
                }

                function e(t, e) {
                    return 2 * (1 - t) * t * e
                }

                function n(t, e) {
                    return t * t * e
                }

                return function (i, r, a, o) {
                    return t(i, r) + e(i, a) + n(i, o)
                }
            }(), b3: function () {
                function t(t, e) {
                    var n = 1 - t;
                    return n * n * n * e
                }

                function e(t, e) {
                    var n = 1 - t;
                    return 3 * n * n * t * e
                }

                function n(t, e) {
                    var n = 1 - t;
                    return 3 * n * t * t * e
                }

                function i(t, e) {
                    return t * t * t * e
                }

                return function (r, a, o, s, c) {
                    return t(r, a) + e(r, o) + n(r, s) + i(r, c)
                }
            }()
        };
        We.prototype = Object.create(Et.prototype), We.prototype.constructor = We, We.prototype.addShapeList = function (t, e) {
            for (var n = t.length, i = 0; i < n; i++) {
                var r = t[i];
                this.addShape(r, e)
            }
        }, We.prototype.addShape = function (t, e) {
            function i(t, e, n) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
            }

            function r(t, e, i) {
                var r, a, o = 1, s = t.x - e.x, c = t.y - e.y, l = i.x - t.x, u = i.y - t.y, h = s * s + c * c, d = s * u - c * l;
                if (Math.abs(d) > Number.EPSILON) {
                    var p = Math.sqrt(h), f = Math.sqrt(l * l + u * u), m = e.x - c / p, g = e.y + s / p, v = i.x - u / f, y = i.y + l / f, _ = ((v - m) * u - (y - g) * l) / (s * u - c * l);
                    r = m + s * _ - t.x, a = g + c * _ - t.y;
                    var x = r * r + a * a;
                    if (x <= 2)return new n(r, a);
                    o = Math.sqrt(x / 2)
                } else {
                    var b = !1;
                    s > Number.EPSILON ? l > Number.EPSILON && (b = !0) : s < -Number.EPSILON ? l < -Number.EPSILON && (b = !0) : Math.sign(c) === Math.sign(u) && (b = !0), b ? (r = -c, a = s, o = Math.sqrt(h)) : (r = s, a = c, o = Math.sqrt(h / 2))
                }
                return new n(r / o, a / o)
            }

            function a() {
                if (b) {
                    var t = 0, e = j * t;
                    for (Y = 0; Y < W; Y++)V = D[Y], u(V[2] + e, V[1] + e, V[0] + e);
                    for (t = M + 2 * x, e = j * t, Y = 0; Y < W; Y++)V = D[Y], u(V[0] + e, V[1] + e, V[2] + e)
                } else {
                    for (Y = 0; Y < W; Y++)V = D[Y], u(V[2], V[1], V[0]);
                    for (Y = 0; Y < W; Y++)V = D[Y], u(V[0] + j * M, V[1] + j * M, V[2] + j * M)
                }
            }

            function o() {
                var t = 0;
                for (s(F, t), t += F.length, L = 0, R = U.length; L < R; L++)A = U[L], s(A, t), t += A.length
            }

            function s(t, e) {
                var n, i;
                for (Y = t.length; --Y >= 0;) {
                    n = Y, i = Y - 1, i < 0 && (i = t.length - 1);
                    var r = 0, a = M + 2 * x;
                    for (r = 0; r < a; r++) {
                        var o = j * r, s = j * (r + 1), c = e + n + o, l = e + i + o, u = e + i + s, d = e + n + s;
                        h(c, l, u, d, t, r, a, n, i)
                    }
                }
            }

            function l(t, e, n) {
                C.vertices.push(new c(t, e, n))
            }

            function u(t, e, n) {
                t += P, e += P, n += P, C.faces.push(new ht(t, e, n, null, null, 0));
                var i = S.generateTopUV(C, t, e, n);
                C.faceVertexUvs[0].push(i)
            }

            function h(t, e, n, i, r, a, o, s, c) {
                t += P, e += P, n += P, i += P, C.faces.push(new ht(t, e, i, null, null, 1)), C.faces.push(new ht(e, n, i, null, null, 1));
                var l = S.generateSideWallUV(C, t, e, n, i);
                C.faceVertexUvs[0].push([l[0], l[1], l[3]]), C.faceVertexUvs[0].push([l[1], l[2], l[3]])
            }

            var d, p, f, m, g, v = void 0 !== e.amount ? e.amount : 100, y = void 0 !== e.bevelThickness ? e.bevelThickness : 6, _ = void 0 !== e.bevelSize ? e.bevelSize : y - 2, x = void 0 !== e.bevelSegments ? e.bevelSegments : 3, b = void 0 === e.bevelEnabled || e.bevelEnabled, w = void 0 !== e.curveSegments ? e.curveSegments : 12, M = void 0 !== e.steps ? e.steps : 1, E = e.extrudePath, T = !1, S = void 0 !== e.UVGenerator ? e.UVGenerator : We.WorldUVGenerator;
            E && (d = E.getSpacedPoints(M), T = !0, b = !1, p = void 0 !== e.frames ? e.frames : E.computeFrenetFrames(M, !1), f = new c, m = new c, g = new c), b || (x = 0, y = 0, _ = 0);
            var A, L, R, C = this, P = this.vertices.length, O = t.extractPoints(w), I = O.shape, U = O.holes, N = !hl.isClockWise(I);
            if (N) {
                for (I = I.reverse(), L = 0, R = U.length; L < R; L++)A = U[L], hl.isClockWise(A) && (U[L] = A.reverse());
                N = !1
            }
            var D = hl.triangulateShape(I, U), F = I;
            for (L = 0, R = U.length; L < R; L++)A = U[L], I = I.concat(A);
            for (var B, z, G, k, H, V, j = I.length, W = D.length, X = [], Y = 0, q = F.length, Z = q - 1, J = Y + 1; Y < q; Y++, Z++, J++)Z === q && (Z = 0), J === q && (J = 0), X[Y] = r(F[Y], F[Z], F[J]);
            var Q, K = [], $ = X.concat();
            for (L = 0, R = U.length; L < R; L++) {
                for (A = U[L], Q = [], Y = 0, q = A.length, Z = q - 1, J = Y + 1; Y < q; Y++, Z++, J++)Z === q && (Z = 0), J === q && (J = 0), Q[Y] = r(A[Y], A[Z], A[J]);
                K.push(Q), $ = $.concat(Q)
            }
            for (B = 0; B < x; B++) {
                for (G = B / x, k = y * Math.cos(G * Math.PI / 2), z = _ * Math.sin(G * Math.PI / 2), Y = 0, q = F.length; Y < q; Y++)H = i(F[Y], X[Y], z), l(H.x, H.y, -k);
                for (L = 0, R = U.length; L < R; L++)for (A = U[L], Q = K[L], Y = 0, q = A.length; Y < q; Y++)H = i(A[Y], Q[Y], z), l(H.x, H.y, -k)
            }
            for (z = _, Y = 0; Y < j; Y++)H = b ? i(I[Y], $[Y], z) : I[Y], T ? (m.copy(p.normals[0]).multiplyScalar(H.x), f.copy(p.binormals[0]).multiplyScalar(H.y), g.copy(d[0]).add(m).add(f), l(g.x, g.y, g.z)) : l(H.x, H.y, 0);
            var tt;
            for (tt = 1; tt <= M; tt++)for (Y = 0; Y < j; Y++)H = b ? i(I[Y], $[Y], z) : I[Y], T ? (m.copy(p.normals[tt]).multiplyScalar(H.x), f.copy(p.binormals[tt]).multiplyScalar(H.y), g.copy(d[tt]).add(m).add(f), l(g.x, g.y, g.z)) : l(H.x, H.y, v / M * tt);
            for (B = x - 1; B >= 0; B--) {
                for (G = B / x, k = y * Math.cos(G * Math.PI / 2), z = _ * Math.sin(G * Math.PI / 2), Y = 0, q = F.length; Y < q; Y++)H = i(F[Y], X[Y], z), l(H.x, H.y, v + k);
                for (L = 0, R = U.length; L < R; L++)for (A = U[L], Q = K[L], Y = 0, q = A.length; Y < q; Y++)H = i(A[Y], Q[Y], z), T ? l(H.x, H.y + d[M - 1].y, d[M - 1].x + k) : l(H.x, H.y, v + k)
            }
            a(), o()
        }, We.WorldUVGenerator = {
            generateTopUV: function (t, e, i, r) {
                var a = t.vertices, o = a[e], s = a[i], c = a[r];
                return [new n(o.x, o.y), new n(s.x, s.y), new n(c.x, c.y)]
            }, generateSideWallUV: function (t, e, i, r, a) {
                var o = t.vertices, s = o[e], c = o[i], l = o[r], u = o[a];
                return Math.abs(s.y - c.y) < .01 ? [new n(s.x, 1 - s.z), new n(c.x, 1 - c.z), new n(l.x, 1 - l.z), new n(u.x, 1 - u.z)] : [new n(s.y, 1 - s.z), new n(c.y, 1 - c.z), new n(l.y, 1 - l.z), new n(u.y, 1 - u.z)]
            }
        }, Xe.prototype = Object.create(We.prototype), Xe.prototype.constructor = Xe, Ye.prototype = Object.create(St.prototype), Ye.prototype.constructor = Ye, qe.prototype = Object.create(Et.prototype), qe.prototype.constructor = qe, Ze.prototype = Object.create(St.prototype), Ze.prototype.constructor = Ze, Je.prototype = Object.create(Et.prototype), Je.prototype.constructor = Je, Qe.prototype = Object.create(Et.prototype), Qe.prototype.constructor = Qe, Ke.prototype = Object.create(St.prototype), Ke.prototype.constructor = Ke, $e.prototype = Object.create(Et.prototype), $e.prototype.constructor = $e, tn.prototype = Object.create(St.prototype), tn.prototype.constructor = tn, en.prototype = Object.create(Et.prototype), en.prototype.constructor = en, nn.prototype = Object.create(St.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(St.prototype), rn.prototype.constructor = rn, an.prototype = Object.create(Et.prototype), an.prototype.constructor = an, on.prototype = Object.create(an.prototype), on.prototype.constructor = on, sn.prototype = Object.create(rn.prototype), sn.prototype.constructor = sn, cn.prototype = Object.create(St.prototype), cn.prototype.constructor = cn, ln.prototype = Object.create(Et.prototype), ln.prototype.constructor = ln, un.prototype = Object.create(Et.prototype), un.prototype.constructor = un;
        var dl = Object.freeze({
            WireframeGeometry: Se,
            ParametricGeometry: Le,
            ParametricBufferGeometry: Ae,
            TetrahedronGeometry: Pe,
            TetrahedronBufferGeometry: Ce,
            OctahedronGeometry: Ie,
            OctahedronBufferGeometry: Oe,
            IcosahedronGeometry: Ne,
            IcosahedronBufferGeometry: Ue,
            DodecahedronGeometry: Fe,
            DodecahedronBufferGeometry: De,
            PolyhedronGeometry: Be,
            PolyhedronBufferGeometry: Re,
            TubeGeometry: Ge,
            TubeBufferGeometry: ze,
            TorusKnotGeometry: He,
            TorusKnotBufferGeometry: ke,
            TorusGeometry: je,
            TorusBufferGeometry: Ve,
            TextGeometry: Xe,
            SphereBufferGeometry: Ye,
            SphereGeometry: qe,
            RingGeometry: Je,
            RingBufferGeometry: Ze,
            PlaneBufferGeometry: Rt,
            PlaneGeometry: Qe,
            LatheGeometry: $e,
            LatheBufferGeometry: Ke,
            ShapeGeometry: en,
            ShapeBufferGeometry: tn,
            ExtrudeGeometry: We,
            EdgesGeometry: nn,
            ConeGeometry: on,
            ConeBufferGeometry: sn,
            CylinderGeometry: an,
            CylinderBufferGeometry: rn,
            CircleBufferGeometry: cn,
            CircleGeometry: ln,
            BoxBufferGeometry: Lt,
            BoxGeometry: un
        });
        hn.prototype = Object.create(Q.prototype), hn.prototype.constructor = hn, hn.prototype.isShadowMaterial = !0, dn.prototype = Object.create(Q.prototype), dn.prototype.constructor = dn, dn.prototype.isRawShaderMaterial = !0, pn.prototype = {
            constructor: pn,
            isMultiMaterial: !0,
            toJSON: function (t) {
                for (var e = {
                    metadata: {version: 4.2, type: "material", generator: "MaterialExporter"},
                    uuid: this.uuid,
                    type: this.type,
                    materials: []
                }, n = this.materials, i = 0, r = n.length; i < r; i++) {
                    var a = n[i].toJSON(t);
                    delete a.metadata, e.materials.push(a)
                }
                return e.visible = this.visible, e
            },
            clone: function () {
                for (var t = new this.constructor, e = 0; e < this.materials.length; e++)t.materials.push(this.materials[e].clone());
                return t.visible = this.visible, t
            }
        }, fn.prototype = Object.create(J.prototype), fn.prototype.constructor = fn, fn.prototype.isMeshStandardMaterial = !0, fn.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, mn.prototype = Object.create(fn.prototype), mn.prototype.constructor = mn, mn.prototype.isMeshPhysicalMaterial = !0, mn.prototype.copy = function (t) {
            return fn.prototype.copy.call(this, t), this.defines = {PHYSICAL: ""}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
        }, gn.prototype = Object.create(J.prototype), gn.prototype.constructor = gn, gn.prototype.isMeshPhongMaterial = !0, gn.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, vn.prototype = Object.create(gn.prototype), vn.prototype.constructor = vn, vn.prototype.isMeshToonMaterial = !0, vn.prototype.copy = function (t) {
            return gn.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
        }, yn.prototype = Object.create(J.prototype), yn.prototype.constructor = yn, yn.prototype.isMeshNormalMaterial = !0, yn.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, _n.prototype = Object.create(J.prototype), _n.prototype.constructor = _n, _n.prototype.isMeshLambertMaterial = !0, _n.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
        }, xn.prototype = Object.create(J.prototype), xn.prototype.constructor = xn, xn.prototype.isLineDashedMaterial = !0, xn.prototype.copy = function (t) {
            return J.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
        };
        var pl = Object.freeze({
            ShadowMaterial: hn,
            SpriteMaterial: ue,
            RawShaderMaterial: dn,
            ShaderMaterial: Q,
            PointsMaterial: _e,
            MultiMaterial: pn,
            MeshPhysicalMaterial: mn,
            MeshStandardMaterial: fn,
            MeshPhongMaterial: gn,
            MeshToonMaterial: vn,
            MeshNormalMaterial: yn,
            MeshLambertMaterial: _n,
            MeshDepthMaterial: K,
            MeshBasicMaterial: dt,
            LineDashedMaterial: xn,
            LineBasicMaterial: ge,
            Material: J
        }), fl = {
            enabled: !1, files: {}, add: function (t, e) {
                this.enabled !== !1 && (this.files[t] = e)
            }, get: function (t) {
                if (this.enabled !== !1)return this.files[t]
            }, remove: function (t) {
                delete this.files[t]
            }, clear: function () {
                this.files = {}
            }
        }, ml = new bn;
        Object.assign(wn.prototype, {
            load: function (t, e, n, i) {
                void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t);
                var r = this, a = fl.get(t);
                if (void 0 !== a)return r.manager.itemStart(t), setTimeout(function () {
                    e && e(a), r.manager.itemEnd(t)
                }, 0), a;
                var o = /^data:(.*?)(;base64)?,(.*)$/, s = t.match(o);
                if (s) {
                    var c = s[1], l = !!s[2], u = s[3];
                    u = window.decodeURIComponent(u), l && (u = window.atob(u));
                    try {
                        var h, d = (this.responseType || "").toLowerCase();
                        switch (d) {
                            case"arraybuffer":
                            case"blob":
                                h = new ArrayBuffer(u.length);
                                for (var p = new Uint8Array(h), f = 0; f < u.length; f++)p[f] = u.charCodeAt(f);
                                "blob" === d && (h = new Blob([h], {type: c}));
                                break;
                            case"document":
                                var m = new DOMParser;
                                h = m.parseFromString(u, c);
                                break;
                            case"json":
                                h = JSON.parse(u);
                                break;
                            default:
                                h = u
                        }
                        window.setTimeout(function () {
                            e && e(h), r.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function () {
                            i && i(e), r.manager.itemError(t)
                        }, 0)
                    }
                } else {
                    var g = new XMLHttpRequest;
                    g.open("GET", t, !0), g.addEventListener("load", function (n) {
                        var a = n.target.response;
                        fl.add(t, a), 200 === this.status ? (e && e(a), r.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), e && e(a), r.manager.itemEnd(t)) : (i && i(n), r.manager.itemError(t))
                    }, !1), void 0 !== n && g.addEventListener("progress", function (t) {
                        n(t)
                    }, !1), g.addEventListener("error", function (e) {
                        i && i(e), r.manager.itemError(t)
                    }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.overrideMimeType && g.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), g.send(null)
                }
                return r.manager.itemStart(t), g
            }, setPath: function (t) {
                return this.path = t, this
            }, setResponseType: function (t) {
                return this.responseType = t, this
            }, setWithCredentials: function (t) {
                return this.withCredentials = t, this
            }, setMimeType: function (t) {
                return this.mimeType = t, this
            }
        }), Object.assign(Mn.prototype, {
            load: function (t, e, n, i) {
                function r(r) {
                    c.load(t[r], function (t) {
                        var n = a._parser(t, !0);
                        o[r] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        }, l += 1, 6 === l && (1 === n.mipmapCount && (s.minFilter = Za), s.format = n.format, s.needsUpdate = !0, e && e(s))
                    }, n, i)
                }

                var a = this, o = [], s = new Me;
                s.image = o;
                var c = new wn(this.manager);
                if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(t))for (var l = 0, u = 0, h = t.length; u < h; ++u)r(u); else c.load(t, function (t) {
                    var n = a._parser(t, !0);
                    if (n.isCubemap)for (var i = n.mipmaps.length / n.mipmapCount, r = 0; r < i; r++) {
                        o[r] = {mipmaps: []};
                        for (var c = 0; c < n.mipmapCount; c++)o[r].mipmaps.push(n.mipmaps[r * n.mipmapCount + c]), o[r].format = n.format, o[r].width = n.width, o[r].height = n.height
                    } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (s.minFilter = Za), s.format = n.format, s.needsUpdate = !0, e && e(s)
                }, n, i);
                return s
            }, setPath: function (t) {
                return this.path = t, this
            }
        });
        var gl = En;
        Object.assign(En.prototype, {
            load: function (t, e, n, i) {
                var r = this, a = new X, o = new wn(this.manager);
                return o.setResponseType("arraybuffer"), o.load(t, function (t) {
                    var n = r._parser(t);
                    n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : Va, a.wrapT = void 0 !== n.wrapT ? n.wrapT : Va, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Za, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Qa, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps), 1 === n.mipmapCount && (a.minFilter = Za), a.needsUpdate = !0, e && e(a, n))
                }, n, i), a
            }
        }), Object.assign(Tn.prototype, {
            load: function (t, e, n, i) {
                var r = this, a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                if (a.onload = function () {
                        a.onload = null, URL.revokeObjectURL(a.src), e && e(a), r.manager.itemEnd(t)
                    }, a.onerror = i, 0 === t.indexOf("data:"))a.src = t; else if (void 0 !== this.crossOrigin)a.crossOrigin = this.crossOrigin, a.src = t; else {
                    var o = new wn;
                    o.setPath(this.path), o.setResponseType("blob"), o.setWithCredentials(this.withCredentials), o.load(t, function (t) {
                        a.src = URL.createObjectURL(t)
                    }, n, i)
                }
                return r.manager.itemStart(t), a
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, setWithCredentials: function (t) {
                return this.withCredentials = t, this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(Sn.prototype, {
            load: function (t, e, n, i) {
                function r(n) {
                    o.load(t[n], function (t) {
                        a.images[n] = t, s++, 6 === s && (a.needsUpdate = !0, e && e(a))
                    }, void 0, i)
                }

                var a = new u, o = new Tn(this.manager);
                o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                for (var s = 0, c = 0; c < t.length; ++c)r(c);
                return a
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Object.assign(An.prototype, {
            load: function (t, e, n, r) {
                var a = new i, o = new Tn(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setWithCredentials(this.withCredentials), o.setPath(this.path), o.load(t, function (n) {
                    var i = t.search(/\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                    a.format = i ? po : fo, a.image = n, a.needsUpdate = !0, void 0 !== e && e(a)
                }, n, r), a
            }, setCrossOrigin: function (t) {
                return this.crossOrigin = t, this
            }, setWithCredentials: function (t) {
                return this.withCredentials = t, this
            }, setPath: function (t) {
                return this.path = t, this
            }
        }), Ln.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: Ln,
            isLight: !0,
            copy: function (t) {
                return ct.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
            },
            toJSON: function (t) {
                var e = ct.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
            }
        }), Rn.prototype = Object.assign(Object.create(Ln.prototype), {
            constructor: Rn,
            isHemisphereLight: !0,
            copy: function (t) {
                return Ln.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
            }
        }), Object.assign(Cn.prototype, {
            copy: function (t) {
                return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, toJSON: function () {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
            }
        }), Pn.prototype = Object.assign(Object.create(Cn.prototype), {
            constructor: Pn,
            isSpotLightShadow: !0,
            update: function (t) {
                var e = 2 * Qo.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height, i = t.distance || 500, r = this.camera;
                e === r.fov && n === r.aspect && i === r.far || (r.fov = e, r.aspect = n, r.far = i, r.updateProjectionMatrix())
            }
        }), On.prototype = Object.assign(Object.create(Ln.prototype), {
            constructor: On,
            isSpotLight: !0,
            copy: function (t) {
                return Ln.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), In.prototype = Object.assign(Object.create(Ln.prototype), {
            constructor: In,
            isPointLight: !0,
            copy: function (t) {
                return Ln.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
            }
        }), Un.prototype = Object.assign(Object.create(Cn.prototype), {constructor: Un}), Nn.prototype = Object.assign(Object.create(Ln.prototype), {
            constructor: Nn,
            isDirectionalLight: !0,
            copy: function (t) {
                return Ln.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
            }
        }), Dn.prototype = Object.assign(Object.create(Ln.prototype), {constructor: Dn, isAmbientLight: !0});
        var vl = {
            arraySlice: function (t, e, n) {
                return vl.isTypedArray(t) ? new t.constructor(t.subarray(e, n)) : t.slice(e, n)
            }, convertArray: function (t, e, n) {
                return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            }, isTypedArray: function (t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            }, getKeyframeOrder: function (t) {
                function e(e, n) {
                    return t[e] - t[n]
                }

                for (var n = t.length, i = new Array(n), r = 0; r !== n; ++r)i[r] = r;
                return i.sort(e), i
            }, sortedArray: function (t, e, n) {
                for (var i = t.length, r = new t.constructor(i), a = 0, o = 0; o !== i; ++a)for (var s = n[a] * e, c = 0; c !== e; ++c)r[o++] = t[s + c];
                return r
            }, flattenJSON: function (t, e, n, i) {
                for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[i];)a = t[r++];
                if (void 0 !== a) {
                    var o = a[i];
                    if (void 0 !== o)if (Array.isArray(o)) {
                        do o = a[i], void 0 !== o && (e.push(a.time), n.push.apply(n, o)), a = t[r++]; while (void 0 !== a)
                    } else if (void 0 !== o.toArray) {
                        do o = a[i], void 0 !== o && (e.push(a.time), o.toArray(n, n.length)), a = t[r++]; while (void 0 !== a)
                    } else do o = a[i], void 0 !== o && (e.push(a.time), n.push(o)), a = t[r++]; while (void 0 !== a)
                }
            }
        };
        Fn.prototype = {
            constructor: Fn, evaluate: function (t) {
                var e = this.parameterPositions, n = this._cachedIndex, i = e[n], r = e[n - 1];
                t:{
                    e:{
                        var a;
                        n:{
                            i:if (!(t < i)) {
                                for (var o = n + 2; ;) {
                                    if (void 0 === i) {
                                        if (t < r)break i;
                                        return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                    }
                                    if (n === o)break;
                                    if (r = i, i = e[++n], t < i)break e
                                }
                                a = e.length;
                                break n
                            }
                            {
                                if (t >= r)break t;
                                var s = e[1];
                                t < s && (n = 2, r = s);
                                for (var o = n - 2; ;) {
                                    if (void 0 === r)return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                    if (n === o)break;
                                    if (i = r, r = e[--n - 1], t >= r)break e
                                }
                                a = n, n = 0
                            }
                        }
                        for (; n < a;) {
                            var c = n + a >>> 1;
                            t < e[c] ? a = c : n = c + 1
                        }
                        if (i = e[n], r = e[n - 1], void 0 === r)return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                        if (void 0 === i)return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                    }
                    this._cachedIndex = n, this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, t, i)
            }, settings: null, DefaultSettings_: {}, getSettings_: function () {
                return this.settings || this.DefaultSettings_
            }, copySampleValue_: function (t) {
                for (var e = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = t * i, a = 0; a !== i; ++a)e[a] = n[r + a];
                return e
            }, interpolate_: function (t, e, n, i) {
                throw new Error("call to abstract method")
            }, intervalChanged_: function (t, e, n) {
            }
        }, Object.assign(Fn.prototype, {
            beforeStart_: Fn.prototype.copySampleValue_,
            afterEnd_: Fn.prototype.copySampleValue_
        }), Bn.prototype = Object.assign(Object.create(Fn.prototype), {
            constructor: Bn,
            DefaultSettings_: {endingStart: No, endingEnd: No},
            intervalChanged_: function (t, e, n) {
                var i = this.parameterPositions, r = t - 2, a = t + 1, o = i[r], s = i[a];
                if (void 0 === o)switch (this.getSettings_().endingStart) {
                    case Do:
                        r = t, o = 2 * e - n;
                        break;
                    case Fo:
                        r = i.length - 2, o = e + i[r] - i[r + 1];
                        break;
                    default:
                        r = t, o = n
                }
                if (void 0 === s)switch (this.getSettings_().endingEnd) {
                    case Do:
                        a = t, s = 2 * n - e;
                        break;
                    case Fo:
                        a = 1, s = n + i[1] - i[0];
                        break;
                    default:
                        a = t - 1, s = e
                }
                var c = .5 * (n - e), l = this.valueSize;
                this._weightPrev = c / (e - o), this._weightNext = c / (s - n), this._offsetPrev = r * l, this._offsetNext = a * l
            },
            interpolate_: function (t, e, n, i) {
                for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, l = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - e) / (i - e), f = p * p, m = f * p, g = -h * m + 2 * h * f - h * p, v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== o; ++x)r[x] = g * a[l + x] + v * a[c + x] + y * a[s + x] + _ * a[u + x];
                return r
            }
        }), zn.prototype = Object.assign(Object.create(Fn.prototype), {
            constructor: zn,
            interpolate_: function (t, e, n, i) {
                for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = t * o, c = s - o, l = (n - e) / (i - e), u = 1 - l, h = 0; h !== o; ++h)r[h] = a[c + h] * u + a[s + h] * l;
                return r
            }
        }), Gn.prototype = Object.assign(Object.create(Fn.prototype), {
            constructor: Gn,
            interpolate_: function (t, e, n, i) {
                return this.copySampleValue_(t - 1)
            }
        });
        var yl;
        yl = {
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: Io,
            InterpolantFactoryMethodDiscrete: function (t) {
                return new Gn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodLinear: function (t) {
                return new zn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: function (t) {
                return new Bn(this.times, this.values, this.getValueSize(), t)
            },
            setInterpolation: function (t) {
                var e;
                switch (t) {
                    case Oo:
                        e = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Io:
                        e = this.InterpolantFactoryMethodLinear;
                        break;
                    case Uo:
                        e = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === e) {
                    var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (t === this.DefaultInterpolation)throw new Error(n);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return void console.warn(n)
                }
                this.createInterpolant = e
            },
            getInterpolation: function () {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Oo;
                    case this.InterpolantFactoryMethodLinear:
                        return Io;
                    case this.InterpolantFactoryMethodSmooth:
                        return Uo
                }
            },
            getValueSize: function () {
                return this.values.length / this.times.length
            },
            shift: function (t) {
                if (0 !== t)for (var e = this.times, n = 0, i = e.length; n !== i; ++n)e[n] += t;
                return this
            },
            scale: function (t) {
                if (1 !== t)for (var e = this.times, n = 0, i = e.length; n !== i; ++n)e[n] *= t;
                return this
            },
            trim: function (t, e) {
                for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < t;)++r;
                for (; a !== -1 && n[a] > e;)--a;
                if (++a, 0 !== r || a !== i) {
                    r >= a && (a = Math.max(a, 1), r = a - 1);
                    var o = this.getValueSize();
                    this.times = vl.arraySlice(n, r, a), this.values = vl.arraySlice(this.values, r * o, a * o)
                }
                return this
            },
            validate: function () {
                var t = !0, e = this.getValueSize();
                e - Math.floor(e) !== 0 && (console.error("invalid value size in track", this), t = !1);
                var n = this.times, i = this.values, r = n.length;
                0 === r && (console.error("track is empty", this), t = !1);
                for (var a = null, o = 0; o !== r; o++) {
                    var s = n[o];
                    if ("number" == typeof s && isNaN(s)) {
                        console.error("time is not a valid number", this, o, s), t = !1;
                        break
                    }
                    if (null !== a && a > s) {
                        console.error("out of order keys", this, o, s, a), t = !1;
                        break
                    }
                    a = s
                }
                if (void 0 !== i && vl.isTypedArray(i))for (var o = 0, c = i.length; o !== c; ++o) {
                    var l = i[o];
                    if (isNaN(l)) {
                        console.error("value is not a valid number", this, o, l), t = !1;
                        break
                    }
                }
                return t
            },
            optimize: function () {
                for (var t = this.times, e = this.values, n = this.getValueSize(), i = this.getInterpolation() === Uo, r = 1, a = t.length - 1, o = 1; o < a; ++o) {
                    var s = !1, c = t[o], l = t[o + 1];
                    if (c !== l && (1 !== o || c !== c[0]))if (i)s = !0; else for (var u = o * n, h = u - n, d = u + n, p = 0; p !== n; ++p) {
                        var f = e[u + p];
                        if (f !== e[h + p] || f !== e[d + p]) {
                            s = !0;
                            break
                        }
                    }
                    if (s) {
                        if (o !== r) {
                            t[r] = t[o];
                            for (var m = o * n, g = r * n, p = 0; p !== n; ++p)e[g + p] = e[m + p]
                        }
                        ++r
                    }
                }
                if (a > 0) {
                    t[r] = t[a];
                    for (var m = a * n, g = r * n, p = 0; p !== n; ++p)e[g + p] = e[m + p];
                    ++r
                }
                return r !== t.length && (this.times = vl.arraySlice(t, 0, r), this.values = vl.arraySlice(e, 0, r * n)), this
            }
        }, Hn.prototype = Object.assign(Object.create(yl), {
            constructor: Hn,
            ValueTypeName: "vector"
        }), Vn.prototype = Object.assign(Object.create(Fn.prototype), {
            constructor: Vn,
            interpolate_: function (t, e, n, i) {
                for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = t * o, l = (n - e) / (i - e), u = c + o; c !== u; c += 4)s.slerpFlat(r, 0, a, c - o, a, c, l);
                return r
            }
        }), jn.prototype = Object.assign(Object.create(yl), {
            constructor: jn,
            ValueTypeName: "quaternion",
            DefaultInterpolation: Io,
            InterpolantFactoryMethodLinear: function (t) {
                return new Vn(this.times, this.values, this.getValueSize(), t)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), Wn.prototype = Object.assign(Object.create(yl), {
            constructor: Wn,
            ValueTypeName: "number"
        }), Xn.prototype = Object.assign(Object.create(yl), {
            constructor: Xn,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: Oo,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Yn.prototype = Object.assign(Object.create(yl), {
            constructor: Yn,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: Oo,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), qn.prototype = Object.assign(Object.create(yl), {
            constructor: qn,
            ValueTypeName: "color"
        }), Zn.prototype = yl, yl.constructor = Zn, Object.assign(Zn, {
            parse: function (t) {
                if (void 0 === t.type)throw new Error("track type undefined, can not parse");
                var e = Zn._getTrackTypeForValueTypeName(t.type);
                if (void 0 === t.times) {
                    var n = [], i = [];
                    vl.flattenJSON(t.keys, n, i, "value"), t.times = n, t.values = i
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }, toJSON: function (t) {
                var e, n = t.constructor;
                if (void 0 !== n.toJSON)e = n.toJSON(t); else {
                    e = {
                        name: t.name,
                        times: vl.convertArray(t.times, Array),
                        values: vl.convertArray(t.values, Array)
                    };
                    var i = t.getInterpolation();
                    i !== t.DefaultInterpolation && (e.interpolation = i)
                }
                return e.type = t.ValueTypeName, e
            }, _getTrackTypeForValueTypeName: function (t) {
                switch (t.toLowerCase()) {
                    case"scalar":
                    case"double":
                    case"float":
                    case"number":
                    case"integer":
                        return Wn;
                    case"vector":
                    case"vector2":
                    case"vector3":
                    case"vector4":
                        return Hn;
                    case"color":
                        return qn;
                    case"quaternion":
                        return jn;
                    case"bool":
                    case"boolean":
                        return Yn;
                    case"string":
                        return Xn
                }
                throw new Error("Unsupported typeName: " + t)
            }
        }), Jn.prototype = {
            constructor: Jn, resetDuration: function () {
                for (var t = this.tracks, e = 0, n = 0, i = t.length; n !== i; ++n) {
                    var r = this.tracks[n];
                    e = Math.max(e, r.times[r.times.length - 1])
                }
                this.duration = e
            }, trim: function () {
                for (var t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration);
                return this
            }, optimize: function () {
                for (var t = 0; t < this.tracks.length; t++)this.tracks[t].optimize();
                return this
            }
        }, Object.assign(Jn, {
            parse: function (t) {
                for (var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, a = n.length; r !== a; ++r)e.push(Zn.parse(n[r]).scale(i));
                return new Jn(t.name, t.duration, e)
            }, toJSON: function (t) {
                for (var e = [], n = t.tracks, i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                }, r = 0, a = n.length; r !== a; ++r)e.push(Zn.toJSON(n[r]));
                return i
            }, CreateFromMorphTargetSequence: function (t, e, n, i) {
                for (var r = e.length, a = [], o = 0; o < r; o++) {
                    var s = [], c = [];
                    s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
                    var l = vl.getKeyframeOrder(s);
                    s = vl.sortedArray(s, 1, l), c = vl.sortedArray(c, 1, l), i || 0 !== s[0] || (s.push(r), c.push(c[0])), a.push(new Wn(".morphTargetInfluences[" + e[o].name + "]", s, c).scale(1 / n))
                }
                return new Jn(t, -1, a)
            }, findByName: function (t, e) {
                var n = t;
                if (!Array.isArray(t)) {
                    var i = t;
                    n = i.geometry && i.geometry.animations || i.animations
                }
                for (var r = 0; r < n.length; r++)if (n[r].name === e)return n[r];
                return null
            }, CreateClipsFromMorphTargetSequences: function (t, e, n) {
                for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                    var s = t[a], c = s.name.match(r);
                    if (c && c.length > 1) {
                        var l = c[1], u = i[l];
                        u || (i[l] = u = []), u.push(s)
                    }
                }
                var h = [];
                for (var l in i)h.push(Jn.CreateFromMorphTargetSequence(l, i[l], e, n));
                return h
            }, parseAnimation: function (t, e) {
                if (!t)return console.error("  no animation in JSONLoader data"), null;
                for (var n = function (t, e, n, i, r) {
                    if (0 !== n.length) {
                        var a = [], o = [];
                        vl.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new t(e, a, o))
                    }
                }, i = [], r = t.name || "default", a = t.length || -1, o = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                    var l = s[c].keys;
                    if (l && 0 !== l.length)if (l[0].morphTargets) {
                        for (var u = {}, h = 0; h < l.length; h++)if (l[h].morphTargets)for (var d = 0; d < l[h].morphTargets.length; d++)u[l[h].morphTargets[d]] = -1;
                        for (var p in u) {
                            for (var f = [], m = [], d = 0; d !== l[h].morphTargets.length; ++d) {
                                var g = l[h];
                                f.push(g.time), m.push(g.morphTarget === p ? 1 : 0)
                            }
                            i.push(new Wn(".morphTargetInfluence[" + p + "]", f, m))
                        }
                        a = u.length * (o || 1)
                    } else {
                        var v = ".bones[" + e[c].name + "]";
                        n(Hn, v + ".position", l, "pos", i), n(jn, v + ".quaternion", l, "rot", i), n(Hn, v + ".scale", l, "scl", i)
                    }
                }
                if (0 === i.length)return null;
                var y = new Jn(r, a, i);
                return y
            }
        }), Object.assign(Qn.prototype, {
            load: function (t, e, n, i) {
                var r = this, a = new wn(r.manager);
                a.load(t, function (t) {
                    e(r.parse(JSON.parse(t)))
                }, n, i)
            }, setTextures: function (t) {
                this.textures = t
            }, parse: function (t) {
                function e(t) {
                    return void 0 === i[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), i[t]
                }

                var i = this.textures, r = new pl[t.type];
                if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.uniforms && (r.uniforms = t.uniforms), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.shading && (r.shading = t.shading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = e(t.map)), void 0 !== t.alphaMap && (r.alphaMap = e(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = e(t.normalMap)), void 0 !== t.normalScale) {
                    var a = t.normalScale;
                    Array.isArray(a) === !1 && (a = [a, a]), r.normalScale = (new n).fromArray(a)
                }
                if (void 0 !== t.displacementMap && (r.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = e(t.specularMap)), void 0 !== t.envMap && (r.envMap = e(t.envMap)), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.lightMap && (r.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = e(t.gradientMap)), void 0 !== t.materials)for (var o = 0, s = t.materials.length; o < s; o++)r.materials.push(this.parse(t.materials[o]));
                return r
            }
        }), Object.assign(Kn.prototype, {
            load: function (t, e, n, i) {
                var r = this, a = new wn(r.manager);
                a.load(t, function (t) {
                    e(r.parse(JSON.parse(t)))
                }, n, i)
            }, parse: function (t) {
                var e = new St, n = t.data.index, i = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };
                if (void 0 !== n) {
                    var r = new i[n.type](n.array);
                    e.setIndex(new pt(r, 1))
                }
                var a = t.data.attributes;
                for (var o in a) {
                    var s = a[o], r = new i[s.type](s.array);
                    e.addAttribute(o, new pt(r, s.itemSize, s.normalized))
                }
                var l = t.data.groups || t.data.drawcalls || t.data.offsets;
                if (void 0 !== l)for (var u = 0, h = l.length; u !== h; ++u) {
                    var d = l[u];
                    e.addGroup(d.start, d.count, d.materialIndex)
                }
                var p = t.data.boundingSphere;
                if (void 0 !== p) {
                    var f = new c;
                    void 0 !== p.center && f.fromArray(p.center), e.boundingSphere = new tt(f, p.radius)
                }
                return e
            }
        }), $n.prototype = {
            constructor: $n, crossOrigin: void 0, extractUrlBase: function (t) {
                var e = t.split("/");
                return 1 === e.length ? "./" : (e.pop(), e.join("/") + "/")
            }, initMaterials: function (t, e, n) {
                for (var i = [], r = 0; r < t.length; ++r)i[r] = this.createMaterial(t[r], e, n);
                return i
            }, createMaterial: function () {
                var t, e, n;
                return function (i, r, a) {
                    function o(t, n, i, o, c) {
                        var l, u = r + t, h = $n.Handlers.get(u);
                        null !== h ? l = h.load(u) : (e.setCrossOrigin(a), l = e.load(u)), void 0 !== n && (l.repeat.fromArray(n), 1 !== n[0] && (l.wrapS = Ha), 1 !== n[1] && (l.wrapT = Ha)), void 0 !== i && l.offset.fromArray(i), void 0 !== o && ("repeat" === o[0] && (l.wrapS = Ha), "mirror" === o[0] && (l.wrapS = ja), "repeat" === o[1] && (l.wrapT = Ha), "mirror" === o[1] && (l.wrapT = ja)), void 0 !== c && (l.anisotropy = c);
                        var d = Qo.generateUUID();
                        return s[d] = l, d
                    }

                    void 0 === t && (t = new W), void 0 === e && (e = new An), void 0 === n && (n = new Qn);
                    var s = {}, c = {uuid: Qo.generateUUID(), type: "MeshLambertMaterial"};
                    for (var l in i) {
                        var u = i[l];
                        switch (l) {
                            case"DbgColor":
                            case"DbgIndex":
                            case"opticalDensity":
                            case"illumination":
                                break;
                            case"DbgName":
                                c.name = u;
                                break;
                            case"blending":
                                c.blending = ta[u];
                                break;
                            case"colorAmbient":
                            case"mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                                break;
                            case"colorDiffuse":
                                c.color = t.fromArray(u).getHex();
                                break;
                            case"colorSpecular":
                                c.specular = t.fromArray(u).getHex();
                                break;
                            case"colorEmissive":
                                c.emissive = t.fromArray(u).getHex();
                                break;
                            case"specularCoef":
                                c.shininess = u;
                                break;
                            case"shading":
                                "basic" === u.toLowerCase() && (c.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (c.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (c.type = "MeshStandardMaterial");
                                break;
                            case"mapDiffuse":
                                c.map = o(u, i.mapDiffuseRepeat, i.mapDiffuseOffset, i.mapDiffuseWrap, i.mapDiffuseAnisotropy);
                                break;
                            case"mapDiffuseRepeat":
                            case"mapDiffuseOffset":
                            case"mapDiffuseWrap":
                            case"mapDiffuseAnisotropy":
                                break;
                            case"mapEmissive":
                                c.emissiveMap = o(u, i.mapEmissiveRepeat, i.mapEmissiveOffset, i.mapEmissiveWrap, i.mapEmissiveAnisotropy);
                                break;
                            case"mapEmissiveRepeat":
                            case"mapEmissiveOffset":
                            case"mapEmissiveWrap":
                            case"mapEmissiveAnisotropy":
                                break;
                            case"mapLight":
                                c.lightMap = o(u, i.mapLightRepeat, i.mapLightOffset, i.mapLightWrap, i.mapLightAnisotropy);
                                break;
                            case"mapLightRepeat":
                            case"mapLightOffset":
                            case"mapLightWrap":
                            case"mapLightAnisotropy":
                                break;
                            case"mapAO":
                                c.aoMap = o(u, i.mapAORepeat, i.mapAOOffset, i.mapAOWrap, i.mapAOAnisotropy);
                                break;
                            case"mapAORepeat":
                            case"mapAOOffset":
                            case"mapAOWrap":
                            case"mapAOAnisotropy":
                                break;
                            case"mapBump":
                                c.bumpMap = o(u, i.mapBumpRepeat, i.mapBumpOffset, i.mapBumpWrap, i.mapBumpAnisotropy);
                                break;
                            case"mapBumpScale":
                                c.bumpScale = u;
                                break;
                            case"mapBumpRepeat":
                            case"mapBumpOffset":
                            case"mapBumpWrap":
                            case"mapBumpAnisotropy":
                                break;
                            case"mapNormal":
                                c.normalMap = o(u, i.mapNormalRepeat, i.mapNormalOffset, i.mapNormalWrap, i.mapNormalAnisotropy);
                                break;
                            case"mapNormalFactor":
                                c.normalScale = [u, u];
                                break;
                            case"mapNormalRepeat":
                            case"mapNormalOffset":
                            case"mapNormalWrap":
                            case"mapNormalAnisotropy":
                                break;
                            case"mapSpecular":
                                c.specularMap = o(u, i.mapSpecularRepeat, i.mapSpecularOffset, i.mapSpecularWrap, i.mapSpecularAnisotropy);
                                break;
                            case"mapSpecularRepeat":
                            case"mapSpecularOffset":
                            case"mapSpecularWrap":
                            case"mapSpecularAnisotropy":
                                break;
                            case"mapMetalness":
                                c.metalnessMap = o(u, i.mapMetalnessRepeat, i.mapMetalnessOffset, i.mapMetalnessWrap, i.mapMetalnessAnisotropy);
                                break;
                            case"mapMetalnessRepeat":
                            case"mapMetalnessOffset":
                            case"mapMetalnessWrap":
                            case"mapMetalnessAnisotropy":
                                break;
                            case"mapRoughness":
                                c.roughnessMap = o(u, i.mapRoughnessRepeat, i.mapRoughnessOffset, i.mapRoughnessWrap, i.mapRoughnessAnisotropy);
                                break;
                            case"mapRoughnessRepeat":
                            case"mapRoughnessOffset":
                            case"mapRoughnessWrap":
                            case"mapRoughnessAnisotropy":
                                break;
                            case"mapAlpha":
                                c.alphaMap = o(u, i.mapAlphaRepeat, i.mapAlphaOffset, i.mapAlphaWrap, i.mapAlphaAnisotropy);
                                break;
                            case"mapAlphaRepeat":
                            case"mapAlphaOffset":
                            case"mapAlphaWrap":
                            case"mapAlphaAnisotropy":
                                break;
                            case"flipSided":
                                c.side = kr;
                                break;
                            case"doubleSided":
                                c.side = Hr;
                                break;
                            case"transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = u;
                                break;
                            case"depthTest":
                            case"depthWrite":
                            case"colorWrite":
                            case"opacity":
                            case"reflectivity":
                            case"transparent":
                            case"visible":
                            case"wireframe":
                                c[l] = u;
                                break;
                            case"vertexColors":
                                u === !0 && (c.vertexColors = Yr), "face" === u && (c.vertexColors = Xr);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", l, u)
                        }
                    }
                    return "MeshBasicMaterial" === c.type && delete c.emissive, "MeshPhongMaterial" !== c.type && delete c.specular, c.opacity < 1 && (c.transparent = !0), n.setTextures(s), n.parse(c)
                }
            }()
        }, $n.Handlers = {
            handlers: [], add: function (t, e) {
                this.handlers.push(t, e)
            }, get: function (t) {
                for (var e = this.handlers, n = 0, i = e.length; n < i; n += 2) {
                    var r = e[n], a = e[n + 1];
                    if (r.test(t))return a
                }
                return null
            }
        }, Object.assign(ti.prototype, {
            load: function (t, e, n, i) {
                var r = this, a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : $n.prototype.extractUrlBase(t), o = new wn(this.manager);
                o.setWithCredentials(this.withCredentials), o.load(t, function (n) {
                    var i = JSON.parse(n), o = i.metadata;
                    if (void 0 !== o) {
                        var s = o.type;
                        if (void 0 !== s) {
                            if ("object" === s.toLowerCase())return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                            if ("scene" === s.toLowerCase())return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                        }
                    }
                    var c = r.parse(i, a);
                    e(c.geometry, c.materials)
                }, n, i)
            }, setTexturePath: function (t) {
                this.texturePath = t
            }, parse: function (t, e) {
                function i(e) {
                    function i(t, e) {
                        return t & 1 << e
                    }

                    var r, a, o, s, u, h, d, p, f, m, g, v, y, _, x, b, w, M, E, T, S, A, L, R, C, P, O, I = t.faces, U = t.vertices, N = t.normals, D = t.colors, F = 0;
                    if (void 0 !== t.uvs) {
                        for (r = 0; r < t.uvs.length; r++)t.uvs[r].length && F++;
                        for (r = 0; r < F; r++)l.faceVertexUvs[r] = []
                    }
                    for (s = 0, u = U.length; s < u;)M = new c, M.x = U[s++] * e, M.y = U[s++] * e, M.z = U[s++] * e, l.vertices.push(M);
                    for (s = 0, u = I.length; s < u;)if (m = I[s++], g = i(m, 0), v = i(m, 1), y = i(m, 3), _ = i(m, 4), x = i(m, 5), b = i(m, 6), w = i(m, 7), g) {
                        if (T = new ht, T.a = I[s], T.b = I[s + 1], T.c = I[s + 3], S = new ht, S.a = I[s + 1], S.b = I[s + 2], S.c = I[s + 3], s += 4, v && (f = I[s++], T.materialIndex = f, S.materialIndex = f), o = l.faces.length, y)for (r = 0; r < F; r++)for (R = t.uvs[r], l.faceVertexUvs[r][o] = [], l.faceVertexUvs[r][o + 1] = [], a = 0; a < 4; a++)p = I[s++], P = R[2 * p], O = R[2 * p + 1], C = new n(P, O), 2 !== a && l.faceVertexUvs[r][o].push(C), 0 !== a && l.faceVertexUvs[r][o + 1].push(C);
                        if (_ && (d = 3 * I[s++], T.normal.set(N[d++], N[d++], N[d]), S.normal.copy(T.normal)), x)for (r = 0; r < 4; r++)d = 3 * I[s++], L = new c(N[d++], N[d++], N[d]), 2 !== r && T.vertexNormals.push(L), 0 !== r && S.vertexNormals.push(L);
                        if (b && (h = I[s++], A = D[h], T.color.setHex(A), S.color.setHex(A)), w)for (r = 0; r < 4; r++)h = I[s++], A = D[h], 2 !== r && T.vertexColors.push(new W(A)), 0 !== r && S.vertexColors.push(new W(A));
                        l.faces.push(T), l.faces.push(S)
                    } else {
                        if (E = new ht, E.a = I[s++], E.b = I[s++], E.c = I[s++], v && (f = I[s++], E.materialIndex = f), o = l.faces.length, y)for (r = 0; r < F; r++)for (R = t.uvs[r], l.faceVertexUvs[r][o] = [], a = 0; a < 3; a++)p = I[s++], P = R[2 * p], O = R[2 * p + 1], C = new n(P, O), l.faceVertexUvs[r][o].push(C);
                        if (_ && (d = 3 * I[s++], E.normal.set(N[d++], N[d++], N[d])), x)for (r = 0; r < 3; r++)d = 3 * I[s++], L = new c(N[d++], N[d++], N[d]), E.vertexNormals.push(L);
                        if (b && (h = I[s++], E.color.setHex(D[h])), w)for (r = 0; r < 3; r++)h = I[s++], E.vertexColors.push(new W(D[h]));
                        l.faces.push(E)
                    }
                }

                function a() {
                    var e = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
                    if (t.skinWeights)for (var n = 0, i = t.skinWeights.length; n < i; n += e) {
                        var a = t.skinWeights[n], o = e > 1 ? t.skinWeights[n + 1] : 0, s = e > 2 ? t.skinWeights[n + 2] : 0, c = e > 3 ? t.skinWeights[n + 3] : 0;
                        l.skinWeights.push(new r(a, o, s, c))
                    }
                    if (t.skinIndices)for (var n = 0, i = t.skinIndices.length; n < i; n += e) {
                        var u = t.skinIndices[n], h = e > 1 ? t.skinIndices[n + 1] : 0, d = e > 2 ? t.skinIndices[n + 2] : 0, p = e > 3 ? t.skinIndices[n + 3] : 0;
                        l.skinIndices.push(new r(u, h, d, p))
                    }
                    l.bones = t.bones, l.bones && l.bones.length > 0 && (l.skinWeights.length !== l.skinIndices.length || l.skinIndices.length !== l.vertices.length) && console.warn("When skinning, number of vertices (" + l.vertices.length + "), skinIndices (" + l.skinIndices.length + "), and skinWeights (" + l.skinWeights.length + ") should match.")
                }

                function o(e) {
                    if (void 0 !== t.morphTargets)for (var n = 0, i = t.morphTargets.length; n < i; n++) {
                        l.morphTargets[n] = {}, l.morphTargets[n].name = t.morphTargets[n].name, l.morphTargets[n].vertices = [];
                        for (var r = l.morphTargets[n].vertices, a = t.morphTargets[n].vertices, o = 0, s = a.length; o < s; o += 3) {
                            var u = new c;
                            u.x = a[o] * e, u.y = a[o + 1] * e, u.z = a[o + 2] * e, r.push(u)
                        }
                    }
                    if (void 0 !== t.morphColors && t.morphColors.length > 0) {
                        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                        for (var h = l.faces, d = t.morphColors[0].colors, n = 0, i = h.length; n < i; n++)h[n].color.fromArray(d, 3 * n)
                    }
                }

                function s() {
                    var e = [], n = [];
                    void 0 !== t.animation && n.push(t.animation), void 0 !== t.animations && (t.animations.length ? n = n.concat(t.animations) : n.push(t.animations));
                    for (var i = 0; i < n.length; i++) {
                        var r = Jn.parseAnimation(n[i], l.bones);
                        r && e.push(r)
                    }
                    if (l.morphTargets) {
                        var a = Jn.CreateClipsFromMorphTargetSequences(l.morphTargets, 10);
                        e = e.concat(a)
                    }
                    e.length > 0 && (l.animations = e)
                }

                var l = new Et, u = void 0 !== t.scale ? 1 / t.scale : 1;
                if (i(u), a(), o(u), s(), l.computeFaceNormals(), l.computeBoundingSphere(), void 0 === t.materials || 0 === t.materials.length)return {geometry: l};
                var h = $n.prototype.initMaterials(t.materials, e, this.crossOrigin);
                return {geometry: l, materials: h}
            }
        }), Object.assign(ei.prototype, {
            load: function (t, e, n, i) {
                "" === this.texturePath && (this.texturePath = t.substring(0, t.lastIndexOf("/") + 1));
                var r = this, a = new wn(r.manager);
                a.load(t, function (n) {
                    var i = null;
                    try {
                        i = JSON.parse(n)
                    } catch (e) {
                        return void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                    }
                    var a = i.metadata;
                    return void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase() ? void console.error("THREE.ObjectLoader: Can't load " + t + ". Use THREE.JSONLoader instead.") : void r.parse(i, e)
                }, n, i)
            }, setTexturePath: function (t) {
                this.texturePath = t
            }, setCrossOrigin: function (t) {
                this.crossOrigin = t
            }, parse: function (t, e) {
                var n = this.parseGeometries(t.geometries), i = this.parseImages(t.images, function () {
                    void 0 !== e && e(o)
                }), r = this.parseTextures(t.textures, i), a = this.parseMaterials(t.materials, r), o = this.parseObject(t.object, n, a);
                return t.animations && (o.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(o), o
            }, parseGeometries: function (t) {
                var e = {};
                if (void 0 !== t)for (var n = new ti, i = new Kn, r = 0, a = t.length; r < a; r++) {
                    var o, s = t[r];
                    switch (s.type) {
                        case"PlaneGeometry":
                        case"PlaneBufferGeometry":
                            o = new dl[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                            break;
                        case"BoxGeometry":
                        case"BoxBufferGeometry":
                        case"CubeGeometry":
                            o = new dl[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                            break;
                        case"CircleGeometry":
                        case"CircleBufferGeometry":
                            o = new dl[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                            break;
                        case"CylinderGeometry":
                        case"CylinderBufferGeometry":
                            o = new dl[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case"ConeGeometry":
                        case"ConeBufferGeometry":
                            o = new dl[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                            break;
                        case"SphereGeometry":
                        case"SphereBufferGeometry":
                            o = new dl[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                            break;
                        case"DodecahedronGeometry":
                        case"IcosahedronGeometry":
                        case"OctahedronGeometry":
                        case"TetrahedronGeometry":
                            o = new dl[s.type](s.radius, s.detail);
                            break;
                        case"RingGeometry":
                        case"RingBufferGeometry":
                            o = new dl[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                            break;
                        case"TorusGeometry":
                        case"TorusBufferGeometry":
                            o = new dl[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                            break;
                        case"TorusKnotGeometry":
                        case"TorusKnotBufferGeometry":
                            o = new dl[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                            break;
                        case"LatheGeometry":
                        case"LatheBufferGeometry":
                            o = new dl[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                            break;
                        case"BufferGeometry":
                            o = i.parse(s);
                            break;
                        case"Geometry":
                            o = n.parse(s.data, this.texturePath).geometry;
                            break;
                        default:
                            console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                            continue
                    }
                    o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), e[s.uuid] = o
                }
                return e
            }, parseMaterials: function (t, e) {
                var n = {};
                if (void 0 !== t) {
                    var i = new Qn;
                    i.setTextures(e);
                    for (var r = 0, a = t.length; r < a; r++) {
                        var o = i.parse(t[r]);
                        n[o.uuid] = o
                    }
                }
                return n
            }, parseAnimations: function (t) {
                for (var e = [], n = 0; n < t.length; n++) {
                    var i = Jn.parse(t[n]);
                    e.push(i)
                }
                return e
            }, parseImages: function (t, e) {
                function n(t) {
                    return i.manager.itemStart(t), o.load(t, function () {
                        i.manager.itemEnd(t)
                    }, void 0, function () {
                        i.manager.itemError(t)
                    })
                }

                var i = this, r = {};
                if (void 0 !== t && t.length > 0) {
                    var a = new bn(e), o = new Tn(a);
                    o.setCrossOrigin(this.crossOrigin);
                    for (var s = 0, c = t.length; s < c; s++) {
                        var l = t[s], u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.texturePath + l.url;
                        r[l.uuid] = n(u)
                    }
                }
                return r
            }, parseTextures: function (t, e) {
                function n(t, e) {
                    return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                }

                var r = {};
                if (void 0 !== t)for (var a = 0, o = t.length; a < o; a++) {
                    var s = t[a];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                    var c = new i(e[s.image]);
                    c.needsUpdate = !0, c.uuid = s.uuid, void 0 !== s.name && (c.name = s.name), void 0 !== s.mapping && (c.mapping = n(s.mapping, ka)), void 0 !== s.offset && c.offset.fromArray(s.offset), void 0 !== s.repeat && c.repeat.fromArray(s.repeat), void 0 !== s.wrap && (c.wrapS = n(s.wrap[0], Wa), c.wrapT = n(s.wrap[1], Wa)), void 0 !== s.minFilter && (c.minFilter = n(s.minFilter, Ka)), void 0 !== s.magFilter && (c.magFilter = n(s.magFilter, Ka)), void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy), void 0 !== s.flipY && (c.flipY = s.flipY), r[s.uuid] = c
                }
                return r
            }, parseObject: function () {
                var t = new l;
                return function (e, n, i) {
                    function r(t) {
                        return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), n[t]
                    }

                    function a(t) {
                        if (void 0 !== t)return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                    }

                    var o;
                    switch (e.type) {
                        case"Scene":
                            o = new ce, void 0 !== e.background && Number.isInteger(e.background) && (o.background = new W(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? o.fog = new se(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (o.fog = new oe(e.fog.color, e.fog.density)));
                            break;
                        case"PerspectiveCamera":
                            o = new Pt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (o.focus = e.focus), void 0 !== e.zoom && (o.zoom = e.zoom), void 0 !== e.filmGauge && (o.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (o.filmOffset = e.filmOffset), void 0 !== e.view && (o.view = Object.assign({}, e.view));
                            break;
                        case"OrthographicCamera":
                            o = new Ot(e.left, e.right, e.top, e.bottom, e.near, e.far);
                            break;
                        case"AmbientLight":
                            o = new Dn(e.color, e.intensity);
                            break;
                        case"DirectionalLight":
                            o = new Nn(e.color, e.intensity);
                            break;
                        case"PointLight":
                            o = new In(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case"SpotLight":
                            o = new On(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case"HemisphereLight":
                            o = new Rn(e.color, e.groundColor, e.intensity);
                            break;
                        case"Mesh":
                            var s = r(e.geometry), c = a(e.material);
                            o = s.bones && s.bones.length > 0 ? new me(s, c) : new At(s, c);
                            break;
                        case"LOD":
                            o = new de;
                            break;
                        case"Line":
                            o = new ve(r(e.geometry), a(e.material), e.mode);
                            break;
                        case"LineSegments":
                            o = new ye(r(e.geometry), a(e.material));
                            break;
                        case"PointCloud":
                        case"Points":
                            o = new xe(r(e.geometry), a(e.material));
                            break;
                        case"Sprite":
                            o = new he(a(e.material));
                            break;
                        case"Group":
                            o = new be;
                            break;
                        case"SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.");
                        default:
                            o = new ct
                    }
                    if (o.uuid = e.uuid, void 0 !== e.name && (o.name = e.name), void 0 !== e.matrix ? (t.fromArray(e.matrix), t.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== e.position && o.position.fromArray(e.position), void 0 !== e.rotation && o.rotation.fromArray(e.rotation), void 0 !== e.quaternion && o.quaternion.fromArray(e.quaternion), void 0 !== e.scale && o.scale.fromArray(e.scale)), void 0 !== e.castShadow && (o.castShadow = e.castShadow), void 0 !== e.receiveShadow && (o.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (o.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (o.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && o.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (o.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.children)for (var l in e.children)o.add(this.parseObject(e.children[l], n, i));
                    if ("LOD" === e.type)for (var u = e.levels, h = 0; h < u.length; h++) {
                        var d = u[h], l = o.getObjectByProperty("uuid", d.object);
                        void 0 !== l && o.addLevel(l, d.distance)
                    }
                    return o
                }
            }()
        }), ni.prototype = {
            constructor: ni, getPoint: function (t) {
                return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
            }, getPointAt: function (t) {
                var e = this.getUtoTmapping(t);
                return this.getPoint(e)
            }, getPoints: function (t) {
                t || (t = 5);
                for (var e = [], n = 0; n <= t; n++)e.push(this.getPoint(n / t));
                return e
            }, getSpacedPoints: function (t) {
                t || (t = 5);
                for (var e = [], n = 0; n <= t; n++)e.push(this.getPointAt(n / t));
                return e
            }, getLength: function () {
                var t = this.getLengths();
                return t[t.length - 1]
            }, getLengths: function (t) {
                if (t || (t = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate)return this.cacheArcLengths;
                this.needsUpdate = !1;
                var e, n, i = [], r = this.getPoint(0), a = 0;
                for (i.push(0), n = 1; n <= t; n++)e = this.getPoint(n / t), a += e.distanceTo(r), i.push(a), r = e;
                return this.cacheArcLengths = i, i
            }, updateArcLengths: function () {
                this.needsUpdate = !0, this.getLengths()
            }, getUtoTmapping: function (t, e) {
                var n, i = this.getLengths(), r = 0, a = i.length;
                n = e ? e : t * i[a - 1];
                for (var o, s = 0, c = a - 1; s <= c;)if (r = Math.floor(s + (c - s) / 2), o = i[r] - n, o < 0)s = r + 1; else {
                    if (!(o > 0)) {
                        c = r;
                        break
                    }
                    c = r - 1
                }
                if (r = c, i[r] === n) {
                    var l = r / (a - 1);
                    return l
                }
                var u = i[r], h = i[r + 1], d = h - u, p = (n - u) / d, l = (r + p) / (a - 1);
                return l
            }, getTangent: function (t) {
                var e = 1e-4, n = t - e, i = t + e;
                n < 0 && (n = 0), i > 1 && (i = 1);
                var r = this.getPoint(n), a = this.getPoint(i), o = a.clone().sub(r);
                return o.normalize()
            }, getTangentAt: function (t) {
                var e = this.getUtoTmapping(t);
                return this.getTangent(e)
            }, computeFrenetFrames: function (t, e) {
                var n, i, r, a = new c, o = [], s = [], u = [], h = new c, d = new l;
                for (n = 0; n <= t; n++)i = n / t, o[n] = this.getTangentAt(i), o[n].normalize();
                s[0] = new c, u[0] = new c;
                var p = Number.MAX_VALUE, f = Math.abs(o[0].x), m = Math.abs(o[0].y), g = Math.abs(o[0].z);
                for (f <= p && (p = f, a.set(1, 0, 0)), m <= p && (p = m, a.set(0, 1, 0)), g <= p && a.set(0, 0, 1), h.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], h), u[0].crossVectors(o[0], s[0]), n = 1; n <= t; n++)s[n] = s[n - 1].clone(), u[n] = u[n - 1].clone(), h.crossVectors(o[n - 1], o[n]), h.length() > Number.EPSILON && (h.normalize(), r = Math.acos(Qo.clamp(o[n - 1].dot(o[n]), -1, 1)), s[n].applyMatrix4(d.makeRotationAxis(h, r))), u[n].crossVectors(o[n], s[n]);
                if (e === !0)for (r = Math.acos(Qo.clamp(s[0].dot(s[t]), -1, 1)), r /= t, o[0].dot(h.crossVectors(s[0], s[t])) > 0 && (r = -r), n = 1; n <= t; n++)s[n].applyMatrix4(d.makeRotationAxis(o[n], r * n)), u[n].crossVectors(o[n], s[n]);
                return {tangents: o, normals: s, binormals: u}
            }
        }, ni.create = function (t, e) {
            return t.prototype = Object.create(ni.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
        }, ii.prototype = Object.create(ni.prototype), ii.prototype.constructor = ii, ii.prototype.isLineCurve = !0, ii.prototype.getPoint = function (t) {
            if (1 === t)return this.v2.clone();
            var e = this.v2.clone().sub(this.v1);
            return e.multiplyScalar(t).add(this.v1), e
        }, ii.prototype.getPointAt = function (t) {
            return this.getPoint(t)
        }, ii.prototype.getTangent = function (t) {
            var e = this.v2.clone().sub(this.v1);
            return e.normalize()
        }, ri.prototype = Object.assign(Object.create(ni.prototype), {
            constructor: ri, add: function (t) {
                this.curves.push(t)
            }, closePath: function () {
                var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
                t.equals(e) || this.curves.push(new ii(e, t))
            }, getPoint: function (t) {
                for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                    if (n[i] >= e) {
                        var r = n[i] - e, a = this.curves[i], o = a.getLength(), s = 0 === o ? 0 : 1 - r / o;
                        return a.getPointAt(s)
                    }
                    i++
                }
                return null
            }, getLength: function () {
                var t = this.getCurveLengths();
                return t[t.length - 1]
            }, updateArcLengths: function () {
                this.needsUpdate = !0, this.cacheLengths = null, this.getLengths()
            }, getCurveLengths: function () {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)return this.cacheLengths;
                for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)e += this.curves[n].getLength(), t.push(e);
                return this.cacheLengths = t, t
            }, getSpacedPoints: function (t) {
                t || (t = 40);
                for (var e = [], n = 0; n <= t; n++)e.push(this.getPoint(n / t));
                return this.autoClose && e.push(e[0]), e
            }, getPoints: function (t) {
                t = t || 12;
                for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)for (var a = r[i], o = a && a.isEllipseCurve ? 2 * t : a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length : t, s = a.getPoints(o), c = 0; c < s.length; c++) {
                    var l = s[c];
                    e && e.equals(l) || (n.push(l), e = l)
                }
                return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
            }, createPointsGeometry: function (t) {
                var e = this.getPoints(t);
                return this.createGeometry(e)
            }, createSpacedPointsGeometry: function (t) {
                var e = this.getSpacedPoints(t);
                return this.createGeometry(e)
            }, createGeometry: function (t) {
                for (var e = new Et, n = 0, i = t.length; n < i; n++) {
                    var r = t[n];
                    e.vertices.push(new c(r.x, r.y, r.z || 0))
                }
                return e
            }
        }), ai.prototype = Object.create(ni.prototype), ai.prototype.constructor = ai, ai.prototype.isEllipseCurve = !0, ai.prototype.getPoint = function (t) {
            for (var e = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, r = Math.abs(i) < Number.EPSILON; i < 0;)i += e;
            for (; i > e;)i -= e;
            i < Number.EPSILON && (i = r ? 0 : e), this.aClockwise !== !0 || r || (i === e ? i = -e : i -= e);
            var a = this.aStartAngle + t * i, o = this.aX + this.xRadius * Math.cos(a), s = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
                var c = Math.cos(this.aRotation), l = Math.sin(this.aRotation), u = o - this.aX, h = s - this.aY;
                o = u * c - h * l + this.aX, s = u * l + h * c + this.aY
            }
            return new n(o, s)
        };
        var _l = {
            tangentQuadraticBezier: function (t, e, n, i) {
                return 2 * (1 - t) * (n - e) + 2 * t * (i - n)
            }, tangentCubicBezier: function (t, e, n, i, r) {
                return -3 * e * (1 - t) * (1 - t) + 3 * n * (1 - t) * (1 - t) - 6 * t * n * (1 - t) + 6 * t * i * (1 - t) - 3 * t * t * i + 3 * t * t * r
            }, tangentSpline: function (t, e, n, i, r) {
                var a = 6 * t * t - 6 * t, o = 3 * t * t - 4 * t + 1, s = -6 * t * t + 6 * t, c = 3 * t * t - 2 * t;
                return a + o + s + c
            }, interpolate: function (t, e, n, i, r) {
                var a = .5 * (n - t), o = .5 * (i - e), s = r * r, c = r * s;
                return (2 * e - 2 * n + a + o) * c + (-3 * e + 3 * n - 2 * a - o) * s + a * r + e
            }
        };
        oi.prototype = Object.create(ni.prototype), oi.prototype.constructor = oi, oi.prototype.isSplineCurve = !0, oi.prototype.getPoint = function (t) {
            var e = this.points, i = (e.length - 1) * t, r = Math.floor(i), a = i - r, o = e[0 === r ? r : r - 1], s = e[r], c = e[r > e.length - 2 ? e.length - 1 : r + 1], l = e[r > e.length - 3 ? e.length - 1 : r + 2], u = _l.interpolate;
            return new n(u(o.x, s.x, c.x, l.x, a), u(o.y, s.y, c.y, l.y, a))
        }, si.prototype = Object.create(ni.prototype), si.prototype.constructor = si, si.prototype.getPoint = function (t) {
            var e = hl.b3;
            return new n(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
        }, si.prototype.getTangent = function (t) {
            var e = _l.tangentCubicBezier;
            return new n(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
        }, ci.prototype = Object.create(ni.prototype), ci.prototype.constructor = ci, ci.prototype.getPoint = function (t) {
            var e = hl.b2;
            return new n(e(t, this.v0.x, this.v1.x, this.v2.x), e(t, this.v0.y, this.v1.y, this.v2.y))
        }, ci.prototype.getTangent = function (t) {
            var e = _l.tangentQuadraticBezier;
            return new n(e(t, this.v0.x, this.v1.x, this.v2.x), e(t, this.v0.y, this.v1.y, this.v2.y)).normalize()
        };
        var xl = Object.assign(Object.create(ri.prototype), {
            fromPoints: function (t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y)
            }, moveTo: function (t, e) {
                this.currentPoint.set(t, e)
            }, lineTo: function (t, e) {
                var i = new ii(this.currentPoint.clone(), new n(t, e));
                this.curves.push(i), this.currentPoint.set(t, e)
            }, quadraticCurveTo: function (t, e, i, r) {
                var a = new ci(this.currentPoint.clone(), new n(t, e), new n(i, r));
                this.curves.push(a), this.currentPoint.set(i, r)
            }, bezierCurveTo: function (t, e, i, r, a, o) {
                var s = new si(this.currentPoint.clone(), new n(t, e), new n(i, r), new n(a, o));
                this.curves.push(s), this.currentPoint.set(a, o)
            }, splineThru: function (t) {
                var e = [this.currentPoint.clone()].concat(t), n = new oi(e);
                this.curves.push(n), this.currentPoint.copy(t[t.length - 1])
            }, arc: function (t, e, n, i, r, a) {
                var o = this.currentPoint.x, s = this.currentPoint.y;
                this.absarc(t + o, e + s, n, i, r, a)
            }, absarc: function (t, e, n, i, r, a) {
                this.absellipse(t, e, n, n, i, r, a)
            }, ellipse: function (t, e, n, i, r, a, o, s) {
                var c = this.currentPoint.x, l = this.currentPoint.y;
                this.absellipse(t + c, e + l, n, i, r, a, o, s)
            }, absellipse: function (t, e, n, i, r, a, o, s) {
                var c = new ai(t, e, n, i, r, a, o, s);
                if (this.curves.length > 0) {
                    var l = c.getPoint(0);
                    l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                }
                this.curves.push(c);
                var u = c.getPoint(1);
                this.currentPoint.copy(u)
            }
        });
        li.prototype = Object.assign(Object.create(xl), {
            constructor: li, getPointsHoles: function (t) {
                for (var e = [], n = 0, i = this.holes.length; n < i; n++)e[n] = this.holes[n].getPoints(t);
                return e
            }, extractAllPoints: function (t) {
                return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
            }, extractPoints: function (t) {
                return this.extractAllPoints(t)
            }
        }), ui.prototype = xl, xl.constructor = ui, hi.prototype = {
            moveTo: function (t, e) {
                this.currentPath = new ui, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
            }, lineTo: function (t, e) {
                this.currentPath.lineTo(t, e)
            }, quadraticCurveTo: function (t, e, n, i) {
                this.currentPath.quadraticCurveTo(t, e, n, i)
            }, bezierCurveTo: function (t, e, n, i, r, a) {
                this.currentPath.bezierCurveTo(t, e, n, i, r, a)
            }, splineThru: function (t) {
                this.currentPath.splineThru(t)
            }, toShapes: function (t, e) {
                function n(t) {
                    for (var e = [], n = 0, i = t.length; n < i; n++) {
                        var r = t[n], a = new li;
                        a.curves = r.curves, e.push(a)
                    }
                    return e
                }

                function i(t, e) {
                    for (var n = e.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                        var o = e[r], s = e[a], c = s.x - o.x, l = s.y - o.y;
                        if (Math.abs(l) > Number.EPSILON) {
                            if (l < 0 && (o = e[a], c = -c, s = e[r], l = -l), t.y < o.y || t.y > s.y)continue;
                            if (t.y === o.y) {
                                if (t.x === o.x)return !0
                            } else {
                                var u = l * (t.x - o.x) - c * (t.y - o.y);
                                if (0 === u)return !0;
                                if (u < 0)continue;
                                i = !i
                            }
                        } else {
                            if (t.y !== o.y)continue;
                            if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x)return !0
                        }
                    }
                    return i
                }

                var r = hl.isClockWise, a = this.subPaths;
                if (0 === a.length)return [];
                if (e === !0)return n(a);
                var o, s, c, l = [];
                if (1 === a.length)return s = a[0], c = new li, c.curves = s.curves, l.push(c), l;
                var u = !r(a[0].getPoints());
                u = t ? !u : u;
                var h, d = [], p = [], f = [], m = 0;
                p[m] = void 0, f[m] = [];
                for (var g = 0, v = a.length; g < v; g++)s = a[g], h = s.getPoints(), o = r(h), o = t ? !o : o, o ? (!u && p[m] && m++, p[m] = {
                    s: new li,
                    p: h
                }, p[m].s.curves = s.curves, u && m++, f[m] = []) : f[m].push({h: s, p: h[0]});
                if (!p[0])return n(a);
                if (p.length > 1) {
                    for (var y = !1, _ = [], x = 0, b = p.length; x < b; x++)d[x] = [];
                    for (var x = 0, b = p.length; x < b; x++)for (var w = f[x], M = 0; M < w.length; M++) {
                        for (var E = w[M], T = !0, S = 0; S < p.length; S++)i(E.p, p[S].p) && (x !== S && _.push({
                            froms: x,
                            tos: S,
                            hole: M
                        }), T ? (T = !1, d[S].push(E)) : y = !0);
                        T && d[x].push(E)
                    }
                    _.length > 0 && (y || (f = d))
                }
                for (var A, g = 0, L = p.length; g < L; g++) {
                    c = p[g].s, l.push(c), A = f[g];
                    for (var R = 0, C = A.length; R < C; R++)c.holes.push(A[R].h)
                }
                return l
            }
        }, Object.assign(di.prototype, {
            isFont: !0, generateShapes: function (t, e, n) {
                function i(t) {
                    for (var n = String(t).split(""), i = e / a.resolution, o = 0, s = [], c = 0; c < n.length; c++) {
                        var l = r(n[c], i, o);
                        o += l.offset, s.push(l.path)
                    }
                    return s
                }

                function r(t, e, i) {
                    var r = a.glyphs[t] || a.glyphs["?"];
                    if (r) {
                        var o, s, c, l, u, h, d, p, f, m, g, v = new hi, y = [], _ = hl.b2, x = hl.b3;
                        if (r.o)for (var b = r._cachedOutline || (r._cachedOutline = r.o.split(" ")), w = 0, M = b.length; w < M;) {
                            var E = b[w++];
                            switch (E) {
                                case"m":
                                    o = b[w++] * e + i, s = b[w++] * e, v.moveTo(o, s);
                                    break;
                                case"l":
                                    o = b[w++] * e + i, s = b[w++] * e, v.lineTo(o, s);
                                    break;
                                case"q":
                                    if (c = b[w++] * e + i, l = b[w++] * e, d = b[w++] * e + i, p = b[w++] * e, v.quadraticCurveTo(d, p, c, l), g = y[y.length - 1]) {
                                        u = g.x, h = g.y;
                                        for (var T = 1; T <= n; T++) {
                                            var S = T / n;
                                            _(S, u, d, c), _(S, h, p, l)
                                        }
                                    }
                                    break;
                                case"b":
                                    if (c = b[w++] * e + i, l = b[w++] * e, d = b[w++] * e + i, p = b[w++] * e, f = b[w++] * e + i, m = b[w++] * e, v.bezierCurveTo(d, p, f, m, c, l), g = y[y.length - 1]) {
                                        u = g.x, h = g.y;
                                        for (var T = 1; T <= n; T++) {
                                            var S = T / n;
                                            x(S, u, d, f, c), x(S, h, p, m, l)
                                        }
                                    }
                            }
                        }
                        return {offset: r.ha * e, path: v}
                    }
                }

                void 0 === e && (e = 100), void 0 === n && (n = 4);
                for (var a = this.data, o = i(t), s = [], c = 0, l = o.length; c < l; c++)Array.prototype.push.apply(s, o[c].toShapes());
                return s
            }
        }), Object.assign(pi.prototype, {
            load: function (t, e, n, i) {
                var r = this, a = new wn(this.manager);
                a.load(t, function (t) {
                    var n;
                    try {
                        n = JSON.parse(t)
                    } catch (e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                    }
                    var i = r.parse(n);
                    e && e(i)
                }, n, i)
            }, parse: function (t) {
                return new di(t)
            }
        });
        var bl, wl = {
            getContext: function () {
                return void 0 === bl && (bl = new (window.AudioContext || window.webkitAudioContext)), bl
            }, setContext: function (t) {
                bl = t
            }
        };
        Object.assign(fi.prototype, {
            load: function (t, e, n, i) {
                var r = new wn(this.manager);
                r.setResponseType("arraybuffer"), r.load(t, function (t) {
                    var n = wl.getContext();
                    n.decodeAudioData(t, function (t) {
                        e(t)
                    })
                }, n, i)
            }
        }), mi.prototype = Object.assign(Object.create(Ln.prototype), {
            constructor: mi,
            isRectAreaLight: !0,
            copy: function (t) {
                return Ln.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
            }
        }), Object.assign(gi.prototype, {
            update: function () {
                var t, e, n, i, r, a, o, s = new l, c = new l;
                return function (l) {
                    var u = t !== this || e !== l.focus || n !== l.fov || i !== l.aspect * this.aspect || r !== l.near || a !== l.far || o !== l.zoom;
                    if (u) {
                        t = this, e = l.focus, n = l.fov, i = l.aspect * this.aspect, r = l.near, a = l.far, o = l.zoom;
                        var h, d, p = l.projectionMatrix.clone(), f = this.eyeSep / 2, m = f * r / e, g = r * Math.tan(Qo.DEG2RAD * n * .5) / o;
                        c.elements[12] = -f, s.elements[12] = f, h = -g * i + m, d = g * i + m, p.elements[0] = 2 * r / (d - h), p.elements[8] = (d + h) / (d - h), this.cameraL.projectionMatrix.copy(p), h = -g * i - m, d = g * i - m, p.elements[0] = 2 * r / (d - h), p.elements[8] = (d + h) / (d - h), this.cameraR.projectionMatrix.copy(p)
                    }
                    this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(c), this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(s)
                }
            }()
        }), vi.prototype = Object.create(ct.prototype), vi.prototype.constructor = vi, yi.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: yi,
            getInput: function () {
                return this.gain
            },
            removeFilter: function () {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function () {
                return this.filter
            },
            setFilter: function (t) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function () {
                return this.gain.gain.value
            },
            setMasterVolume: function (t) {
                this.gain.gain.value = t
            },
            updateMatrixWorld: function () {
                var t = new c, e = new s, n = new c, i = new c;
                return function (r) {
                    ct.prototype.updateMatrixWorld.call(this, r);
                    var a = this.context.listener, o = this.up;
                    this.matrixWorld.decompose(t, e, n), i.set(0, 0, -1).applyQuaternion(e), a.positionX ? (a.positionX.setValueAtTime(t.x, this.context.currentTime), a.positionY.setValueAtTime(t.y, this.context.currentTime), a.positionZ.setValueAtTime(t.z, this.context.currentTime), a.forwardX.setValueAtTime(i.x, this.context.currentTime), a.forwardY.setValueAtTime(i.y, this.context.currentTime), a.forwardZ.setValueAtTime(i.z, this.context.currentTime), a.upX.setValueAtTime(o.x, this.context.currentTime), a.upY.setValueAtTime(o.y, this.context.currentTime), a.upZ.setValueAtTime(o.z, this.context.currentTime)) : (a.setPosition(t.x, t.y, t.z), a.setOrientation(i.x, i.y, i.z, o.x, o.y, o.z))
                }
            }()
        }), _i.prototype = Object.assign(Object.create(ct.prototype), {
            constructor: _i, getOutput: function () {
                return this.gain
            }, setNodeSource: function (t) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
            }, setBuffer: function (t) {
                return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
            }, play: function () {
                if (this.isPlaying === !0)return void console.warn("THREE.Audio: Audio is already playing.");
                if (this.hasPlaybackControl === !1)return void console.warn("THREE.Audio: this Audio has no playback control.");
                var t = this.context.createBufferSource();
                return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), t.start(0, this.startTime), this.isPlaying = !0, this.source = t, this.connect()
            }, pause: function () {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this)
            }, stop: function () {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this)
            }, connect: function () {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            }, disconnect: function () {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            }, getFilters: function () {
                return this.filters
            }, setFilters: function (t) {
                return t || (t = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
            }, getFilter: function () {
                return this.getFilters()[0]
            }, setFilter: function (t) {
                return this.setFilters(t ? [t] : [])
            }, setPlaybackRate: function (t) {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this)
            }, getPlaybackRate: function () {
                return this.playbackRate
            }, onEnded: function () {
                this.isPlaying = !1
            }, getLoop: function () {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
            }, setLoop: function (t) {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = t, this.isPlaying === !0 && (this.source.loop = this.loop), this)
            }, getVolume: function () {
                return this.gain.gain.value
            }, setVolume: function (t) {
                return this.gain.gain.value = t, this
            }
        }), xi.prototype = Object.assign(Object.create(_i.prototype), {
            constructor: xi, getOutput: function () {
                return this.panner
            }, getRefDistance: function () {
                return this.panner.refDistance
            }, setRefDistance: function (t) {
                this.panner.refDistance = t
            }, getRolloffFactor: function () {
                return this.panner.rolloffFactor
            }, setRolloffFactor: function (t) {
                this.panner.rolloffFactor = t
            }, getDistanceModel: function () {
                return this.panner.distanceModel
            }, setDistanceModel: function (t) {
                this.panner.distanceModel = t
            }, getMaxDistance: function () {
                return this.panner.maxDistance
            }, setMaxDistance: function (t) {
                this.panner.maxDistance = t
            }, updateMatrixWorld: function () {
                var t = new c;
                return function (e) {
                    ct.prototype.updateMatrixWorld.call(this, e), t.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(t.x, t.y, t.z)
                }
            }()
        }), Object.assign(bi.prototype, {
            getFrequencyData: function () {
                return this.analyser.getByteFrequencyData(this.data), this.data
            }, getAverageFrequency: function () {
                for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)t += e[n];
                return t / e.length
            }
        }), wi.prototype = {
            constructor: wi, accumulate: function (t, e) {
                var n = this.buffer, i = this.valueSize, r = t * i + i, a = this.cumulativeWeight;
                if (0 === a) {
                    for (var o = 0; o !== i; ++o)n[r + o] = n[o];
                    a = e
                } else {
                    a += e;
                    var s = e / a;
                    this._mixBufferRegion(n, r, 0, s, i)
                }
                this.cumulativeWeight = a
            }, apply: function (t) {
                var e = this.valueSize, n = this.buffer, i = t * e + e, r = this.cumulativeWeight, a = this.binding;
                if (this.cumulativeWeight = 0, r < 1) {
                    var o = 3 * e;
                    this._mixBufferRegion(n, i, o, 1 - r, e)
                }
                for (var s = e, c = e + e; s !== c; ++s)if (n[s] !== n[s + e]) {
                    a.setValue(n, i);
                    break
                }
            }, saveOriginalState: function () {
                var t = this.binding, e = this.buffer, n = this.valueSize, i = 3 * n;
                t.getValue(e, i);
                for (var r = n, a = i; r !== a; ++r)e[r] = e[i + r % n];
                this.cumulativeWeight = 0
            }, restoreOriginalState: function () {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            }, _select: function (t, e, n, i, r) {
                if (i >= .5)for (var a = 0; a !== r; ++a)t[e + a] = t[n + a]
            }, _slerp: function (t, e, n, i, r) {
                s.slerpFlat(t, e, t, e, t, n, i)
            }, _lerp: function (t, e, n, i, r) {
                for (var a = 1 - i, o = 0; o !== r; ++o) {
                    var s = e + o;
                    t[s] = t[s] * a + t[n + o] * i
                }
            }
        }, Mi.prototype = {
            constructor: Mi, getValue: function (t, e) {
                this.bind(), this.getValue(t, e)
            }, setValue: function (t, e) {
                this.bind(), this.setValue(t, e)
            }, bind: function () {
                var t = this.node, e = this.parsedPath, n = e.objectName, i = e.propertyName, r = e.propertyIndex;
                if (t || (t = Mi.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t)return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    var a = e.objectIndex;
                    switch (n) {
                        case"materials":
                            if (!t.material)return void console.error("  can not bind to material as node does not have a material", this);
                            if (!t.material.materials)return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                            t = t.material.materials;
                            break;
                        case"bones":
                            if (!t.skeleton)return void console.error("  can not bind to bones as node does not have a skeleton", this);
                            t = t.skeleton.bones;
                            for (var o = 0; o < t.length; o++)if (t[o].name === a) {
                                a = o;
                                break
                            }
                            break;
                        default:
                            if (void 0 === t[n])return void console.error("  can not bind to objectName of node, undefined", this);
                            t = t[n]
                    }
                    if (void 0 !== a) {
                        if (void 0 === t[a])return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, t);
                        t = t[a]
                    }
                }
                var s = t[i];
                if (void 0 === s) {
                    var c = e.nodeName;
                    return void console.error("  trying to update property for track: " + c + "." + i + " but it wasn't found.", t)
                }
                var l = this.Versioning.None;
                void 0 !== t.needsUpdate ? (l = this.Versioning.NeedsUpdate, this.targetObject = t) : void 0 !== t.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                var u = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry)return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                        if (!t.geometry.morphTargets)return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                        for (var o = 0; o < this.node.geometry.morphTargets.length; o++)if (t.geometry.morphTargets[o].name === r) {
                            r = o;
                            break
                        }
                    }
                    u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : void 0 !== s.length ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][l]
            }, unbind: function () {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }, Object.assign(Mi.prototype, {
            _getValue_unavailable: function () {
            },
            _setValue_unavailable: function () {
            },
            _getValue_unbound: Mi.prototype.getValue,
            _setValue_unbound: Mi.prototype.setValue,
            BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
            Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
            GetterByBindingType: [function (t, e) {
                t[e] = this.node[this.propertyName]
            }, function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)t[e++] = n[i]
            }, function (t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            }, function (t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [[function (t, e) {
                this.node[this.propertyName] = t[e]
            }, function (t, e) {
                this.node[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.node[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++]
            }, function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++];
                this.targetObject.needsUpdate = !0
            }, function (t, e) {
                for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
            }], [function (t, e) {
                this.resolvedProperty.fromArray(t, e)
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
            }, function (t, e) {
                this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
            }]]
        }), Mi.Composite = function (t, e, n) {
            var i = n || Mi.parseTrackName(e);
            this._targetGroup = t, this._bindings = t.subscribe_(e, i)
        }, Mi.Composite.prototype = {
            constructor: Mi.Composite, getValue: function (t, e) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
                void 0 !== i && i.getValue(t, e)
            }, setValue: function (t, e) {
                for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)n[i].setValue(t, e)
            }, bind: function () {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind()
            }, unbind: function () {
                for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind()
            }
        }, Mi.create = function (t, e, n) {
            return t && t.isAnimationObjectGroup ? new Mi.Composite(t, e, n) : new Mi(t, e, n)
        }, Mi.parseTrackName = function (t) {
            var e = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/, n = e.exec(t);
            if (!n)throw new Error("cannot parse trackName at all: " + t);
            var i = {nodeName: n[2], objectName: n[3], objectIndex: n[4], propertyName: n[5], propertyIndex: n[6]};
            if (null === i.propertyName || 0 === i.propertyName.length)throw new Error("can not parse propertyName from trackName: " + t);
            return i
        }, Mi.findNode = function (t, e) {
            if (!e || "" === e || "root" === e || "." === e || e === -1 || e === t.name || e === t.uuid)return t;
            if (t.skeleton) {
                var n = function (t) {
                    for (var n = 0; n < t.bones.length; n++) {
                        var i = t.bones[n];
                        if (i.name === e)return i
                    }
                    return null
                }, i = n(t.skeleton);
                if (i)return i
            }
            if (t.children) {
                var r = function (t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        if (i.name === e || i.uuid === e)return i;
                        var a = r(i.children);
                        if (a)return a
                    }
                    return null
                }, a = r(t.children);
                if (a)return a
            }
            return null
        }, Ei.prototype = {
            constructor: Ei, isAnimationObjectGroup: !0, add: function (t) {
                for (var e = this._objects, n = e.length, i = this.nCachedObjects_, r = this._indicesByUUID, a = this._paths, o = this._parsedPaths, s = this._bindings, c = s.length, l = 0, u = arguments.length; l !== u; ++l) {
                    var h = arguments[l], d = h.uuid, p = r[d], f = void 0;
                    if (void 0 === p) {
                        p = n++, r[d] = p, e.push(h);
                        for (var m = 0, g = c; m !== g; ++m)s[m].push(new Mi(h, a[m], o[m]))
                    } else if (p < i) {
                        f = e[p];
                        var v = --i, y = e[v];
                        r[y.uuid] = p, e[p] = y, r[d] = v, e[v] = h;
                        for (var m = 0, g = c; m !== g; ++m) {
                            var _ = s[m], x = _[v], b = _[p];
                            _[p] = x, void 0 === b && (b = new Mi(h, a[m], o[m])), _[v] = b
                        }
                    } else e[p] !== f && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                }
                this.nCachedObjects_ = i
            }, remove: function (t) {
                for (var e = this._objects, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                    var c = arguments[o], l = c.uuid, u = i[l];
                    if (void 0 !== u && u >= n) {
                        var h = n++, d = e[h];
                        i[d.uuid] = u, e[u] = d, i[l] = h, e[h] = c;
                        for (var p = 0, f = a; p !== f; ++p) {
                            var m = r[p], g = m[h], v = m[u];
                            m[u] = g, m[h] = v
                        }
                    }
                }
                this.nCachedObjects_ = n
            }, uncache: function (t) {
                for (var e = this._objects, n = e.length, i = this.nCachedObjects_, r = this._indicesByUUID, a = this._bindings, o = a.length, s = 0, c = arguments.length; s !== c; ++s) {
                    var l = arguments[s], u = l.uuid, h = r[u];
                    if (void 0 !== h)if (delete r[u], h < i) {
                        var d = --i, p = e[d], f = --n, m = e[f];
                        r[p.uuid] = h, e[h] = p, r[m.uuid] = d, e[d] = m, e.pop();
                        for (var g = 0, v = o; g !== v; ++g) {
                            var y = a[g], _ = y[d], x = y[f];
                            y[h] = _, y[d] = x, y.pop()
                        }
                    } else {
                        var f = --n, m = e[f];
                        r[m.uuid] = h, e[h] = m, e.pop();
                        for (var g = 0, v = o; g !== v; ++g) {
                            var y = a[g];
                            y[h] = y[f], y.pop()
                        }
                    }
                }
                this.nCachedObjects_ = i
            }, subscribe_: function (t, e) {
                var n = this._bindingsIndicesByPath, i = n[t], r = this._bindings;
                if (void 0 !== i)return r[i];
                var a = this._paths, o = this._parsedPaths, s = this._objects, c = s.length, l = this.nCachedObjects_, u = new Array(c);
                i = r.length, n[t] = i, a.push(t), o.push(e), r.push(u);
                for (var h = l, d = s.length; h !== d; ++h) {
                    var p = s[h];
                    u[h] = new Mi(p, t, e)
                }
                return u
            }, unsubscribe_: function (t) {
                var e = this._bindingsIndicesByPath, n = e[t];
                if (void 0 !== n) {
                    var i = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o], c = t[o];
                    e[c] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                }
            }
        }, Ti.prototype = {
            constructor: Ti, play: function () {
                return this._mixer._activateAction(this), this
            }, stop: function () {
                return this._mixer._deactivateAction(this), this.reset()
            }, reset: function () {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }, isRunning: function () {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }, isScheduled: function () {
                return this._mixer._isActiveAction(this)
            }, startAt: function (t) {
                return this._startTime = t, this
            }, setLoop: function (t, e) {
                return this.loop = t, this.repetitions = e, this
            }, setEffectiveWeight: function (t) {
                return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
            }, getEffectiveWeight: function () {
                return this._effectiveWeight
            }, fadeIn: function (t) {
                return this._scheduleFading(t, 0, 1)
            }, fadeOut: function (t) {
                return this._scheduleFading(t, 1, 0)
            }, crossFadeFrom: function (t, e, n) {
                if (t.fadeOut(e), this.fadeIn(e), n) {
                    var i = this._clip.duration, r = t._clip.duration, a = r / i, o = i / r;
                    t.warp(1, a, e), this.warp(o, 1, e)
                }
                return this
            }, crossFadeTo: function (t, e, n) {
                return t.crossFadeFrom(this, e, n)
            }, stopFading: function () {
                var t = this._weightInterpolant;
                return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }, setEffectiveTimeScale: function (t) {
                return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
            }, getEffectiveTimeScale: function () {
                return this._effectiveTimeScale
            }, setDuration: function (t) {
                return this.timeScale = this._clip.duration / t, this.stopWarping()
            }, syncWith: function (t) {
                return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
            }, halt: function (t) {
                return this.warp(this._effectiveTimeScale, 0, t)
            }, warp: function (t, e, n) {
                var i = this._mixer, r = i.time, a = this._timeScaleInterpolant, o = this.timeScale;
                null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
                var s = a.parameterPositions, c = a.sampleValues;
                return s[0] = r, s[1] = r + n, c[0] = t / o, c[1] = e / o, this
            }, stopWarping: function () {
                var t = this._timeScaleInterpolant;
                return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
            }, getMixer: function () {
                return this._mixer
            }, getClip: function () {
                return this._clip
            }, getRoot: function () {
                return this._localRoot || this._mixer._root
            }, _update: function (t, e, n, i) {
                var r = this._startTime;
                if (null !== r) {
                    var a = (t - r) * n;
                    if (a < 0 || 0 === n)return;
                    this._startTime = null, e = n * a
                }
                e *= this._updateTimeScale(t);
                var o = this._updateTime(e), s = this._updateWeight(t);
                if (s > 0)for (var c = this._interpolants, l = this._propertyBindings, u = 0, h = c.length; u !== h; ++u)c[u].evaluate(o), l[u].accumulate(i, s)
            }, _updateWeight: function (t) {
                var e = 0;
                if (this.enabled) {
                    e = this.weight;
                    var n = this._weightInterpolant;
                    if (null !== n) {
                        var i = n.evaluate(t)[0];
                        e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = e, e
            }, _updateTimeScale: function (t) {
                var e = 0;
                if (!this.paused) {
                    e = this.timeScale;
                    var n = this._timeScaleInterpolant;
                    if (null !== n) {
                        var i = n.evaluate(t)[0];
                        e *= i, t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                }
                return this._effectiveTimeScale = e, e
            }, _updateTime: function (t) {
                var e = this.time + t;
                if (0 === t)return e;
                var n = this._clip.duration, i = this.loop, r = this._loopCount;
                if (i === Ro) {
                    r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    t:{
                        if (e >= n)e = n; else {
                            if (!(e < 0))break t;
                            e = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t < 0 ? -1 : 1
                        })
                    }
                } else {
                    var a = i === Po;
                    if (r === -1 && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), e >= n || e < 0) {
                        var o = Math.floor(e / n);
                        e -= n * o, r += Math.abs(o);
                        var s = this.repetitions - r;
                        if (s < 0)this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: t > 0 ? 1 : -1
                        }); else {
                            if (0 === s) {
                                var c = t < 0;
                                this._setEndings(c, !c, a)
                            } else this._setEndings(!1, !1, a);
                            this._loopCount = r, this._mixer.dispatchEvent({type: "loop", action: this, loopDelta: o})
                        }
                    }
                    if (a && 1 === (1 & r))return this.time = e, n - e
                }
                return this.time = e, e
            }, _setEndings: function (t, e, n) {
                var i = this._interpolantSettings;
                n ? (i.endingStart = Do, i.endingEnd = Do) : (t ? i.endingStart = this.zeroSlopeAtStart ? Do : No : i.endingStart = Fo, e ? i.endingEnd = this.zeroSlopeAtEnd ? Do : No : i.endingEnd = Fo)
            }, _scheduleFading: function (t, e, n) {
                var i = this._mixer, r = i.time, a = this._weightInterpolant;
                null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                var o = a.parameterPositions, s = a.sampleValues;
                return o[0] = r, s[0] = e, o[1] = r + t, s[1] = n, this
            }
        }, Object.assign(Si.prototype, e.prototype, {
            clipAction: function (t, e) {
                var n = e || this._root, i = n.uuid, r = "string" == typeof t ? Jn.findByName(n, t) : t, a = null !== r ? r.uuid : t, o = this._actionsByClip[a], s = null;
                if (void 0 !== o) {
                    var c = o.actionByRoot[i];
                    if (void 0 !== c)return c;
                    s = o.knownActions[0], null === r && (r = s._clip)
                }
                if (null === r)return null;
                var l = new Ti(this, r, e);
                return this._bindAction(l, s), this._addInactiveAction(l, a, i), l
            }, existingAction: function (t, e) {
                var n = e || this._root, i = n.uuid, r = "string" == typeof t ? Jn.findByName(n, t) : t, a = r ? r.uuid : t, o = this._actionsByClip[a];
                return void 0 !== o ? o.actionByRoot[i] || null : null
            }, stopAllAction: function () {
                var t = this._actions, e = this._nActiveActions, n = this._bindings, i = this._nActiveBindings;
                this._nActiveActions = 0, this._nActiveBindings = 0;
                for (var r = 0; r !== e; ++r)t[r].reset();
                for (var r = 0; r !== i; ++r)n[r].useCount = 0;
                return this
            }, update: function (t) {
                t *= this.timeScale;
                for (var e = this._actions, n = this._nActiveActions, i = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                    var s = e[o];
                    s.enabled && s._update(i, t, r, a)
                }
                for (var c = this._bindings, l = this._nActiveBindings, o = 0; o !== l; ++o)c[o].apply(a);
                return this
            }, getRoot: function () {
                return this._root
            }, uncacheClip: function (t) {
                var e = this._actions, n = t.uuid, i = this._actionsByClip, r = i[n];
                if (void 0 !== r) {
                    for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                        var c = a[o];
                        this._deactivateAction(c);
                        var l = c._cacheIndex, u = e[e.length - 1];
                        c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = l, e[l] = u, e.pop(), this._removeInactiveBindingsForAction(c)
                    }
                    delete i[n]
                }
            }, uncacheRoot: function (t) {
                var e = t.uuid, n = this._actionsByClip;
                for (var i in n) {
                    var r = n[i].actionByRoot, a = r[e];
                    void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
                }
                var o = this._bindingsByRootAndName, s = o[e];
                if (void 0 !== s)for (var c in s) {
                    var l = s[c];
                    l.restoreOriginalState(), this._removeInactiveBinding(l)
                }
            }, uncacheAction: function (t, e) {
                var n = this.existingAction(t, e);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }), Object.assign(Si.prototype, {
            _bindAction: function (t, e) {
                var n = t._localRoot || this._root, i = t._clip.tracks, r = i.length, a = t._propertyBindings, o = t._interpolants, s = n.uuid, c = this._bindingsByRootAndName, l = c[s];
                void 0 === l && (l = {}, c[s] = l);
                for (var u = 0; u !== r; ++u) {
                    var h = i[u], d = h.name, p = l[d];
                    if (void 0 !== p)a[u] = p; else {
                        if (p = a[u], void 0 !== p) {
                            null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                            continue
                        }
                        var f = e && e._propertyBindings[u].binding.parsedPath;
                        p = new wi(Mi.create(n, d, f), h.ValueTypeName, h.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, s, d), a[u] = p
                    }
                    o[u].resultBuffer = p.buffer
                }
            }, _activateAction: function (t) {
                if (!this._isActiveAction(t)) {
                    if (null === t._cacheIndex) {
                        var e = (t._localRoot || this._root).uuid, n = t._clip.uuid, i = this._actionsByClip[n];
                        this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                    }
                    for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                        var s = r[a];
                        0 === s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                    }
                    this._lendAction(t)
                }
            }, _deactivateAction: function (t) {
                if (this._isActiveAction(t)) {
                    for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                        var r = e[n];
                        0 === --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                    }
                    this._takeBackAction(t)
                }
            }, _initMemoryManager: function () {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var t = this;
                this.stats = {
                    actions: {
                        get total() {
                            return t._actions.length
                        }, get inUse() {
                            return t._nActiveActions
                        }
                    }, bindings: {
                        get total() {
                            return t._bindings.length
                        }, get inUse() {
                            return t._nActiveBindings
                        }
                    }, controlInterpolants: {
                        get total() {
                            return t._controlInterpolants.length
                        }, get inUse() {
                            return t._nActiveControlInterpolants
                        }
                    }
                }
            }, _isActiveAction: function (t) {
                var e = t._cacheIndex;
                return null !== e && e < this._nActiveActions
            }, _addInactiveAction: function (t, e, n) {
                var i = this._actions, r = this._actionsByClip, a = r[e];
                if (void 0 === a)a = {knownActions: [t], actionByRoot: {}}, t._byClipCacheIndex = 0, r[e] = a; else {
                    var o = a.knownActions;
                    t._byClipCacheIndex = o.length, o.push(t)
                }
                t._cacheIndex = i.length, i.push(t), a.actionByRoot[n] = t
            }, _removeInactiveAction: function (t) {
                var e = this._actions, n = e[e.length - 1], i = t._cacheIndex;
                n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                var r = t._clip.uuid, a = this._actionsByClip, o = a[r], s = o.knownActions, c = s[s.length - 1], l = t._byClipCacheIndex;
                c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null;
                var u = o.actionByRoot, h = (e._localRoot || this._root).uuid;
                delete u[h], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(t)
            }, _removeInactiveBindingsForAction: function (t) {
                for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
                    var r = e[n];
                    0 === --r.referenceCount && this._removeInactiveBinding(r)
                }
            }, _lendAction: function (t) {
                var e = this._actions, n = t._cacheIndex, i = this._nActiveActions++, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }, _takeBackAction: function (t) {
                var e = this._actions, n = t._cacheIndex, i = --this._nActiveActions, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }, _addInactiveBinding: function (t, e, n) {
                var i = this._bindingsByRootAndName, r = i[e], a = this._bindings;
                void 0 === r && (r = {}, i[e] = r), r[n] = t, t._cacheIndex = a.length, a.push(t)
            }, _removeInactiveBinding: function (t) {
                var e = this._bindings, n = t.binding, i = n.rootNode.uuid, r = n.path, a = this._bindingsByRootAndName, o = a[i], s = e[e.length - 1], c = t._cacheIndex;
                s._cacheIndex = c, e[c] = s, e.pop(), delete o[r];
                t:{
                    for (var l in o)break t;
                    delete a[i]
                }
            }, _lendBinding: function (t) {
                var e = this._bindings, n = t._cacheIndex, i = this._nActiveBindings++, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }, _takeBackBinding: function (t) {
                var e = this._bindings, n = t._cacheIndex, i = --this._nActiveBindings, r = e[i];
                t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
            }, _lendControlInterpolant: function () {
                var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, n = t[e];
                return void 0 === n && (n = new zn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
            }, _takeBackControlInterpolant: function (t) {
                var e = this._controlInterpolants, n = t.__cacheIndex, i = --this._nActiveControlInterpolants, r = e[i];
                t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
            }, _controlInterpolantsResultBuffer: new Float32Array(1)
        }), Ai.prototype.clone = function () {
            return new Ai(void 0 === this.value.clone ? this.value : this.value.clone())
        }, Li.prototype = Object.create(St.prototype), Li.prototype.constructor = Li, Li.prototype.isInstancedBufferGeometry = !0, Li.prototype.addGroup = function (t, e, n) {
            this.groups.push({start: t, count: e, materialIndex: n})
        }, Li.prototype.copy = function (t) {
            var e = t.index;
            null !== e && this.setIndex(e.clone());
            var n = t.attributes;
            for (var i in n) {
                var r = n[i];
                this.addAttribute(i, r.clone())
            }
            for (var a = t.groups, o = 0, s = a.length; o < s; o++) {
                var c = a[o];
                this.addGroup(c.start, c.count, c.materialIndex)
            }
            return this
        }, Ri.prototype = {
            constructor: Ri, isInterleavedBufferAttribute: !0, get count() {
                return this.data.count
            }, get array() {
                return this.data.array
            }, setX: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset] = e, this
            }, setY: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 1] = e, this
            }, setZ: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 2] = e, this
            }, setW: function (t, e) {
                return this.data.array[t * this.data.stride + this.offset + 3] = e, this
            }, getX: function (t) {
                return this.data.array[t * this.data.stride + this.offset]
            }, getY: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 1]
            }, getZ: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 2]
            }, getW: function (t) {
                return this.data.array[t * this.data.stride + this.offset + 3]
            }, setXY: function (t, e, n) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
            }, setXYZ: function (t, e, n, i) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
            }, setXYZW: function (t, e, n, i, r) {
                return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
            }
        }, Ci.prototype = {
            constructor: Ci, isInterleavedBuffer: !0, set needsUpdate(t) {
                t === !0 && this.version++
            }, setArray: function (t) {
                if (Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t
            }, setDynamic: function (t) {
                return this.dynamic = t, this
            }, copy: function (t) {
                return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
            }, copyAt: function (t, e, n) {
                t *= this.stride, n *= e.stride;
                for (var i = 0, r = this.stride; i < r; i++)this.array[t + i] = e.array[n + i];
                return this
            }, set: function (t, e) {
                return void 0 === e && (e = 0), this.array.set(t, e), this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, onUpload: function (t) {
                return this.onUploadCallback = t, this
            }
        }, Pi.prototype = Object.create(Ci.prototype), Pi.prototype.constructor = Pi, Pi.prototype.isInstancedInterleavedBuffer = !0, Pi.prototype.copy = function (t) {
            return Ci.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }, Oi.prototype = Object.create(pt.prototype), Oi.prototype.constructor = Oi, Oi.prototype.isInstancedBufferAttribute = !0, Oi.prototype.copy = function (t) {
            return pt.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }, Ii.prototype = {
            constructor: Ii, linePrecision: 1, set: function (t, e) {
                this.ray.set(t, e)
            }, setFromCamera: function (t, e) {
                e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            }, intersectObject: function (t, e) {
                var n = [];
                return Ni(t, this, n, e), n.sort(Ui), n
            }, intersectObjects: function (t, e) {
                var n = [];
                if (Array.isArray(t) === !1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                for (var i = 0, r = t.length; i < r; i++)Ni(t[i], this, n, e);
                return n.sort(Ui), n
            }
        }, Di.prototype = {
            constructor: Di, start: function () {
                this.startTime = (performance || Date).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }, stop: function () {
                this.getElapsedTime(), this.running = !1
            }, getElapsedTime: function () {
                return this.getDelta(), this.elapsedTime
            }, getDelta: function () {
                var t = 0;
                if (this.autoStart && !this.running && this.start(), this.running) {
                    var e = (performance || Date).now();
                    t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                }
                return t
            }
        }, Bi.prototype = {
            constructor: Bi, set: function (t, e, n) {
                return this.radius = t, this.phi = e, this.theta = n, this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
            }, makeSafe: function () {
                var t = 1e-6;
                return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this
            }, setFromVector3: function (t) {
                return this.radius = t.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(Qo.clamp(t.y / this.radius, -1, 1))), this
            }
        }, zi.prototype = {
            constructor: zi, set: function (t, e, n) {
                return this.radius = t, this.theta = e, this.y = n, this
            }, clone: function () {
                return (new this.constructor).copy(this)
            }, copy: function (t) {
                return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
            }, setFromVector3: function (t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z), this.theta = Math.atan2(t.x, t.z), this.y = t.y, this
            }
        }, Gi.prototype = Object.create(At.prototype), Gi.prototype.constructor = Gi, Gi.prototype.createAnimation = function (t, e, n, i) {
            var r = {
                start: e,
                end: n,
                length: n - e + 1,
                fps: i,
                duration: (n - e) / i,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            };
            this.animationsMap[t] = r, this.animationsList.push(r)
        }, Gi.prototype.autoCreateAnimations = function (t) {
            for (var e, n = /([a-z]+)_?(\d+)/i, i = {}, r = this.geometry, a = 0, o = r.morphTargets.length; a < o; a++) {
                var s = r.morphTargets[a], c = s.name.match(n);
                if (c && c.length > 1) {
                    var l = c[1];
                    i[l] || (i[l] = {start: 1 / 0, end: -(1 / 0)});
                    var u = i[l];
                    a < u.start && (u.start = a), a > u.end && (u.end = a), e || (e = l)
                }
            }
            for (var l in i) {
                var u = i[l];
                this.createAnimation(l, u.start, u.end, t)
            }
            this.firstAnimation = e
        }, Gi.prototype.setAnimationDirectionForward = function (t) {
            var e = this.animationsMap[t];
            e && (e.direction = 1, e.directionBackwards = !1)
        }, Gi.prototype.setAnimationDirectionBackward = function (t) {
            var e = this.animationsMap[t];
            e && (e.direction = -1, e.directionBackwards = !0)
        }, Gi.prototype.setAnimationFPS = function (t, e) {
            var n = this.animationsMap[t];
            n && (n.fps = e, n.duration = (n.end - n.start) / n.fps)
        }, Gi.prototype.setAnimationDuration = function (t, e) {
            var n = this.animationsMap[t];
            n && (n.duration = e, n.fps = (n.end - n.start) / n.duration)
        }, Gi.prototype.setAnimationWeight = function (t, e) {
            var n = this.animationsMap[t];
            n && (n.weight = e)
        }, Gi.prototype.setAnimationTime = function (t, e) {
            var n = this.animationsMap[t];
            n && (n.time = e)
        }, Gi.prototype.getAnimationTime = function (t) {
            var e = 0, n = this.animationsMap[t];
            return n && (e = n.time), e
        }, Gi.prototype.getAnimationDuration = function (t) {
            var e = -1, n = this.animationsMap[t];
            return n && (e = n.duration), e
        }, Gi.prototype.playAnimation = function (t) {
            var e = this.animationsMap[t];
            e ? (e.time = 0, e.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
        }, Gi.prototype.stopAnimation = function (t) {
            var e = this.animationsMap[t];
            e && (e.active = !1)
        }, Gi.prototype.update = function (t) {
            for (var e = 0, n = this.animationsList.length; e < n; e++) {
                var i = this.animationsList[e];
                if (i.active) {
                    var r = i.duration / i.length;
                    i.time += i.direction * t, i.mirroredLoop ? (i.time > i.duration || i.time < 0) && (i.direction *= -1, i.time > i.duration && (i.time = i.duration, i.directionBackwards = !0), i.time < 0 && (i.time = 0, i.directionBackwards = !1)) : (i.time = i.time % i.duration, i.time < 0 && (i.time += i.duration));
                    var a = i.start + Qo.clamp(Math.floor(i.time / r), 0, i.length - 1), o = i.weight;
                    a !== i.currentFrame && (this.morphTargetInfluences[i.lastFrame] = 0, this.morphTargetInfluences[i.currentFrame] = 1 * o, this.morphTargetInfluences[a] = 0, i.lastFrame = i.currentFrame, i.currentFrame = a);
                    var s = i.time % r / r;
                    i.directionBackwards && (s = 1 - s), i.currentFrame !== i.lastFrame ? (this.morphTargetInfluences[i.currentFrame] = s * o, this.morphTargetInfluences[i.lastFrame] = (1 - s) * o) : this.morphTargetInfluences[i.currentFrame] = o
                }
            }
        }, ki.prototype = Object.create(ct.prototype), ki.prototype.constructor = ki, ki.prototype.isImmediateRenderObject = !0, Hi.prototype = Object.create(ye.prototype), Hi.prototype.constructor = Hi, Hi.prototype.update = function () {
            var t = new c, e = new c, n = new et;
            return function () {
                var i = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                var r = this.object.matrixWorld, a = this.geometry.attributes.position, o = this.object.geometry;
                if (o && o.isGeometry)for (var s = o.vertices, c = o.faces, l = 0, u = 0, h = c.length; u < h; u++)for (var d = c[u], p = 0, f = d.vertexNormals.length; p < f; p++) {
                    var m = s[d[i[p]]], g = d.vertexNormals[p];
                    t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), a.setXYZ(l, t.x, t.y, t.z), l += 1, a.setXYZ(l, e.x, e.y, e.z), l += 1
                } else if (o && o.isBufferGeometry)for (var v = o.attributes.position, y = o.attributes.normal, l = 0, p = 0, f = v.count; p < f; p++)t.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(r), e.set(y.getX(p), y.getY(p), y.getZ(p)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), a.setXYZ(l, t.x, t.y, t.z), l += 1, a.setXYZ(l, e.x, e.y, e.z), l += 1;
                return a.needsUpdate = !0, this
            }
        }(), Vi.prototype = Object.create(ct.prototype), Vi.prototype.constructor = Vi, Vi.prototype.dispose = function () {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, Vi.prototype.update = function () {
            var t = new c, e = new c;
            return function () {
                var n = this.light.distance ? this.light.distance : 1e3, i = n * Math.tan(this.light.angle);
                this.cone.scale.set(i, i, n), t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e.sub(t)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }
        }(), ji.prototype = Object.create(ye.prototype), ji.prototype.constructor = ji, ji.prototype.getBoneList = function (t) {
            var e = [];
            t && t.isBone && e.push(t);
            for (var n = 0; n < t.children.length; n++)e.push.apply(e, this.getBoneList(t.children[n]));
            return e
        }, ji.prototype.update = function () {
            var t = new c, e = new l, n = new l;
            return function () {
                var i = this.geometry, r = i.getAttribute("position");
                n.getInverse(this.root.matrixWorld);
                for (var a = 0, o = 0; a < this.bones.length; a++) {
                    var s = this.bones[a];
                    s.parent && s.parent.isBone && (e.multiplyMatrices(n, s.matrixWorld), t.setFromMatrixPosition(e), r.setXYZ(o, t.x, t.y, t.z), e.multiplyMatrices(n, s.parent.matrixWorld), t.setFromMatrixPosition(e), r.setXYZ(o + 1, t.x, t.y, t.z), o += 2)
                }
                i.getAttribute("position").needsUpdate = !0
            }
        }(), Wi.prototype = Object.create(At.prototype), Wi.prototype.constructor = Wi, Wi.prototype.dispose = function () {
            this.geometry.dispose(), this.material.dispose()
        }, Wi.prototype.update = function () {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }, Xi.prototype = Object.create(ct.prototype), Xi.prototype.constructor = Xi, Xi.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose(), this.children[1].geometry.dispose(), this.children[1].material.dispose()
        }, Xi.prototype.update = function () {
            var t = new c, e = new c;
            return function () {
                var n = this.children[0], i = this.children[1];
                if (this.light.target) {
                    t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld);
                    var r = e.clone().sub(t);
                    n.lookAt(r), i.lookAt(r)
                }
                n.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), i.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                var a = .5 * this.light.width, o = .5 * this.light.height, s = n.geometry.getAttribute("position"), c = s.array;
                c[0] = a, c[1] = -o, c[2] = 0, c[3] = a, c[4] = o, c[5] = 0, c[6] = -a, c[7] = o, c[8] = 0, c[9] = -a, c[10] = o, c[11] = 0, c[12] = -a, c[13] = -o, c[14] = 0, c[15] = a, c[16] = -o, c[17] = 0, s.needsUpdate = !0
            }
        }(), Yi.prototype = Object.create(ct.prototype), Yi.prototype.constructor = Yi, Yi.prototype.dispose = function () {
            this.children[0].geometry.dispose(), this.children[0].material.dispose()
        }, Yi.prototype.update = function () {
            var t = new c, e = new W, n = new W;
            return function () {
                var i = this.children[0], r = i.geometry.getAttribute("color");
                e.copy(this.light.color).multiplyScalar(this.light.intensity), n.copy(this.light.groundColor).multiplyScalar(this.light.intensity);
                for (var a = 0, o = r.count; a < o; a++) {
                    var s = a < o / 2 ? e : n;
                    r.setXYZ(a, s.r, s.g, s.b)
                }
                i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()), r.needsUpdate = !0
            }
        }(), qi.prototype = Object.create(ye.prototype), qi.prototype.constructor = qi, Zi.prototype = Object.create(ye.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(ye.prototype), Ji.prototype.constructor = Ji, Ji.prototype.update = function () {
            var t = new c, e = new c, n = new et;
            return function () {
                this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = a.faces, c = 0, l = 0, u = s.length; l < u; l++) {
                    var h = s[l], d = h.normal;
                    t.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(i), e.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1
                }
                return r.needsUpdate = !0, this
            }
        }(), Qi.prototype = Object.create(ct.prototype), Qi.prototype.constructor = Qi, Qi.prototype.dispose = function () {
            var t = this.children[0], e = this.children[1];
            t.geometry.dispose(), t.material.dispose(), e.geometry.dispose(), e.material.dispose()
        }, Qi.prototype.update = function () {
            var t = new c, e = new c, n = new c;
            return function () {
                t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t);
                var i = this.children[0], r = this.children[1];
                i.lookAt(n), i.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), r.lookAt(n), r.scale.z = n.length()
            }
        }(), Ki.prototype = Object.create(ye.prototype), Ki.prototype.constructor = Ki, Ki.prototype.update = function () {
            function t(t, a, o, s) {
                i.set(a, o, s).unproject(r);
                var c = n[t];
                if (void 0 !== c)for (var l = e.getAttribute("position"), u = 0, h = c.length; u < h; u++)l.setXYZ(c[u], i.x, i.y, i.z)
            }

            var e, n, i = new c, r = new Ct;
            return function () {
                e = this.geometry, n = this.pointMap;
                var i = 1, a = 1;
                r.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -i, -a, -1), t("n2", i, -a, -1), t("n3", -i, a, -1), t("n4", i, a, -1), t("f1", -i, -a, 1), t("f2", i, -a, 1), t("f3", -i, a, 1), t("f4", i, a, 1), t("u1", .7 * i, 1.1 * a, -1), t("u2", .7 * -i, 1.1 * a, -1), t("u3", 0, 2 * a, -1), t("cf1", -i, 0, 1), t("cf2", i, 0, 1), t("cf3", 0, -a, 1), t("cf4", 0, a, 1), t("cn1", -i, 0, -1), t("cn2", i, 0, -1), t("cn3", 0, -a, -1), t("cn4", 0, a, -1), e.getAttribute("position").needsUpdate = !0
            }
        }(), $i.prototype = Object.create(ye.prototype), $i.prototype.constructor = $i, $i.prototype.update = function () {
            var t = new $;
            return function (e) {
                if (e && e.isBox3 ? t.copy(e) : t.setFromObject(e), !t.isEmpty()) {
                    var n = t.min, i = t.max, r = this.geometry.attributes.position, a = r.array;
                    a[0] = i.x, a[1] = i.y, a[2] = i.z, a[3] = n.x, a[4] = i.y, a[5] = i.z, a[6] = n.x, a[7] = n.y, a[8] = i.z, a[9] = i.x, a[10] = n.y, a[11] = i.z, a[12] = i.x, a[13] = i.y, a[14] = n.z, a[15] = n.x, a[16] = i.y, a[17] = n.z, a[18] = n.x, a[19] = n.y, a[20] = n.z, a[21] = i.x, a[22] = n.y, a[23] = n.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }();
        var Ml = new St;
        Ml.addAttribute("position", new bt([0, 0, 0, 0, 1, 0], 3));
        var El = new rn(0, .5, 1, 5, 1);
        El.translate(0, -.5, 0), tr.prototype = Object.create(ct.prototype), tr.prototype.constructor = tr, tr.prototype.setDirection = function () {
            var t, e = new c;
            return function (n) {
                n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
            }
        }(), tr.prototype.setLength = function (t, e, n) {
            void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
        }, tr.prototype.setColor = function (t) {
            this.line.material.color.copy(t), this.cone.material.color.copy(t)
        }, er.prototype = Object.create(ye.prototype), er.prototype.constructor = er;
        var Tl = function () {
            function t() {
            }

            var e = new c, n = new t, i = new t, r = new t;
            return t.prototype.init = function (t, e, n, i) {
                this.c0 = t, this.c1 = n, this.c2 = -3 * t + 3 * e - 2 * n - i, this.c3 = 2 * t - 2 * e + n + i
            }, t.prototype.initNonuniformCatmullRom = function (t, e, n, i, r, a, o) {
                var s = (e - t) / r - (n - t) / (r + a) + (n - e) / a, c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
                s *= a, c *= a, this.init(e, n, s, c)
            }, t.prototype.initCatmullRom = function (t, e, n, i, r) {
                this.init(e, n, r * (n - t), r * (i - e))
            }, t.prototype.calc = function (t) {
                var e = t * t, n = e * t;
                return this.c0 + this.c1 * t + this.c2 * e + this.c3 * n
            }, ni.create(function (t) {
                this.points = t || [], this.closed = !1
            }, function (t) {
                var a, o, s, l, u = this.points;
                l = u.length, l < 2 && console.log("duh, you need at least 2 points"), a = (l - (this.closed ? 0 : 1)) * t, o = Math.floor(a), s = a - o, this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / u.length) + 1) * u.length : 0 === s && o === l - 1 && (o = l - 2, s = 1);
                var h, d, p, f;
                if (this.closed || o > 0 ? h = u[(o - 1) % l] : (e.subVectors(u[0], u[1]).add(u[0]), h = e), d = u[o % l], p = u[(o + 1) % l], this.closed || o + 2 < l ? f = u[(o + 2) % l] : (e.subVectors(u[l - 1], u[l - 2]).add(u[l - 1]), f = e), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                    var m = "chordal" === this.type ? .5 : .25, g = Math.pow(h.distanceToSquared(d), m), v = Math.pow(d.distanceToSquared(p), m), y = Math.pow(p.distanceToSquared(f), m);
                    v < 1e-4 && (v = 1), g < 1e-4 && (g = v), y < 1e-4 && (y = v), n.initNonuniformCatmullRom(h.x, d.x, p.x, f.x, g, v, y), i.initNonuniformCatmullRom(h.y, d.y, p.y, f.y, g, v, y), r.initNonuniformCatmullRom(h.z, d.z, p.z, f.z, g, v, y)
                } else if ("catmullrom" === this.type) {
                    var _ = void 0 !== this.tension ? this.tension : .5;
                    n.initCatmullRom(h.x, d.x, p.x, f.x, _), i.initCatmullRom(h.y, d.y, p.y, f.y, _), r.initCatmullRom(h.z, d.z, p.z, f.z, _)
                }
                var x = new c(n.calc(s), i.calc(s), r.calc(s));
                return x
            })
        }(), Sl = ni.create(function (t) {
            console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), this.points = void 0 === t ? [] : t
        }, function (t) {
            var e = this.points, n = (e.length - 1) * t, i = Math.floor(n), r = n - i, a = e[0 == i ? i : i - 1], o = e[i], s = e[i > e.length - 2 ? e.length - 1 : i + 1], l = e[i > e.length - 3 ? e.length - 1 : i + 2], u = _l.interpolate;
            return new c(u(a.x, o.x, s.x, l.x, r), u(a.y, o.y, s.y, l.y, r), u(a.z, o.z, s.z, l.z, r))
        }), Al = ni.create(function (t, e, n, i) {
            this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
        }, function (t) {
            var e = hl.b3;
            return new c(e(t, this.v0.x, this.v1.x, this.v2.x, this.v3.x), e(t, this.v0.y, this.v1.y, this.v2.y, this.v3.y), e(t, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
        }), Ll = ni.create(function (t, e, n) {
            this.v0 = t, this.v1 = e, this.v2 = n
        }, function (t) {
            var e = hl.b2;
            return new c(e(t, this.v0.x, this.v1.x, this.v2.x), e(t, this.v0.y, this.v1.y, this.v2.y), e(t, this.v0.z, this.v1.z, this.v2.z))
        }), Rl = ni.create(function (t, e) {
            this.v1 = t, this.v2 = e
        }, function (t) {
            if (1 === t)return this.v2.clone();
            var e = new c;
            return e.subVectors(this.v2, this.v1), e.multiplyScalar(t), e.add(this.v1), e
        });
        nr.prototype = Object.create(ai.prototype), nr.prototype.constructor = nr;
        var Cl = {
            createMultiMaterialObject: function (t, e) {
                for (var n = new be, i = 0, r = e.length; i < r; i++)n.add(new At(t, e[i]));
                return n
            }, detach: function (t, e, n) {
                t.applyMatrix(e.matrixWorld), e.remove(t), n.add(t)
            }, attach: function (t, e, n) {
                var i = new l;
                i.getInverse(n.matrixWorld), t.applyMatrix(i), e.remove(t), n.add(t)
            }
        }, Pl = 0, Ol = 1;
        wr.prototype = Object.create(Tl.prototype), qi.prototype.setColors = function () {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, Object.assign(Y.prototype, {
            center: function (t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, empty: function () {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, isIntersectionBox: function (t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, size: function (t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), Object.assign($.prototype, {
            center: function (t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, empty: function () {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, isIntersectionBox: function (t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, isIntersectionSphere: function (t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, size: function (t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }
        }), lt.prototype.center = function (t) {
            return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, Qo.random16 = function () {
            return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
        }, Object.assign(et.prototype, {
            flattenToArrayOffset: function (t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, multiplyVector3: function (t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, multiplyVector3Array: function (t) {
                return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
            }, applyToBuffer: function (t, e, n) {
                return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            }
        }), Object.assign(l.prototype, {
            extractPosition: function (t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            }, flattenToArrayOffset: function (t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, getPosition: function () {
                var t;
                return function () {
                    return void 0 === t && (t = new c), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                }
            }(), setRotationFromQuaternion: function (t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            }, multiplyVector3: function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), t.applyProjection(this)
            }, multiplyVector4: function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, multiplyVector3Array: function (t) {
                return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(t)
            }, rotateAxis: function (t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            }, crossVector: function (t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, translate: function () {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, rotateX: function () {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, rotateY: function () {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, rotateZ: function () {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, rotateByAxis: function () {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, applyToBuffer: function (t, e, n) {
                return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
            }
        }), nt.prototype.isIntersectionLine = function (t) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
        }, s.prototype.multiplyVector3 = function (t) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
        }, Object.assign(at.prototype, {
            isIntersectionBox: function (t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, isIntersectionPlane: function (t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            }, isIntersectionSphere: function (t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }
        }), Object.assign(li.prototype, {
            extrude: function (t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new We(this, t)
            }, makeGeometry: function (t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new en(this, t)
            }
        }), Object.assign(c.prototype, {
            setEulerFromRotationMatrix: function () {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, setEulerFromQuaternion: function () {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, getPositionFromMatrix: function (t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            }, getScaleFromMatrix: function (t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            }, getColumnFromMatrix: function (t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            }
        }), Et.prototype.computeTangents = function () {
            console.warn("THREE.Geometry: .computeTangents() has been removed.")
        }, Object.assign(ct.prototype, {
            getChildByName: function (t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            }, renderDepth: function () {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, translate: function (t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }
        }), Object.defineProperties(ct.prototype, {
            eulerOrder: {
                get: function () {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                }, set: function (t) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                }
            }, useQuaternion: {
                get: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }, set: function () {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(de.prototype, {
            objects: {
                get: function () {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), Pt.prototype.setLens = function (t, e) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
        }, Object.defineProperties(Ln.prototype, {
            onlyShadow: {
                set: function () {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            }, shadowCameraFov: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                }
            }, shadowCameraLeft: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                }
            }, shadowCameraRight: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                }
            }, shadowCameraTop: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                }
            }, shadowCameraBottom: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                }
            }, shadowCameraNear: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                }
            }, shadowCameraFar: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                }
            }, shadowCameraVisible: {
                set: function () {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            }, shadowBias: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                }
            }, shadowDarkness: {
                set: function () {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            }, shadowMapWidth: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                }
            }, shadowMapHeight: {
                set: function (t) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                }
            }
        }), Object.defineProperties(pt.prototype, {
            length: {
                get: function () {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                }
            }
        }), Object.assign(St.prototype, {
            addIndex: function (t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            }, addDrawCall: function (t, e, n) {
                void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            }, clearDrawCalls: function () {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, computeTangents: function () {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            }, computeOffsets: function () {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(St.prototype, {
            drawcalls: {
                get: function () {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            }, offsets: {
                get: function () {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(Ai.prototype, {
            dynamic: {
                set: function () {
                    console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                }
            }, onUpdate: {
                value: function () {
                    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                }
            }
        }), Object.defineProperties(J.prototype, {
            wrapAround: {
                get: function () {
                    console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                }, set: function () {
                    console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                }
            }, wrapRGB: {
                get: function () {
                    return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new W
                }
            }
        }), Object.defineProperties(gn.prototype, {
            metal: {
                get: function () {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                }, set: function () {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(Q.prototype, {
            derivatives: {
                get: function () {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                }, set: function (t) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                }
            }
        }), e.prototype = Object.assign(Object.create({
            constructor: e, apply: function (t) {
                console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."), Object.assign(t, this)
            }
        }), e.prototype), Object.assign(ae.prototype, {
            supportsFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, supportsHalfFloatTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, supportsStandardDerivatives: function () {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, supportsCompressedTextureS3TC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, supportsCompressedTexturePVRTC: function () {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, supportsBlendMinMax: function () {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, supportsVertexTextures: function () {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, supportsInstancedArrays: function () {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, enableScissorTest: function (t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            }, initMaterial: function () {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, addPrePlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, addPostPlugin: function () {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, updateShadowMap: function () {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        }), Object.defineProperties(ae.prototype, {
            shadowMapEnabled: {
                get: function () {
                    return this.shadowMap.enabled
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                }
            }, shadowMapType: {
                get: function () {
                    return this.shadowMap.type
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                }
            }, shadowMapCullFace: {
                get: function () {
                    return this.shadowMap.cullFace
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = t
                }
            }
        }), Object.defineProperties(rt.prototype, {
            cullFace: {
                get: function () {
                    return this.renderReverseSided ? Ir : Or
                }, set: function (t) {
                    var e = t !== Or;
                    console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + e + "."), this.renderReverseSided = e
                }
            }
        }), Object.defineProperties(a.prototype, {
            wrapS: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                }
            }, wrapT: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                }
            }, magFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                }
            }, minFilter: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                }
            }, anisotropy: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                }
            }, offset: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                }
            }, repeat: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                }
            }, format: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                }
            }, type: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                }
            }, generateMipmaps: {
                get: function () {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                }, set: function (t) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                }
            }
        }), _i.prototype.load = function (t) {
            console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
            var e = this, n = new fi;
            return n.load(t, function (t) {
                e.setBuffer(t)
            }), this
        }, bi.prototype.getData = function () {
            return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
        };
        var Il = {
            merge: function (t, e, n) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var i;
                e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), i = e.matrix, e = e.geometry), t.merge(e, i, n)
            }, center: function (t) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
            }
        }, Ul = {
            crossOrigin: void 0, loadTexture: function (t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new An;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(t, n, void 0, i);
                return e && (a.mapping = e), a
            }, loadTextureCube: function (t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Sn;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(t, n, void 0, i);
                return e && (a.mapping = e), a
            }, loadCompressedTexture: function () {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, loadCompressedTextureCube: function () {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        };
        t.WebGLRenderTargetCube = o, t.WebGLRenderTarget = a, t.WebGLRenderer = ae, t.ShaderLib = ol, t.UniformsLib = al, t.UniformsUtils = rs, t.ShaderChunk = il, t.FogExp2 = oe, t.Fog = se, t.Scene = ce, t.LensFlare = le, t.Sprite = he, t.LOD = de, t.SkinnedMesh = me, t.Skeleton = pe, t.Bone = fe, t.Mesh = At, t.LineSegments = ye, t.Line = ve, t.Points = xe, t.Group = be, t.VideoTexture = we, t.DataTexture = X, t.CompressedTexture = Me, t.CubeTexture = u, t.CanvasTexture = Ee, t.DepthTexture = Te, t.Texture = i, t.CompressedTextureLoader = Mn, t.BinaryTextureLoader = En, t.DataTextureLoader = gl, t.CubeTextureLoader = Sn, t.TextureLoader = An, t.ObjectLoader = ei, t.MaterialLoader = Qn, t.BufferGeometryLoader = Kn, t.DefaultLoadingManager = ml, t.LoadingManager = bn, t.JSONLoader = ti, t.ImageLoader = Tn, t.FontLoader = pi, t.FileLoader = wn, t.Loader = $n, t.Cache = fl, t.AudioLoader = fi, t.SpotLightShadow = Pn, t.SpotLight = On, t.PointLight = In, t.RectAreaLight = mi, t.HemisphereLight = Rn, t.DirectionalLightShadow = Un, t.DirectionalLight = Nn, t.AmbientLight = Dn, t.LightShadow = Cn, t.Light = Ln, t.StereoCamera = gi, t.PerspectiveCamera = Pt, t.OrthographicCamera = Ot, t.CubeCamera = vi, t.Camera = Ct, t.AudioListener = yi, t.PositionalAudio = xi, t.AudioContext = wl, t.AudioAnalyser = bi, t.Audio = _i, t.VectorKeyframeTrack = Hn, t.StringKeyframeTrack = Xn, t.QuaternionKeyframeTrack = jn, t.NumberKeyframeTrack = Wn, t.ColorKeyframeTrack = qn, t.BooleanKeyframeTrack = Yn, t.PropertyMixer = wi, t.PropertyBinding = Mi, t.KeyframeTrack = Zn, t.AnimationUtils = vl, t.AnimationObjectGroup = Ei, t.AnimationMixer = Si, t.AnimationClip = Jn, t.Uniform = Ai, t.InstancedBufferGeometry = Li, t.BufferGeometry = St, t.GeometryIdCount = Tt, t.Geometry = Et, t.InterleavedBufferAttribute = Ri, t.InstancedInterleavedBuffer = Pi, t.InterleavedBuffer = Ci, t.InstancedBufferAttribute = Oi, t.Face3 = ht, t.Object3D = ct, t.Raycaster = Ii, t.Layers = st, t.EventDispatcher = e, t.Clock = Di, t.QuaternionLinearInterpolant = Vn, t.LinearInterpolant = zn, t.DiscreteInterpolant = Gn, t.CubicInterpolant = Bn, t.Interpolant = Fn, t.Triangle = ut, t.Spline = Fi, t.Math = Qo,t.Spherical = Bi,t.Cylindrical = zi,t.Plane = nt,t.Frustum = it,t.Sphere = tt,t.Ray = at,t.Matrix4 = l,t.Matrix3 = et,t.Box3 = $,t.Box2 = Y,t.Line3 = lt,t.Euler = ot,t.Vector4 = r,t.Vector3 = c,t.Vector2 = n,t.Quaternion = s,t.Color = W,t.MorphBlendMesh = Gi,t.ImmediateRenderObject = ki,t.VertexNormalsHelper = Hi,t.SpotLightHelper = Vi,t.SkeletonHelper = ji,t.PointLightHelper = Wi,t.RectAreaLightHelper = Xi,t.HemisphereLightHelper = Yi,t.GridHelper = qi,t.PolarGridHelper = Zi,t.FaceNormalsHelper = Ji,t.DirectionalLightHelper = Qi,t.CameraHelper = Ki,t.BoxHelper = $i,t.ArrowHelper = tr,t.AxisHelper = er,t.CatmullRomCurve3 = Tl,t.SplineCurve3 = Sl,t.CubicBezierCurve3 = Al,t.QuadraticBezierCurve3 = Ll,t.LineCurve3 = Rl,t.ArcCurve = nr,t.EllipseCurve = ai,t.SplineCurve = oi,t.CubicBezierCurve = si,t.QuadraticBezierCurve = ci,t.LineCurve = ii,t.Shape = li,t.ShapePath = hi,t.Path = ui,t.Font = di,t.CurvePath = ri,t.Curve = ni,t.ShapeUtils = hl,t.SceneUtils = Cl,t.CurveUtils = _l,t.WireframeGeometry = Se,t.ParametricGeometry = Le,t.ParametricBufferGeometry = Ae,t.TetrahedronGeometry = Pe,t.TetrahedronBufferGeometry = Ce,t.OctahedronGeometry = Ie,t.OctahedronBufferGeometry = Oe,t.IcosahedronGeometry = Ne,t.IcosahedronBufferGeometry = Ue,t.DodecahedronGeometry = Fe,t.DodecahedronBufferGeometry = De,t.PolyhedronGeometry = Be,t.PolyhedronBufferGeometry = Re,t.TubeGeometry = Ge,t.TubeBufferGeometry = ze,t.TorusKnotGeometry = He,t.TorusKnotBufferGeometry = ke,t.TorusGeometry = je,t.TorusBufferGeometry = Ve,t.TextGeometry = Xe,t.SphereBufferGeometry = Ye,t.SphereGeometry = qe,t.RingGeometry = Je,t.RingBufferGeometry = Ze,t.PlaneBufferGeometry = Rt,t.PlaneGeometry = Qe,t.LatheGeometry = $e,t.LatheBufferGeometry = Ke,t.ShapeGeometry = en,t.ShapeBufferGeometry = tn,t.ExtrudeGeometry = We,t.EdgesGeometry = nn,t.ConeGeometry = on,t.ConeBufferGeometry = sn,t.CylinderGeometry = an,t.CylinderBufferGeometry = rn,t.CircleBufferGeometry = cn,t.CircleGeometry = ln,t.BoxBufferGeometry = Lt,t.BoxGeometry = un,t.ShadowMaterial = hn,t.SpriteMaterial = ue,t.RawShaderMaterial = dn,t.ShaderMaterial = Q,t.PointsMaterial = _e,t.MultiMaterial = pn;
        t.MeshPhysicalMaterial = mn;
        t.MeshStandardMaterial = fn, t.MeshPhongMaterial = gn, t.MeshToonMaterial = vn, t.MeshNormalMaterial = yn, t.MeshLambertMaterial = _n, t.MeshDepthMaterial = K, t.MeshBasicMaterial = dt, t.LineDashedMaterial = xn, t.LineBasicMaterial = ge, t.Material = J, t.Float64BufferAttribute = wt, t.Float32BufferAttribute = bt, t.Uint32BufferAttribute = xt, t.Int32BufferAttribute = _t, t.Uint16BufferAttribute = yt, t.Int16BufferAttribute = vt, t.Uint8ClampedBufferAttribute = gt, t.Uint8BufferAttribute = mt, t.Int8BufferAttribute = ft, t.BufferAttribute = pt, t.REVISION = Rr, t.MOUSE = Cr, t.CullFaceNone = Pr, t.CullFaceBack = Or, t.CullFaceFront = Ir, t.CullFaceFrontBack = Ur, t.FrontFaceDirectionCW = Nr, t.FrontFaceDirectionCCW = Dr, t.BasicShadowMap = Fr, t.PCFShadowMap = Br, t.PCFSoftShadowMap = zr, t.FrontSide = Gr, t.BackSide = kr, t.DoubleSide = Hr, t.FlatShading = Vr, t.SmoothShading = jr, t.NoColors = Wr, t.FaceColors = Xr, t.VertexColors = Yr, t.NoBlending = qr, t.NormalBlending = Zr, t.AdditiveBlending = Jr, t.SubtractiveBlending = Qr, t.MultiplyBlending = Kr, t.CustomBlending = $r, t.BlendingMode = ta, t.AddEquation = ea, t.SubtractEquation = na, t.ReverseSubtractEquation = ia, t.MinEquation = ra, t.MaxEquation = aa, t.ZeroFactor = oa, t.OneFactor = sa, t.SrcColorFactor = ca, t.OneMinusSrcColorFactor = la, t.SrcAlphaFactor = ua, t.OneMinusSrcAlphaFactor = ha, t.DstAlphaFactor = da, t.OneMinusDstAlphaFactor = pa, t.DstColorFactor = fa, t.OneMinusDstColorFactor = ma, t.SrcAlphaSaturateFactor = ga, t.NeverDepth = va, t.AlwaysDepth = ya, t.LessDepth = _a, t.LessEqualDepth = xa, t.EqualDepth = ba, t.GreaterEqualDepth = wa, t.GreaterDepth = Ma, t.NotEqualDepth = Ea, t.MultiplyOperation = Ta, t.MixOperation = Sa, t.AddOperation = Aa, t.NoToneMapping = La, t.LinearToneMapping = Ra, t.ReinhardToneMapping = Ca, t.Uncharted2ToneMapping = Pa, t.CineonToneMapping = Oa, t.UVMapping = Ia, t.CubeReflectionMapping = Ua, t.CubeRefractionMapping = Na, t.EquirectangularReflectionMapping = Da, t.EquirectangularRefractionMapping = Fa, t.SphericalReflectionMapping = Ba, t.CubeUVReflectionMapping = za, t.CubeUVRefractionMapping = Ga, t.TextureMapping = ka, t.RepeatWrapping = Ha, t.ClampToEdgeWrapping = Va, t.MirroredRepeatWrapping = ja, t.TextureWrapping = Wa, t.NearestFilter = Xa, t.NearestMipMapNearestFilter = Ya, t.NearestMipMapLinearFilter = qa, t.LinearFilter = Za, t.LinearMipMapNearestFilter = Ja, t.LinearMipMapLinearFilter = Qa, t.TextureFilter = Ka, t.UnsignedByteType = $a, t.ByteType = to, t.ShortType = eo,t.UnsignedShortType = no,t.IntType = io,t.UnsignedIntType = ro,t.FloatType = ao,t.HalfFloatType = oo,t.UnsignedShort4444Type = so,t.UnsignedShort5551Type = co,t.UnsignedShort565Type = lo,t.UnsignedInt248Type = uo,t.AlphaFormat = ho,t.RGBFormat = po,t.RGBAFormat = fo,t.LuminanceFormat = mo,t.LuminanceAlphaFormat = go,t.RGBEFormat = vo,t.DepthFormat = yo,t.DepthStencilFormat = _o,t.RGB_S3TC_DXT1_Format = xo,t.RGBA_S3TC_DXT1_Format = bo,t.RGBA_S3TC_DXT3_Format = wo,t.RGBA_S3TC_DXT5_Format = Mo,t.RGB_PVRTC_4BPPV1_Format = Eo,t.RGB_PVRTC_2BPPV1_Format = To,t.RGBA_PVRTC_4BPPV1_Format = So,t.RGBA_PVRTC_2BPPV1_Format = Ao,t.RGB_ETC1_Format = Lo,t.LoopOnce = Ro,t.LoopRepeat = Co,t.LoopPingPong = Po,t.InterpolateDiscrete = Oo,t.InterpolateLinear = Io,t.InterpolateSmooth = Uo,t.ZeroCurvatureEnding = No,t.ZeroSlopeEnding = Do,t.WrapAroundEnding = Fo,t.TrianglesDrawMode = Bo,t.TriangleStripDrawMode = zo,t.TriangleFanDrawMode = Go,t.LinearEncoding = ko,t.sRGBEncoding = Ho,t.GammaEncoding = Vo,t.RGBEEncoding = jo,t.LogLuvEncoding = Wo,t.RGBM7Encoding = Xo,t.RGBM16Encoding = Yo,t.RGBDEncoding = qo,t.BasicDepthPacking = Zo,t.RGBADepthPacking = Jo,t.CubeGeometry = un,t.Face4 = ir,t.LineStrip = Pl,t.LinePieces = Ol,t.MeshFaceMaterial = rr,t.PointCloud = ar,t.Particle = or,t.ParticleSystem = sr,t.PointCloudMaterial = cr,t.ParticleBasicMaterial = lr,t.ParticleSystemMaterial = ur,t.Vertex = hr,t.DynamicBufferAttribute = dr,t.Int8Attribute = pr,t.Uint8Attribute = fr,t.Uint8ClampedAttribute = mr,t.Int16Attribute = gr,t.Uint16Attribute = vr,t.Int32Attribute = yr,t.Uint32Attribute = _r,t.Float32Attribute = xr,t.Float64Attribute = br,t.ClosedSplineCurve3 = wr,t.BoundingBoxHelper = Mr,t.EdgesHelper = Er,t.WireframeHelper = Tr,t.XHRLoader = Sr,t.GeometryUtils = Il,t.ImageUtils = Ul,t.Projector = Ar,t.CanvasRenderer = Lr,Object.defineProperty(t, "__esModule", {value: !0})
    })
}, function (t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = {
        scene: {},
        renderer: {},
        camera: {},
        structure: {}
    }
}, function (t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = {
        user: {gui: !1, orbit: !1, stats: !1},
        camera: {fov: 45, aspect: window.innerWidth / window.innerHeight, near: 1, far: 3500},
        backgroundColor: 15724527,
        mobile: /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
    }
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function r(t) {
        if (t && t.__esModule)return t;
        var e = {};
        if (null != t)for (var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e.default = t, e
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var a = n(2), o = r(a), s = n(3), c = i(s), l = n(4), u = i(l), h = n(6), d = i(h), p = n(7), f = i(p), m = n(8), g = i(m), v = n(9), y = i(v);
    e.default = function () {
        var t = u.default.mobile ? 1e4 : 1e5, e = u.default.mobile ? .2 : .1;
        c.default.structure.blueprint = new y.default(new o.TetrahedronGeometry(e), t), c.default.structure.blueprint.createAttribute("aPositionStart", 3, function (t, e) {
            var n = [0, 0, 15];
            c.default.structure.blueprint.setPrefabData(t, e, n)
        }), c.default.structure.blueprint.createAttribute("aControlPointOne", 3, function (t, e, n) {
            var i = e * (2 * Math.PI / n), r = [n / (n / 20) * Math.cos(i), n / (n / 20) * Math.sin(i), -10];
            c.default.structure.blueprint.setPrefabData(t, e, r)
        }), c.default.structure.blueprint.createAttribute("aControlPointTwo", 3, function (t, e, n) {
            var i = e * (2 * Math.PI / n), r = [n / (n / 20) * Math.cos(i) + (40 * Math.random() - 20), n / (n / 20) * Math.sin(i) + (40 * Math.random() - 20), -20 + (12 * Math.random() - 6)];
            c.default.structure.blueprint.setPrefabData(t, e, r)
        }), c.default.structure.blueprint.createAttribute("aPositionEnd", 3, function (t, e, n) {
            var i = e * (2 * Math.PI / n), r = [n / (n / 20) * Math.cos(i) + (40 * Math.random() - 20), n / (n / 20) * Math.sin(i) + (40 * Math.random() - 20), 32];
            c.default.structure.blueprint.setPrefabData(t, e, r)
        }), c.default.structure.blueprint.createAttribute("aColor", 3, function (t, e, n) {
            var i = new o.Color;
            i.setHSL(e / n, o.Math.randFloat(.4, .6), o.Math.randFloat(.4, .6));
            var r = [i.r, i.g, i.b];
            c.default.structure.blueprint.setPrefabData(t, e, r)
        });
        var n = .6, i = 1 - n, r = t, a = i / (r - 1);
        c.default.structure.blueprint.createAttribute("aOffset", 1, function (t, e) {
            c.default.structure.blueprint.setPrefabData(t, e, [e * a])
        });
        var s = new o.ShaderMaterial({
            uniforms: g.default,
            vertexShader: (0, d.default)("\n      uniform float uProgress;\n      \n      attribute vec3 aPositionStart;\n      attribute vec3 aControlPointOne;\n      attribute vec3 aControlPointTwo;\n      attribute vec3 aPositionEnd;\n      attribute float aOffset;\n      attribute vec3 aColor;\n      varying lowp vec3 sharedColor;\n\n      vec3 bezier4(vec3 a, vec3 b, vec3 c, vec3 d, float t) {\n          return mix(mix(mix(a, b, t), mix(b, c, t), t), mix(mix(b, c, t), mix(c, d, t), t), t);\n      }\n    ", "\n      float tProgress = min(1.0, max(0.0, (uProgress - aOffset)) / 0.6);\n      vec3 newPosition = bezier4(aPositionStart, aControlPointOne, aControlPointTwo, aPositionEnd, tProgress);\n       \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition + position, 1.0);\n      sharedColor = aColor;\n    "),
            fragmentShader: (0, f.default)("\n      uniform vec3 diffuse;\n      uniform vec3 emissive;\n      uniform float roughness;\n      uniform float metalness;\n      uniform float opacity;\n      varying lowp vec3 sharedColor; \n    ", "\n      gl_FragColor = vec4(sharedColor, diffuseColor.a);\n    "),
            lights: !0,
            shading: o.FlatShading,
            vertexColors: o.VertexColors,
            side: o.DoubleSide
        });
        c.default.structure.mesh = new o.Mesh(c.default.structure.blueprint, s), c.default.scene.add(c.default.structure.mesh), c.default.structure.light = new o.AmbientLight(4210752), c.default.scene.add(c.default.structure.light)
    }
}, function (t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = function (t, e) {
        return "\n\n  #define PHYSICAL\n\n  " + t + "\n\n  varying vec3 vViewPosition;\n\n  #ifndef FLAT_SHADED\n    \n    varying vec3 vNormal;\n  \n  #endif\n\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n\n  void main() {\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n\n    #include <beginnormal_vertex>\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n\n    #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n      \n      vNormal = normalize(transformedNormal);\n    \n    #endif\n\n    #include <begin_vertex>\n    #include <displacementmap_vertex>\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n\n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n\n    " + e + "\n\n  }\n\n"
    }
}, function (t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = function (t, e) {
        return "\n  \n  #define PHYSICAL\n\n  " + t + "\n\n  #ifndef STANDARD\n    \n    uniform float clearCoat;\n    uniform float clearCoatRoughness;\n  \n  #endif\n\n  varying vec3 vViewPosition;\n\n  #ifndef FLAT_SHADED\n    \n    varying vec3 vNormal;\n  \n  #endif\n\n  #include <common>\n  #include <packing>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <cube_uv_reflection_fragment>\n  #include <lights_pars>\n  #include <lights_physical_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <roughnessmap_pars_fragment>\n  #include <metalnessmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n\n  void main() {\n\n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4(diffuse, opacity);\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n    vec3 totalEmissiveRadiance = emissive;\n\n    #include <logdepthbuf_fragment>\n    #include <map_fragment>\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <roughnessmap_fragment>\n    #include <metalnessmap_fragment>\n    #include <normal_flip>\n    #include <normal_fragment>\n    #include <emissivemap_fragment>\n\n    // accumulation\n    #include <lights_physical_fragment>\n    #include <lights_template>\n\n    // modulation\n    #include <aomap_fragment>\n\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n    " + e + "\n\n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n\n  }\n\n"
    }
}, function (t, e, n) {
    "use strict";
    function i(t) {
        if (t && t.__esModule)return t;
        var e = {};
        if (null != t)for (var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e.default = t, e
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var r = n(2), a = i(r);
    e.default = a.UniformsUtils.merge([a.ShaderLib.standard.uniforms, {
        metalness: {type: "f", value: .55},
        roughness: {type: "f", value: .15},
        opacity: {type: "f", value: 1},
        diffuse: {type: "c", value: new a.Color(16777215)},
        emissive: {type: "c", value: new a.Color(40140)},
        uProgress: {type: "f", value: 0}
    }])
}, function (t, e, n) {
    "use strict";
    function i(t) {
        if (t && t.__esModule)return t;
        var e = {};
        if (null != t)for (var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e.default = t, e
    }

    function r(t, e) {
        if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
    }

    function a(t, e) {
        if (!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !e || "object" != typeof e && "function" != typeof e ? t : e
    }

    function o(t, e) {
        if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var s = function () {
        function t(t, e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
        }

        return function (e, n, i) {
            return n && t(e.prototype, n), i && t(e, i), e
        }
    }(), c = n(2), l = i(c), u = function (t) {
        function e() {
            var t, n = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            r(this, e);
            var o = a(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this));
            return o.setBaseGeometry(n), o.setBaseGeometryMultiplier(i), o.setBaseGeometryVerticesCount(n.vertices.length), o.setIndexBuffer(), o.setPositionBuffer(), t = o, a(o, t)
        }

        return o(e, t), s(e, [{
            key: "setBaseGeometry", value: function (t) {
                this.baseGeometry = t
            }
        }, {
            key: "getBaseGeometry", value: function () {
                return this.baseGeometry
            }
        }, {
            key: "setBaseGeometryMultiplier", value: function (t) {
                this.baseGeometryMultiplier = t
            }
        }, {
            key: "getBaseGeometryMultiplier", value: function () {
                return this.baseGeometryMultiplier
            }
        }, {
            key: "setBaseGeometryVerticesCount", value: function (t) {
                this.baseGeometryVerticesCount = t
            }
        }, {
            key: "getBaseGeometryVerticesCount", value: function () {
                return this.baseGeometryVerticesCount
            }
        }, {
            key: "setIndexBuffer", value: function () {
                var t = 3 * this.getBaseGeometry().faces.length, e = this.getBaseGeometryVerticesCount(), n = [];
                this.getBaseGeometry().faces.map(function (t) {
                    return n.push(t.a, t.b, t.c)
                });
                for (var i = new Uint32Array(this.getBaseGeometryMultiplier() * t), r = 0, a = this.getBaseGeometryMultiplier(); r < a; r += 1)for (var o = 0, s = t; o < s; o += 1)i[r * t + o] = n[o] + r * e;
                this.setIndex(new l.BufferAttribute(i, 1))
            }
        }, {
            key: "setPositionBuffer", value: function () {
                for (var t = this.createAttribute("position", 3).array, e = 0, n = 0, i = this.getBaseGeometryMultiplier(); n < i; n += 1)for (var r = 0, a = this.getBaseGeometryVerticesCount(); r < a; r += 1, e += 3) {
                    var o = this.getBaseGeometry().vertices[r];
                    t[e] = o.x, t[e + 1] = o.y, t[e + 2] = o.z
                }
            }
        }, {
            key: "createAttribute", value: function (t, e, n) {
                var i = this.getBaseGeometryMultiplier(), r = this.getBaseGeometryVerticesCount(), a = new Float32Array(i * r * e), o = new l.BufferAttribute(a, e);
                if (this.addAttribute(t, o), n)for (var s = 0; s < i; s += 1)n(o, s, i);
                return o
            }
        }, {
            key: "setPrefabData", value: function (t, e, n) {
                for (var i = t, r = e * this.getBaseGeometryVerticesCount() * i.itemSize, a = 0; a < this.getBaseGeometryVerticesCount(); a += 1)for (var o = 0; o < i.itemSize; o += 1)i.array[r] = n[o], r += 1
            }
        }]), e
    }(l.BufferGeometry);
    e.default = u
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var r = n(4), a = i(r), o = n(11), s = i(o), c = n(14), l = i(c), u = n(16), h = i(u);
    e.default = function () {
        a.default.user.gui && (0, s.default)(), a.default.user.orbit && (0, l.default)(), a.default.user.stats && (0, h.default)()
    }
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var r = n(12), a = i(r), o = n(13), s = i(o), c = n(3), l = i(c), u = n(8), h = i(u), d = function () {
        var t = s.default.gui.addFolder("Settings"), e = {devicePixelRatio: window.devicePixelRatio}, n = t.add(e, "devicePixelRatio", .1, window.devicePixelRatio).step(.1).name("Pixel Ratio");
        n.onChange(function () {
            l.default.renderer.setPixelRatio(e.devicePixelRatio)
        })
    }, p = function () {
        var t = s.default.gui.addFolder("Light"), e = {
            light1: l.default.structure.light1.color.getHex(),
            light2: l.default.structure.light2.color.getHex()
        };
        t.add(l.default.structure.light1, "intensity", 0, 5).step(.01).name("Light 1 intensity"), t.addColor(e, "light1").name("Light 1 color").onChange(function (t) {
            l.default.structure.light1.color.setHex(t)
        }), t.add(l.default.structure.light2, "intensity", 0, 5).step(.01).name("Light 2 intensity"), t.addColor(e, "light2").name("Light 2 color").onChange(function (t) {
            l.default.structure.light2.color.setHex(t)
        })
    }, f = function () {
        var t = s.default.gui.addFolder("Uniforms"), e = {emissive: h.default.emissive.value.getHex()};
        t.add(h.default.metalness, "value", 0, 1).step(.01).name("Metalness"), t.add(h.default.roughness, "value", 0, 1).step(.01).name("Roughness"), t.addColor(e, "emissive").onChange(function (t) {
            h.default.emissive.value.setHex(t)
        })
    };
    e.default = function () {
        s.default.gui = new a.default.GUI({width: 340}), d(), p(), f(), s.default.gui.close()
    }
}, function (t, e, n) {
    !function (e, n) {
        t.exports = n()
    }(this, function () {
        return function (t) {
            function e(i) {
                if (n[i])return n[i].exports;
                var r = n[i] = {exports: {}, id: i, loaded: !1};
                return t[i].call(r.exports, r, r.exports, e), r.loaded = !0, r.exports
            }

            var n = {};
            return e.m = t, e.c = n, e.p = "", e(0)
        }([function (t, e, n) {
            "use strict";
            t.exports = n(1)
        }, function (t, e, n) {
            "use strict";
            t.exports = {
                color: {Color: n(2), math: n(6), interpret: n(3)},
                controllers: {
                    Controller: n(7),
                    BooleanController: n(8),
                    OptionController: n(10),
                    StringController: n(11),
                    NumberController: n(12),
                    NumberControllerBox: n(13),
                    NumberControllerSlider: n(14),
                    FunctionController: n(20),
                    ColorController: n(21)
                },
                dom: {dom: n(9)},
                gui: {GUI: n(22)},
                GUI: n(22)
            }
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e, n) {
                Object.defineProperty(t, e, {
                    get: function () {
                        return "RGB" === this.__state.space ? this.__state[e] : (m.recalculateRGB(this, e, n), this.__state[e])
                    }, set: function (t) {
                        "RGB" !== this.__state.space && (m.recalculateRGB(this, e, n), this.__state.space = "RGB"), this.__state[e] = t
                    }
                })
            }

            function o(t, e) {
                Object.defineProperty(t, e, {
                    get: function () {
                        return "HSV" === this.__state.space ? this.__state[e] : (m.recalculateHSV(this), this.__state[e])
                    }, set: function (t) {
                        "HSV" !== this.__state.space && (m.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
                    }
                })
            }

            e.__esModule = !0;
            var s = n(3), c = i(s), l = n(6), u = i(l), h = n(4), d = i(h), p = n(5), f = i(p), m = function () {
                function t() {
                    if (r(this, t), this.__state = c.default.apply(this, arguments), this.__state === !1)throw new Error("Failed to interpret color arguments");
                    this.__state.a = this.__state.a || 1
                }

                return t.prototype.toString = function () {
                    return d.default(this)
                }, t.prototype.toOriginal = function () {
                    return this.__state.conversion.write(this)
                }, t
            }();
            m.recalculateRGB = function (t, e, n) {
                if ("HEX" === t.__state.space)t.__state[e] = u.default.component_from_hex(t.__state.hex, n); else {
                    if ("HSV" !== t.__state.space)throw new Error("Corrupted color state");
                    f.default.extend(t.__state, u.default.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
                }
            }, m.recalculateHSV = function (t) {
                var e = u.default.rgb_to_hsv(t.r, t.g, t.b);
                f.default.extend(t.__state, {
                    s: e.s,
                    v: e.v
                }), f.default.isNaN(e.h) ? f.default.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
            }, m.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], a(m.prototype, "r", 2), a(m.prototype, "g", 1), a(m.prototype, "b", 0), o(m.prototype, "h"), o(m.prototype, "s"), o(m.prototype, "v"), Object.defineProperty(m.prototype, "a", {
                get: function () {
                    return this.__state.a
                }, set: function (t) {
                    this.__state.a = t
                }
            }), Object.defineProperty(m.prototype, "hex", {
                get: function () {
                    return "HEX" !== !this.__state.space && (this.__state.hex = u.default.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
                }, set: function (t) {
                    this.__state.space = "HEX", this.__state.hex = t
                }
            }), e.default = m, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            e.__esModule = !0;
            var r = n(4), a = i(r), o = n(5), s = i(o), c = [{
                litmus: s.default.isString,
                conversions: {
                    THREE_CHAR_HEX: {
                        read: function (t) {
                            var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                            return null !== e && {
                                    space: "HEX",
                                    hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                                }
                        }, write: a.default
                    }, SIX_CHAR_HEX: {
                        read: function (t) {
                            var e = t.match(/^#([A-F0-9]{6})$/i);
                            return null !== e && {space: "HEX", hex: parseInt("0x" + e[1].toString(), 0)}
                        }, write: a.default
                    }, CSS_RGB: {
                        read: function (t) {
                            var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                            return null !== e && {
                                    space: "RGB",
                                    r: parseFloat(e[1]),
                                    g: parseFloat(e[2]),
                                    b: parseFloat(e[3])
                                }
                        }, write: a.default
                    }, CSS_RGBA: {
                        read: function (t) {
                            var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\,\s*(.+)\s*\)/);
                            return null !== e && {
                                    space: "RGB",
                                    r: parseFloat(e[1]),
                                    g: parseFloat(e[2]),
                                    b: parseFloat(e[3]),
                                    a: parseFloat(e[4])
                                }
                        }, write: a.default
                    }
                }
            }, {
                litmus: s.default.isNumber, conversions: {
                    HEX: {
                        read: function (t) {
                            return {space: "HEX", hex: t, conversionName: "HEX"}
                        }, write: function (t) {
                            return t.hex
                        }
                    }
                }
            }, {
                litmus: s.default.isArray, conversions: {
                    RGB_ARRAY: {
                        read: function (t) {
                            return 3 === t.length && {space: "RGB", r: t[0], g: t[1], b: t[2]}
                        }, write: function (t) {
                            return [t.r, t.g, t.b]
                        }
                    }, RGBA_ARRAY: {
                        read: function (t) {
                            return 4 === t.length && {space: "RGB", r: t[0], g: t[1], b: t[2], a: t[3]}
                        }, write: function (t) {
                            return [t.r, t.g, t.b, t.a]
                        }
                    }
                }
            }, {
                litmus: s.default.isObject, conversions: {
                    RGBA_OBJ: {
                        read: function (t) {
                            return !!(s.default.isNumber(t.r) && s.default.isNumber(t.g) && s.default.isNumber(t.b) && s.default.isNumber(t.a)) && {
                                    space: "RGB",
                                    r: t.r,
                                    g: t.g,
                                    b: t.b,
                                    a: t.a
                                }
                        }, write: function (t) {
                            return {r: t.r, g: t.g, b: t.b, a: t.a}
                        }
                    }, RGB_OBJ: {
                        read: function (t) {
                            return !!(s.default.isNumber(t.r) && s.default.isNumber(t.g) && s.default.isNumber(t.b)) && {
                                    space: "RGB",
                                    r: t.r,
                                    g: t.g,
                                    b: t.b
                                }
                        }, write: function (t) {
                            return {r: t.r, g: t.g, b: t.b}
                        }
                    }, HSVA_OBJ: {
                        read: function (t) {
                            return !!(s.default.isNumber(t.h) && s.default.isNumber(t.s) && s.default.isNumber(t.v) && s.default.isNumber(t.a)) && {
                                    space: "HSV",
                                    h: t.h,
                                    s: t.s,
                                    v: t.v,
                                    a: t.a
                                }
                        }, write: function (t) {
                            return {h: t.h, s: t.s, v: t.v, a: t.a}
                        }
                    }, HSV_OBJ: {
                        read: function (t) {
                            return !!(s.default.isNumber(t.h) && s.default.isNumber(t.s) && s.default.isNumber(t.v)) && {
                                    space: "HSV",
                                    h: t.h,
                                    s: t.s,
                                    v: t.v
                                }
                        }, write: function (t) {
                            return {h: t.h, s: t.s, v: t.v}
                        }
                    }
                }
            }], l = void 0, u = void 0, h = function () {
                u = !1;
                var t = arguments.length > 1 ? s.default.toArray(arguments) : arguments[0];
                return s.default.each(c, function (e) {
                    if (e.litmus(t))return s.default.each(e.conversions, function (e, n) {
                        if (l = e.read(t), u === !1 && l !== !1)return u = l, l.conversionName = n, l.conversion = e, s.default.BREAK
                    }), s.default.BREAK
                }), u
            };
            e.default = h, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            e.__esModule = !0;
            var r = n(5), a = i(r);
            e.default = function (t) {
                if (1 === t.a || a.default.isUndefined(t.a)) {
                    for (var e = t.hex.toString(16); e.length < 6;)e = "0" + e;
                    return "#" + e
                }
                return "rgba(" + Math.round(t.r) + "," + Math.round(t.g) + "," + Math.round(t.b) + "," + t.a + ")"
            }, t.exports = e.default
        }, function (t, e) {
            "use strict";
            e.__esModule = !0;
            var n = Array.prototype.forEach, i = Array.prototype.slice, r = {
                BREAK: {}, extend: function (t) {
                    return this.each(i.call(arguments, 1), function (e) {
                        for (var n in e)this.isUndefined(e[n]) || (t[n] = e[n])
                    }, this), t
                }, defaults: function (t) {
                    return this.each(i.call(arguments, 1), function (e) {
                        for (var n in e)this.isUndefined(t[n]) && (t[n] = e[n])
                    }, this), t
                }, compose: function () {
                    var t = i.call(arguments);
                    return function () {
                        for (var e = i.call(arguments), n = t.length - 1; n >= 0; n--)e = [t[n].apply(this, e)];
                        return e[0]
                    }
                }, each: function (t, e, i) {
                    if (t)if (n && t.forEach && t.forEach === n)t.forEach(e, i); else if (t.length === t.length + 0) {
                        var r = void 0, a = void 0;
                        for (r = 0, a = t.length; r < a; r++)if (r in t && e.call(i, t[r], r) === this.BREAK)return
                    } else for (var r in t)if (e.call(i, t[r], r) === this.BREAK)return
                }, defer: function (t) {
                    setTimeout(t, 0)
                }, toArray: function (t) {
                    return t.toArray ? t.toArray() : i.call(t)
                }, isUndefined: function (t) {
                    return void 0 === t
                }, isNull: function (t) {
                    return null === t
                }, isNaN: function (t) {
                    function e(e) {
                        return t.apply(this, arguments)
                    }

                    return e.toString = function () {
                        return t.toString()
                    }, e
                }(function (t) {
                    return isNaN(t)
                }), isArray: Array.isArray || function (t) {
                    return t.constructor === Array
                }, isObject: function (t) {
                    return t === Object(t)
                }, isNumber: function (t) {
                    return t === t + 0
                }, isString: function (t) {
                    return t === t + ""
                }, isBoolean: function (t) {
                    return t === !1 || t === !0
                }, isFunction: function (t) {
                    return "[object Function]" === Object.prototype.toString.call(t)
                }
            };
            e.default = r, t.exports = e.default
        }, function (t, e) {
            "use strict";
            e.__esModule = !0;
            var n = void 0, i = {
                hsv_to_rgb: function (t, e, n) {
                    var i = Math.floor(t / 60) % 6, r = t / 60 - Math.floor(t / 60), a = n * (1 - e), o = n * (1 - r * e), s = n * (1 - (1 - r) * e), c = [[n, s, a], [o, n, a], [a, n, s], [a, o, n], [s, a, n], [n, a, o]][i];
                    return {r: 255 * c[0], g: 255 * c[1], b: 255 * c[2]}
                }, rgb_to_hsv: function (t, e, n) {
                    var i = Math.min(t, e, n), r = Math.max(t, e, n), a = r - i, o = void 0, s = void 0;
                    return 0 === r ? {
                        h: NaN,
                        s: 0,
                        v: 0
                    } : (s = a / r, o = t === r ? (e - n) / a : e === r ? 2 + (n - t) / a : 4 + (t - e) / a, o /= 6, o < 0 && (o += 1), {
                        h: 360 * o,
                        s: s,
                        v: r / 255
                    })
                }, rgb_to_hex: function (t, e, n) {
                    var i = this.hex_with_component(0, 2, t);
                    return i = this.hex_with_component(i, 1, e), i = this.hex_with_component(i, 0, n)
                }, component_from_hex: function (t, e) {
                    return t >> 8 * e & 255
                }, hex_with_component: function (t, e, i) {
                    return i << (n = 8 * e) | t & ~(255 << n)
                }
            };
            e.default = i, t.exports = e.default
        }, function (t, e) {
            "use strict";
            function n(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            e.__esModule = !0;
            var i = function () {
                function t(e, i) {
                    n(this, t),
                        this.initialValue = e[i], this.domElement = document.createElement("div"), this.object = e, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0
                }

                return t.prototype.onChange = function (t) {
                    return this.__onChange = t, this
                }, t.prototype.onFinishChange = function (t) {
                    return this.__onFinishChange = t, this
                }, t.prototype.setValue = function (t) {
                    return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                }, t.prototype.getValue = function () {
                    return this.object[this.property]
                }, t.prototype.updateDisplay = function () {
                    return this
                }, t.prototype.isModified = function () {
                    return this.initialValue !== this.getValue()
                }, t
            }();
            e.default = i, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            e.__esModule = !0;
            var o = n(7), s = i(o), c = n(9), l = i(c), u = function (t) {
                function e(n, i) {
                    function a() {
                        o.setValue(!o.__prev)
                    }

                    r(this, e), t.call(this, n, i);
                    var o = this;
                    this.__prev = this.getValue(), this.__checkbox = document.createElement("input"), this.__checkbox.setAttribute("type", "checkbox"), l.default.bind(this.__checkbox, "change", a, !1), this.domElement.appendChild(this.__checkbox), this.updateDisplay()
                }

                return a(e, t), e.prototype.setValue = function (e) {
                    var n = t.prototype.setValue.call(this, e);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), n
                }, e.prototype.updateDisplay = function () {
                    return this.getValue() === !0 ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0) : this.__checkbox.checked = !1, t.prototype.updateDisplay.call(this)
                }, e
            }(s.default);
            e.default = u, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t) {
                if ("0" === t || o.default.isUndefined(t))return 0;
                var e = t.match(l);
                return o.default.isNull(e) ? 0 : parseFloat(e[1])
            }

            e.__esModule = !0;
            var a = n(5), o = i(a), s = {
                HTMLEvents: ["change"],
                MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
                KeyboardEvents: ["keydown"]
            }, c = {};
            o.default.each(s, function (t, e) {
                o.default.each(t, function (t) {
                    c[t] = e
                })
            });
            var l = /(\d+(\.\d+)?)px/, u = {
                makeSelectable: function (t, e) {
                    void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function () {
                        return !1
                    } : function () {
                    }, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
                }, makeFullscreen: function (t, e, n) {
                    var i = n, r = e;
                    o.default.isUndefined(r) && (r = !0), o.default.isUndefined(i) && (i = !0), t.style.position = "absolute", r && (t.style.left = 0, t.style.right = 0), i && (t.style.top = 0, t.style.bottom = 0)
                }, fakeEvent: function (t, e, n, i) {
                    var r = n || {}, a = c[e];
                    if (!a)throw new Error("Event type " + e + " not supported.");
                    var s = document.createEvent(a);
                    switch (a) {
                        case"MouseEvents":
                            var l = r.x || r.clientX || 0, u = r.y || r.clientY || 0;
                            s.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, l, u, !1, !1, !1, !1, 0, null);
                            break;
                        case"KeyboardEvents":
                            var h = s.initKeyboardEvent || s.initKeyEvent;
                            o.default.defaults(r, {
                                cancelable: !0,
                                ctrlKey: !1,
                                altKey: !1,
                                shiftKey: !1,
                                metaKey: !1,
                                keyCode: void 0,
                                charCode: void 0
                            }), h(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                            break;
                        default:
                            s.initEvent(e, r.bubbles || !1, r.cancelable || !0)
                    }
                    o.default.defaults(s, i), t.dispatchEvent(s)
                }, bind: function (t, e, n, i) {
                    var r = i || !1;
                    return t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on" + e, n), u
                }, unbind: function (t, e, n, i) {
                    var r = i || !1;
                    return t.removeEventListener ? t.removeEventListener(e, n, r) : t.detachEvent && t.detachEvent("on" + e, n), u
                }, addClass: function (t, e) {
                    if (void 0 === t.className)t.className = e; else if (t.className !== e) {
                        var n = t.className.split(/ +/);
                        n.indexOf(e) === -1 && (n.push(e), t.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                    }
                    return u
                }, removeClass: function (t, e) {
                    if (e)if (t.className === e)t.removeAttribute("class"); else {
                        var n = t.className.split(/ +/), i = n.indexOf(e);
                        i !== -1 && (n.splice(i, 1), t.className = n.join(" "))
                    } else t.className = void 0;
                    return u
                }, hasClass: function (t, e) {
                    return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
                }, getWidth: function (t) {
                    var e = getComputedStyle(t);
                    return r(e["border-left-width"]) + r(e["border-right-width"]) + r(e["padding-left"]) + r(e["padding-right"]) + r(e.width)
                }, getHeight: function (t) {
                    var e = getComputedStyle(t);
                    return r(e["border-top-width"]) + r(e["border-bottom-width"]) + r(e["padding-top"]) + r(e["padding-bottom"]) + r(e.height)
                }, getOffset: function (t) {
                    var e = t, n = {left: 0, top: 0};
                    if (e.offsetParent)do n.left += e.offsetLeft, n.top += e.offsetTop, e = e.offsetParent; while (e);
                    return n
                }, isActive: function (t) {
                    return t === document.activeElement && (t.type || t.href)
                }
            };
            e.default = u, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            e.__esModule = !0;
            var o = n(7), s = i(o), c = n(9), l = i(c), u = n(5), h = i(u), d = function (t) {
                function e(n, i, a) {
                    r(this, e), t.call(this, n, i);
                    var o = a, s = this;
                    this.__select = document.createElement("select"), h.default.isArray(o) && !function () {
                        var t = {};
                        h.default.each(o, function (e) {
                            t[e] = e
                        }), o = t
                    }(), h.default.each(o, function (t, e) {
                        var n = document.createElement("option");
                        n.innerHTML = e, n.setAttribute("value", t), s.__select.appendChild(n)
                    }), this.updateDisplay(), l.default.bind(this.__select, "change", function () {
                        var t = this.options[this.selectedIndex].value;
                        s.setValue(t)
                    }), this.domElement.appendChild(this.__select)
                }

                return a(e, t), e.prototype.setValue = function (e) {
                    var n = t.prototype.setValue.call(this, e);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), n
                }, e.prototype.updateDisplay = function () {
                    return this.__select.value = this.getValue(), t.prototype.updateDisplay.call(this)
                }, e
            }(s.default);
            e.default = d, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            e.__esModule = !0;
            var o = n(7), s = i(o), c = n(9), l = i(c), u = function (t) {
                function e(n, i) {
                    function a() {
                        s.setValue(s.__input.value)
                    }

                    function o() {
                        s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                    }

                    r(this, e), t.call(this, n, i);
                    var s = this;
                    this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), l.default.bind(this.__input, "keyup", a), l.default.bind(this.__input, "change", a), l.default.bind(this.__input, "blur", o), l.default.bind(this.__input, "keydown", function (t) {
                        13 === t.keyCode && this.blur()
                    }), this.updateDisplay(), this.domElement.appendChild(this.__input)
                }

                return a(e, t), e.prototype.updateDisplay = function () {
                    return l.default.isActive(this.__input) || (this.__input.value = this.getValue()), t.prototype.updateDisplay.call(this)
                }, e
            }(s.default);
            e.default = u, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            function o(t) {
                var e = t.toString();
                return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
            }

            e.__esModule = !0;
            var s = n(7), c = i(s), l = n(5), u = i(l), h = function (t) {
                function e(n, i, a) {
                    r(this, e), t.call(this, n, i);
                    var s = a || {};
                    this.__min = s.min, this.__max = s.max, this.__step = s.step, u.default.isUndefined(this.__step) ? 0 === this.initialValue ? this.__impliedStep = 1 : this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(this.initialValue)) / Math.LN10)) / 10 : this.__impliedStep = this.__step, this.__precision = o(this.__impliedStep)
                }

                return a(e, t), e.prototype.setValue = function (e) {
                    var n = e;
                    return void 0 !== this.__min && n < this.__min ? n = this.__min : void 0 !== this.__max && n > this.__max && (n = this.__max), void 0 !== this.__step && n % this.__step !== 0 && (n = Math.round(n / this.__step) * this.__step), t.prototype.setValue.call(this, n)
                }, e.prototype.min = function (t) {
                    return this.__min = t, this
                }, e.prototype.max = function (t) {
                    return this.__max = t, this
                }, e.prototype.step = function (t) {
                    return this.__step = t, this.__impliedStep = t, this.__precision = o(t), this
                }, e
            }(c.default);
            e.default = h, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            function o(t, e) {
                var n = Math.pow(10, e);
                return Math.round(t * n) / n
            }

            e.__esModule = !0;
            var s = n(12), c = i(s), l = n(9), u = i(l), h = n(5), d = i(h), p = function (t) {
                function e(n, i, a) {
                    function o() {
                        var t = parseFloat(p.__input.value);
                        d.default.isNaN(t) || p.setValue(t)
                    }

                    function s() {
                        o(), p.__onFinishChange && p.__onFinishChange.call(p, p.getValue())
                    }

                    function c(t) {
                        u.default.bind(window, "mousemove", l), u.default.bind(window, "mouseup", h), f = t.clientY
                    }

                    function l(t) {
                        var e = f - t.clientY;
                        p.setValue(p.getValue() + e * p.__impliedStep), f = t.clientY
                    }

                    function h() {
                        u.default.unbind(window, "mousemove", l), u.default.unbind(window, "mouseup", h)
                    }

                    r(this, e), t.call(this, n, i, a), this.__truncationSuspended = !1;
                    var p = this, f = void 0;
                    this.__input = document.createElement("input"), this.__input.setAttribute("type", "text"), u.default.bind(this.__input, "change", o), u.default.bind(this.__input, "blur", s), u.default.bind(this.__input, "mousedown", c), u.default.bind(this.__input, "keydown", function (t) {
                        13 === t.keyCode && (p.__truncationSuspended = !0, this.blur(), p.__truncationSuspended = !1)
                    }), this.updateDisplay(), this.domElement.appendChild(this.__input)
                }

                return a(e, t), e.prototype.updateDisplay = function () {
                    return this.__input.value = this.__truncationSuspended ? this.getValue() : o(this.getValue(), this.__precision), t.prototype.updateDisplay.call(this)
                }, e
            }(c.default);
            e.default = p, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            function o(t, e, n, i, r) {
                return i + (r - i) * ((t - e) / (n - e))
            }

            e.__esModule = !0;
            var s = n(12), c = i(s), l = n(9), u = i(l), h = n(15), d = i(h), p = n(16), f = i(p), m = function (t) {
                function e(n, i, a, s, c) {
                    function l(t) {
                        u.default.bind(window, "mousemove", h), u.default.bind(window, "mouseup", d), h(t)
                    }

                    function h(t) {
                        t.preventDefault();
                        var e = u.default.getOffset(p.__background), n = u.default.getWidth(p.__background);
                        return p.setValue(o(t.clientX, e.left, e.left + n, p.__min, p.__max)), !1
                    }

                    function d() {
                        u.default.unbind(window, "mousemove", h), u.default.unbind(window, "mouseup", d), p.__onFinishChange && p.__onFinishChange.call(p, p.getValue())
                    }

                    r(this, e), t.call(this, n, i, {min: a, max: s, step: c});
                    var p = this;
                    this.__background = document.createElement("div"), this.__foreground = document.createElement("div"), u.default.bind(this.__background, "mousedown", l), u.default.addClass(this.__background, "slider"), u.default.addClass(this.__foreground, "slider-fg"), this.updateDisplay(), this.__background.appendChild(this.__foreground), this.domElement.appendChild(this.__background)
                }

                return a(e, t), e.prototype.updateDisplay = function () {
                    var e = (this.getValue() - this.__min) / (this.__max - this.__min);
                    return this.__foreground.style.width = 100 * e + "%", t.prototype.updateDisplay.call(this)
                }, e
            }(c.default);
            m.useDefaultStyles = function () {
                d.default.inject(f.default)
            }, e.default = m, t.exports = e.default
        }, function (t, e) {
            "use strict";
            t.exports = {
                load: function (t, e) {
                    var n = e || document, i = n.createElement("link");
                    i.type = "text/css", i.rel = "stylesheet", i.href = t, n.getElementsByTagName("head")[0].appendChild(i)
                }, inject: function (t, e) {
                    var n = e || document, i = document.createElement("style");
                    i.type = "text/css", i.innerHTML = t, n.getElementsByTagName("head")[0].appendChild(i)
                }
            }
        }, function (t, e, n) {
            var i = n(17);
            "string" == typeof i && (i = [[t.id, i, ""]]);
            n(19)(i, {});
            i.locals && (t.exports = i.locals)
        }, function (t, e, n) {
            e = t.exports = n(18)(), e.push([t.id, "/**\n * dat-gui JavaScript Controller Library\n * http://code.google.com/p/dat-gui\n *\n * Copyright 2011 Data Arts Team, Google Creative Lab\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n.slider {\n  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15);\n  height: 1em;\n  border-radius: 1em;\n  background-color: #eee;\n  padding: 0 0.5em;\n  overflow: hidden; }\n\n.slider-fg {\n  padding: 1px 0 2px 0;\n  background-color: #aaa;\n  height: 1em;\n  margin-left: -0.5em;\n  padding-right: 0.5em;\n  border-radius: 1em 0 0 1em; }\n\n.slider-fg:after {\n  display: inline-block;\n  border-radius: 1em;\n  background-color: #fff;\n  border: 1px solid #aaa;\n  content: '';\n  float: right;\n  margin-right: -1em;\n  margin-top: -1px;\n  height: 0.9em;\n  width: 0.9em; }\n", ""])
        }, function (t, e) {
            t.exports = function () {
                var t = [];
                return t.toString = function () {
                    for (var t = [], e = 0; e < this.length; e++) {
                        var n = this[e];
                        n[2] ? t.push("@media " + n[2] + "{" + n[1] + "}") : t.push(n[1])
                    }
                    return t.join("")
                }, t.i = function (e, n) {
                    "string" == typeof e && (e = [[null, e, ""]]);
                    for (var i = {}, r = 0; r < this.length; r++) {
                        var a = this[r][0];
                        "number" == typeof a && (i[a] = !0)
                    }
                    for (r = 0; r < e.length; r++) {
                        var o = e[r];
                        "number" == typeof o[0] && i[o[0]] || (n && !o[2] ? o[2] = n : n && (o[2] = "(" + o[2] + ") and (" + n + ")"), t.push(o))
                    }
                }, t
            }
        }, function (t, e, n) {
            function i(t, e) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n], r = h[i.id];
                    if (r) {
                        r.refs++;
                        for (var a = 0; a < r.parts.length; a++)r.parts[a](i.parts[a]);
                        for (; a < i.parts.length; a++)r.parts.push(s(i.parts[a], e))
                    } else {
                        for (var o = [], a = 0; a < i.parts.length; a++)o.push(s(i.parts[a], e));
                        h[i.id] = {id: i.id, refs: 1, parts: o}
                    }
                }
            }

            function r(t) {
                for (var e = [], n = {}, i = 0; i < t.length; i++) {
                    var r = t[i], a = r[0], o = r[1], s = r[2], c = r[3], l = {css: o, media: s, sourceMap: c};
                    n[a] ? n[a].parts.push(l) : e.push(n[a] = {id: a, parts: [l]})
                }
                return e
            }

            function a() {
                var t = document.createElement("style"), e = f();
                return t.type = "text/css", e.appendChild(t), t
            }

            function o() {
                var t = document.createElement("link"), e = f();
                return t.rel = "stylesheet", e.appendChild(t), t
            }

            function s(t, e) {
                var n, i, r;
                if (e.singleton) {
                    var s = g++;
                    n = m || (m = a()), i = c.bind(null, n, s, !1), r = c.bind(null, n, s, !0)
                } else t.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n = o(), i = u.bind(null, n), r = function () {
                    n.parentNode.removeChild(n), n.href && URL.revokeObjectURL(n.href)
                }) : (n = a(), i = l.bind(null, n), r = function () {
                    n.parentNode.removeChild(n)
                });
                return i(t), function (e) {
                    if (e) {
                        if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap)return;
                        i(t = e)
                    } else r()
                }
            }

            function c(t, e, n, i) {
                var r = n ? "" : i.css;
                if (t.styleSheet)t.styleSheet.cssText = v(e, r); else {
                    var a = document.createTextNode(r), o = t.childNodes;
                    o[e] && t.removeChild(o[e]), o.length ? t.insertBefore(a, o[e]) : t.appendChild(a)
                }
            }

            function l(t, e) {
                var n = e.css, i = e.media;
                e.sourceMap;
                if (i && t.setAttribute("media", i), t.styleSheet)t.styleSheet.cssText = n; else {
                    for (; t.firstChild;)t.removeChild(t.firstChild);
                    t.appendChild(document.createTextNode(n))
                }
            }

            function u(t, e) {
                var n = e.css, i = (e.media, e.sourceMap);
                i && (n += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(i)))) + " */");
                var r = new Blob([n], {type: "text/css"}), a = t.href;
                t.href = URL.createObjectURL(r), a && URL.revokeObjectURL(a)
            }

            var h = {}, d = function (t) {
                var e;
                return function () {
                    return "undefined" == typeof e && (e = t.apply(this, arguments)), e
                }
            }, p = d(function () {
                return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase())
            }), f = d(function () {
                return document.head || document.getElementsByTagName("head")[0]
            }), m = null, g = 0;
            t.exports = function (t, e) {
                e = e || {}, "undefined" == typeof e.singleton && (e.singleton = p());
                var n = r(t);
                return i(n, e), function (t) {
                    for (var a = [], o = 0; o < n.length; o++) {
                        var s = n[o], c = h[s.id];
                        c.refs--, a.push(c)
                    }
                    if (t) {
                        var l = r(t);
                        i(l, e)
                    }
                    for (var o = 0; o < a.length; o++) {
                        var c = a[o];
                        if (0 === c.refs) {
                            for (var u = 0; u < c.parts.length; u++)c.parts[u]();
                            delete h[c.id]
                        }
                    }
                }
            };
            var v = function () {
                var t = [];
                return function (e, n) {
                    return t[e] = n, t.filter(Boolean).join("\n")
                }
            }()
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            e.__esModule = !0;
            var o = n(7), s = i(o), c = n(9), l = i(c), u = function (t) {
                function e(n, i, a) {
                    r(this, e), t.call(this, n, i);
                    var o = this;
                    this.__button = document.createElement("div"), this.__button.innerHTML = void 0 === a ? "Fire" : a, l.default.bind(this.__button, "click", function (t) {
                        return t.preventDefault(), o.fire(), !1
                    }), l.default.addClass(this.__button, "button"), this.domElement.appendChild(this.__button)
                }

                return a(e, t), e.prototype.fire = function () {
                    this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                }, e
            }(s.default);
            e.default = u, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            function a(t, e) {
                if ("function" != typeof e && null !== e)throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
            }

            function o(t, e, n, i) {
                t.style.background = "", v.default.each(_, function (r) {
                    t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + n + " 0%, " + i + " 100%); "
                })
            }

            function s(t) {
                t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
            }

            e.__esModule = !0;
            var c = n(7), l = i(c), u = n(9), h = i(u), d = n(2), p = i(d), f = n(3), m = i(f), g = n(5), v = i(g), y = function (t) {
                function e(n, i) {
                    function a(t) {
                        d(t), h.default.bind(window, "mousemove", d), h.default.bind(window, "mouseup", c)
                    }

                    function c() {
                        h.default.unbind(window, "mousemove", d), h.default.unbind(window, "mouseup", c)
                    }

                    function l() {
                        var t = m.default(this.value);
                        t !== !1 ? (g.__color.__state = t, g.setValue(g.__color.toOriginal())) : this.value = g.__color.toString()
                    }

                    function u() {
                        h.default.unbind(window, "mousemove", f), h.default.unbind(window, "mouseup", u)
                    }

                    function d(t) {
                        t.preventDefault();
                        var e = h.default.getWidth(g.__saturation_field), n = h.default.getOffset(g.__saturation_field), i = (t.clientX - n.left + document.body.scrollLeft) / e, r = 1 - (t.clientY - n.top + document.body.scrollTop) / e;
                        return r > 1 ? r = 1 : r < 0 && (r = 0), i > 1 ? i = 1 : i < 0 && (i = 0), g.__color.v = r, g.__color.s = i, g.setValue(g.__color.toOriginal()), !1
                    }

                    function f(t) {
                        t.preventDefault();
                        var e = h.default.getHeight(g.__hue_field), n = h.default.getOffset(g.__hue_field), i = 1 - (t.clientY - n.top + document.body.scrollTop) / e;
                        return i > 1 ? i = 1 : i < 0 && (i = 0), g.__color.h = 360 * i, g.setValue(g.__color.toOriginal()), !1
                    }

                    r(this, e), t.call(this, n, i), this.__color = new p.default(this.getValue()), this.__temp = new p.default(0);
                    var g = this;
                    this.domElement = document.createElement("div"), h.default.makeSelectable(this.domElement, !1), this.__selector = document.createElement("div"), this.__selector.className = "selector", this.__saturation_field = document.createElement("div"), this.__saturation_field.className = "saturation-field", this.__field_knob = document.createElement("div"), this.__field_knob.className = "field-knob", this.__field_knob_border = "2px solid ", this.__hue_knob = document.createElement("div"), this.__hue_knob.className = "hue-knob", this.__hue_field = document.createElement("div"), this.__hue_field.className = "hue-field", this.__input = document.createElement("input"), this.__input.type = "text", this.__input_textShadow = "0 1px 1px ", h.default.bind(this.__input, "keydown", function (t) {
                        13 === t.keyCode && l.call(this)
                    }), h.default.bind(this.__input, "blur", l), h.default.bind(this.__selector, "mousedown", function () {
                        h.default.addClass(this, "drag").bind(window, "mouseup", function () {
                            h.default.removeClass(g.__selector, "drag")
                        })
                    });
                    var y = document.createElement("div");
                    v.default.extend(this.__selector.style, {
                        width: "122px",
                        height: "102px",
                        padding: "3px",
                        backgroundColor: "#222",
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                    }), v.default.extend(this.__field_knob.style, {
                        position: "absolute",
                        width: "12px",
                        height: "12px",
                        border: this.__field_knob_border + (this.__color.v < .5 ? "#fff" : "#000"),
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                        borderRadius: "12px",
                        zIndex: 1
                    }), v.default.extend(this.__hue_knob.style, {
                        position: "absolute",
                        width: "15px",
                        height: "2px",
                        borderRight: "4px solid #fff",
                        zIndex: 1
                    }), v.default.extend(this.__saturation_field.style, {
                        width: "100px",
                        height: "100px",
                        border: "1px solid #555",
                        marginRight: "3px",
                        display: "inline-block",
                        cursor: "pointer"
                    }), v.default.extend(y.style, {
                        width: "100%",
                        height: "100%",
                        background: "none"
                    }), o(y, "top", "rgba(0,0,0,0)", "#000"), v.default.extend(this.__hue_field.style, {
                        width: "15px",
                        height: "100px",
                        display: "inline-block",
                        border: "1px solid #555",
                        cursor: "ns-resize"
                    }), s(this.__hue_field), v.default.extend(this.__input.style, {
                        outline: "none",
                        textAlign: "center",
                        color: "#fff",
                        border: 0,
                        fontWeight: "bold",
                        textShadow: this.__input_textShadow + "rgba(0,0,0,0.7)"
                    }), h.default.bind(this.__saturation_field, "mousedown", a), h.default.bind(this.__field_knob, "mousedown", a), h.default.bind(this.__hue_field, "mousedown", function (t) {
                        f(t), h.default.bind(window, "mousemove", f), h.default.bind(window, "mouseup", u)
                    }), this.__saturation_field.appendChild(y), this.__selector.appendChild(this.__field_knob), this.__selector.appendChild(this.__saturation_field), this.__selector.appendChild(this.__hue_field), this.__hue_field.appendChild(this.__hue_knob), this.domElement.appendChild(this.__input), this.domElement.appendChild(this.__selector), this.updateDisplay()
                }

                return a(e, t), e.prototype.updateDisplay = function () {
                    var t = m.default(this.getValue());
                    if (t !== !1) {
                        var e = !1;
                        v.default.each(p.default.COMPONENTS, function (n) {
                            if (!v.default.isUndefined(t[n]) && !v.default.isUndefined(this.__color.__state[n]) && t[n] !== this.__color.__state[n])return e = !0, {}
                        }, this), e && v.default.extend(this.__color.__state, t)
                    }
                    v.default.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                    var n = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0, i = 255 - n;
                    v.default.extend(this.__field_knob.style, {
                        marginLeft: 100 * this.__color.s - 7 + "px",
                        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                        backgroundColor: this.__temp.toString(),
                        border: this.__field_knob_border + "rgb(" + n + "," + n + "," + n + ")"
                    }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, o(this.__saturation_field, "left", "#fff", this.__temp.toString()), v.default.extend(this.__input.style, {
                        backgroundColor: this.__input.value = this.__color.toString(),
                        color: "rgb(" + n + "," + n + "," + n + ")",
                        textShadow: this.__input_textShadow + "rgba(" + i + "," + i + "," + i + ",.7)"
                    })
                }, e
            }(l.default), _ = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
            e.default = y, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e, n) {
                var i = document.createElement("li");
                return e && i.appendChild(e), n ? t.__ul.insertBefore(i, params.before) : t.__ul.appendChild(i), t.onResize(), i
            }

            function a(t, e) {
                var n = t.__preset_select[t.__preset_select.selectedIndex];
                e ? n.innerHTML = n.value + "*" : n.innerHTML = n.value
            }

            function o(t, e, n) {
                if (n.__li = e, n.__gui = t, W.default.extend(n, {
                        options: function (e) {
                            return arguments.length > 1 ? (n.remove(), c(t, n.object, n.property, {
                                before: n.__li.nextElementSibling,
                                factoryArgs: [W.default.toArray(arguments)]
                            })) : W.default.isArray(e) || W.default.isObject(e) ? (n.remove(), c(t, n.object, n.property, {
                                before: n.__li.nextElementSibling,
                                factoryArgs: [e]
                            })) : void 0
                        }, name: function (t) {
                            return n.__li.firstElementChild.firstElementChild.innerHTML = t, n
                        }, listen: function () {
                            return n.__gui.listen(n), n
                        }, remove: function () {
                            return n.__gui.remove(n), n
                        }
                    }), n instanceof N.default)!function () {
                    var t = new I.default(n.object, n.property, {min: n.__min, max: n.__max, step: n.__step});
                    W.default.each(["updateDisplay", "onChange", "onFinishChange"], function (e) {
                        var i = n[e], r = t[e];
                        n[e] = t[e] = function () {
                            var e = Array.prototype.slice.call(arguments);
                            return i.apply(n, e), r.apply(t, e)
                        }
                    }), V.default.addClass(e, "has-slider"), n.domElement.insertBefore(t.domElement, n.domElement.firstElementChild)
                }(); else if (n instanceof I.default) {
                    var i = function (e) {
                        return W.default.isNumber(n.__min) && W.default.isNumber(n.__max) ? (n.remove(), c(t, n.object, n.property, {
                            before: n.__li.nextElementSibling,
                            factoryArgs: [n.__min, n.__max, n.__step]
                        })) : e
                    };
                    n.min = W.default.compose(i, n.min), n.max = W.default.compose(i, n.max)
                } else n instanceof R.default ? (V.default.bind(e, "click", function () {
                    V.default.fakeEvent(n.__checkbox, "click")
                }), V.default.bind(n.__checkbox, "click", function (t) {
                    t.stopPropagation()
                })) : n instanceof P.default ? (V.default.bind(e, "click", function () {
                    V.default.fakeEvent(n.__button, "click")
                }), V.default.bind(e, "mouseover", function () {
                    V.default.addClass(n.__button, "hover")
                }), V.default.bind(e, "mouseout", function () {
                    V.default.removeClass(n.__button, "hover")
                })) : n instanceof F.default && (V.default.addClass(e, "color"), n.updateDisplay = W.default.compose(function (t) {
                    return e.style.borderLeftColor = n.__color.toString(), t
                }, n.updateDisplay), n.updateDisplay());
                n.setValue = W.default.compose(function (e) {
                    return t.getRoot().__preset_select && n.isModified() && a(t.getRoot(), !0), e
                }, n.setValue)
            }

            function s(t, e) {
                var n = t.getRoot(), i = n.__rememberedObjects.indexOf(e.object);
                if (i !== -1) {
                    var r = n.__rememberedObjectIndecesToControllers[i];
                    if (void 0 === r && (r = {}, n.__rememberedObjectIndecesToControllers[i] = r), r[e.property] = e, n.load && n.load.remembered) {
                        var a = n.load.remembered, o = void 0;
                        if (a[t.preset])o = a[t.preset]; else {
                            if (!a[Z])return;
                            o = a[Z]
                        }
                        if (o[i] && void 0 !== o[i][e.property]) {
                            var s = o[i][e.property];
                            e.initialValue = s, e.setValue(s)
                        }
                    }
                }
            }

            function c(t, e, n, i) {
                if (void 0 === e[n])throw new Error('Object "' + e + '" has no property "' + n + '"');
                var a = void 0;
                if (i.color)a = new F.default(e, n); else {
                    var c = [e, n].concat(i.factoryArgs);
                    a = T.default.apply(t, c)
                }
                i.before instanceof A.default && (i.before = i.before.__li), s(t, a), V.default.addClass(a.domElement, "c");
                var l = document.createElement("span");
                V.default.addClass(l, "property-name"), l.innerHTML = a.property;
                var u = document.createElement("div");
                u.appendChild(l), u.appendChild(a.domElement);
                var h = r(t, u, i.before);
                return V.default.addClass(h, nt.CLASS_CONTROLLER_ROW), a instanceof F.default ? V.default.addClass(h, "color") : V.default.addClass(h, typeof a.getValue()), o(t, h, a), t.__controllers.push(a), a
            }

            function l(t, e) {
                return document.location.href + "." + e
            }

            function u(t, e, n) {
                var i = document.createElement("option");
                i.innerHTML = e, i.value = e, t.__preset_select.appendChild(i), n && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
            }

            function h(t, e) {
                e.style.display = t.useLocalStorage ? "block" : "none"
            }

            function d(t) {
                var e = t.__save_row = document.createElement("li");
                V.default.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), V.default.addClass(e, "save-row");
                var n = document.createElement("span");
                n.innerHTML = "&nbsp;", V.default.addClass(n, "button gears");
                var i = document.createElement("span");
                i.innerHTML = "Save", V.default.addClass(i, "button"), V.default.addClass(i, "save");
                var r = document.createElement("span");
                r.innerHTML = "New", V.default.addClass(r, "button"), V.default.addClass(r, "save-as");
                var a = document.createElement("span");
                a.innerHTML = "Revert", V.default.addClass(a, "button"), V.default.addClass(a, "revert");
                var o = t.__preset_select = document.createElement("select");
                t.load && t.load.remembered ? W.default.each(t.load.remembered, function (e, n) {
                    u(t, n, n === t.preset)
                }) : u(t, Z, !1), V.default.bind(o, "change", function () {
                    for (var e = 0; e < t.__preset_select.length; e++)t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                    t.preset = this.value
                }), e.appendChild(o), e.appendChild(n), e.appendChild(i), e.appendChild(r), e.appendChild(a), J && !function () {
                    var e = document.getElementById("dg-local-explain"), n = document.getElementById("dg-local-storage"), i = document.getElementById("dg-save-locally");
                    i.style.display = "block", "true" === localStorage.getItem(l(t, "isLocal")) && n.setAttribute("checked", "checked"), h(t, e), V.default.bind(n, "change", function () {
                        t.useLocalStorage = !t.useLocalStorage, h(t, e)
                    })
                }();
                var s = document.getElementById("dg-new-constructor");
                V.default.bind(s, "keydown", function (t) {
                    !t.metaKey || 67 !== t.which && 67 !== t.keyCode || Q.hide()
                }), V.default.bind(n, "click", function () {
                    s.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), Q.show(), s.focus(), s.select()
                }), V.default.bind(i, "click", function () {
                    t.save()
                }), V.default.bind(r, "click", function () {
                    var e = prompt("Enter a new preset name.");
                    e && t.saveAs(e)
                }), V.default.bind(a, "click", function () {
                    t.revert()
                })
            }

            function p(t) {
                function e(e) {
                    return e.preventDefault(), t.width += r - e.clientX, t.onResize(), r = e.clientX, !1
                }

                function n() {
                    V.default.removeClass(t.__closeButton, nt.CLASS_DRAG), V.default.unbind(window, "mousemove", e), V.default.unbind(window, "mouseup", n)
                }

                function i(i) {
                    return i.preventDefault(), r = i.clientX, V.default.addClass(t.__closeButton, nt.CLASS_DRAG), V.default.bind(window, "mousemove", e), V.default.bind(window, "mouseup", n), !1
                }

                var r = void 0;
                t.__resize_handle = document.createElement("div"), W.default.extend(t.__resize_handle.style, {
                    width: "6px",
                    marginLeft: "-3px",
                    height: "200px",
                    cursor: "ew-resize",
                    position: "absolute"
                }), V.default.bind(t.__resize_handle, "mousedown", i), V.default.bind(t.__closeButton, "mousedown", i), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
            }

            function f(t, e) {
                t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
            }

            function m(t, e) {
                var n = {};
                return W.default.each(t.__rememberedObjects, function (i, r) {
                    var a = {}, o = t.__rememberedObjectIndecesToControllers[r];
                    W.default.each(o, function (t, n) {
                        a[n] = e ? t.initialValue : t.getValue()
                    }), n[r] = a
                }), n
            }

            function g(t) {
                for (var e = 0; e < t.__preset_select.length; e++)t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
            }

            function v(t) {
                0 !== t.length && z.default(function () {
                    v(t)
                }), W.default.each(t, function (t) {
                    t.updateDisplay()
                })
            }

            var y = n(15), _ = i(y), x = n(23), b = i(x), w = n(24), M = i(w), E = n(26), T = i(E), S = n(7), A = i(S), L = n(8), R = i(L), C = n(20), P = i(C), O = n(13), I = i(O), U = n(14), N = i(U), D = n(21), F = i(D), B = n(27), z = i(B), G = n(28), k = i(G), H = n(9), V = i(H), j = n(5), W = i(j);
            _.default.inject(M.default);
            var X = "dg", Y = 72, q = 20, Z = "Default", J = function () {
                try {
                    return "localStorage" in window && null !== window.localStorage
                } catch (t) {
                    return !1
                }
            }(), Q = void 0, K = !0, $ = void 0, tt = !1, et = [], nt = function t(e) {
                function n() {
                    var t = i.getRoot();
                    t.width += 1, W.default.defer(function () {
                        t.width -= 1
                    })
                }

                var i = this, a = e || {};
                this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), V.default.addClass(this.domElement, X), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], a = W.default.defaults(a, {
                    autoPlace: !0,
                    width: t.DEFAULT_WIDTH
                }), a = W.default.defaults(a, {
                    resizable: a.autoPlace,
                    hideable: a.autoPlace
                }), W.default.isUndefined(a.load) ? a.load = {preset: Z} : a.preset && (a.load.preset = a.preset), W.default.isUndefined(a.parent) && a.hideable && et.push(this), a.resizable = W.default.isUndefined(a.parent) && a.resizable, a.autoPlace && W.default.isUndefined(a.scrollable) && (a.scrollable = !0);
                var o = J && "true" === localStorage.getItem(l(this, "isLocal")), s = void 0;
                if (Object.defineProperties(this, {
                        parent: {
                            get: function () {
                                return a.parent
                            }
                        }, scrollable: {
                            get: function () {
                                return a.scrollable
                            }
                        }, autoPlace: {
                            get: function () {
                                return a.autoPlace
                            }
                        }, preset: {
                            get: function () {
                                return i.parent ? i.getRoot().preset : a.load.preset
                            }, set: function (t) {
                                i.parent ? i.getRoot().preset = t : a.load.preset = t, g(this), i.revert()
                            }
                        }, width: {
                            get: function () {
                                return a.width
                            }, set: function (t) {
                                a.width = t, f(i, t)
                            }
                        }, name: {
                            get: function () {
                                return a.name
                            }, set: function (t) {
                                a.name = t, titleRowName && (titleRowName.innerHTML = a.name)
                            }
                        }, closed: {
                            get: function () {
                                return a.closed
                            }, set: function (e) {
                                a.closed = e, a.closed ? V.default.addClass(i.__ul, t.CLASS_CLOSED) : V.default.removeClass(i.__ul, t.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                            }
                        }, load: {
                            get: function () {
                                return a.load
                            }
                        }, useLocalStorage: {
                            get: function () {
                                return o
                            }, set: function (t) {
                                J && (o = t, t ? V.default.bind(window, "unload", s) : V.default.unbind(window, "unload", s), localStorage.setItem(l(i, "isLocal"), t))
                            }
                        }
                    }), W.default.isUndefined(a.parent)) {
                    if (a.closed = !1, V.default.addClass(this.domElement, t.CLASS_MAIN), V.default.makeSelectable(this.domElement, !1), J && o) {
                        i.useLocalStorage = !0;
                        var c = localStorage.getItem(l(this, "gui"));
                        c && (a.load = JSON.parse(c))
                    }
                    this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, V.default.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), this.domElement.appendChild(this.__closeButton), V.default.bind(this.__closeButton, "click", function () {
                        i.closed = !i.closed
                    })
                } else {
                    void 0 === a.closed && (a.closed = !0);
                    var u = document.createTextNode(a.name);
                    V.default.addClass(u, "controller-name");
                    var h = r(i, u), d = function (t) {
                        return t.preventDefault(), i.closed = !i.closed, !1
                    };
                    V.default.addClass(this.__ul, t.CLASS_CLOSED), V.default.addClass(h, "title"), V.default.bind(h, "click", d), a.closed || (this.closed = !1)
                }
                a.autoPlace && (W.default.isUndefined(a.parent) && (K && ($ = document.createElement("div"), V.default.addClass($, X), V.default.addClass($, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild($), K = !1), $.appendChild(this.domElement), V.default.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || f(i, a.width)), V.default.bind(window, "resize", function () {
                    i.onResize()
                }), V.default.bind(this.__ul, "webkitTransitionEnd", function () {
                    i.onResize()
                }), V.default.bind(this.__ul, "transitionend", function () {
                    i.onResize()
                }), V.default.bind(this.__ul, "oTransitionEnd", function () {
                    i.onResize()
                }), this.onResize(), a.resizable && p(this), s = function () {
                    J && "true" === localStorage.getItem(l(i, "isLocal")) && localStorage.setItem(l(i, "gui"), JSON.stringify(i.getSaveObject()))
                }, this.saveToLocalStorageIfPossible = s, a.parent || n()
            };
            nt.toggleHide = function () {
                tt = !tt, W.default.each(et, function (t) {
                    t.domElement.style.zIndex = tt ? -999 : 999, t.domElement.style.opacity = tt ? 0 : 1
                })
            }, nt.CLASS_AUTO_PLACE = "a", nt.CLASS_AUTO_PLACE_CONTAINER = "ac", nt.CLASS_MAIN = "main", nt.CLASS_CONTROLLER_ROW = "cr", nt.CLASS_TOO_TALL = "taller-than-window", nt.CLASS_CLOSED = "closed", nt.CLASS_CLOSE_BUTTON = "close-button", nt.CLASS_DRAG = "drag", nt.DEFAULT_WIDTH = 245, nt.TEXT_CLOSED = "Close Controls", nt.TEXT_OPEN = "Open Controls", V.default.bind(window, "keydown", function (t) {
                "text" === document.activeElement.type || t.which !== Y && t.keyCode !== Y || nt.toggleHide()
            }, !1), W.default.extend(nt.prototype, {
                add: function (t) {
                    function e(e, n) {
                        return t.apply(this, arguments)
                    }

                    return e.toString = function () {
                        return t.toString()
                    }, e
                }(function (t, e) {
                    return c(this, t, e, {factoryArgs: Array.prototype.slice.call(arguments, 2)})
                }), addColor: function (t, e) {
                    return c(this, t, e, {color: !0})
                }, remove: function (t) {
                    this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
                    var e = this;
                    W.default.defer(function () {
                        e.onResize()
                    })
                }, destroy: function () {
                    this.autoPlace && $.removeChild(this.domElement)
                }, addFolder: function (t) {
                    if (void 0 !== this.__folders[t])throw new Error('You already have a folder in this GUI by the name "' + t + '"');
                    var e = {name: t, parent: this};
                    e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
                    var n = new nt(e);
                    this.__folders[t] = n;
                    var i = r(this, n.domElement);
                    return V.default.addClass(i, "folder"), n
                }, open: function () {
                    this.closed = !1
                }, close: function () {
                    this.closed = !0
                }, onResize: function () {
                    var t = this.getRoot();
                    if (t.scrollable) {
                        var e = V.default.getOffset(t.__ul).top, n = 0;
                        W.default.each(t.__ul.childNodes, function (e) {
                            t.autoPlace && e === t.__save_row || (n += V.default.getHeight(e))
                        }), window.innerHeight - e - q < n ? (V.default.addClass(t.domElement, nt.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - q + "px") : (V.default.removeClass(t.domElement, nt.CLASS_TOO_TALL), t.__ul.style.height = "auto")
                    }
                    t.__resize_handle && W.default.defer(function () {
                        t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
                    }), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
                }, remember: function () {
                    if (W.default.isUndefined(Q) && (Q = new k.default, Q.domElement.innerHTML = b.default), this.parent)throw new Error("You can only call remember on a top level GUI.");
                    var t = this;
                    W.default.each(Array.prototype.slice.call(arguments), function (e) {
                        0 === t.__rememberedObjects.length && d(t), t.__rememberedObjects.indexOf(e) === -1 && t.__rememberedObjects.push(e)
                    }), this.autoPlace && f(this, this.width)
                }, getRoot: function () {
                    for (var t = this; t.parent;)t = t.parent;
                    return t
                }, getSaveObject: function () {
                    var t = this.load;
                    return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = m(this)), t.folders = {}, W.default.each(this.__folders, function (e, n) {
                        t.folders[n] = e.getSaveObject()
                    }), t
                }, save: function () {
                    this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = m(this), a(this, !1), this.saveToLocalStorageIfPossible()
                }, saveAs: function (t) {
                    this.load.remembered || (this.load.remembered = {}, this.load.remembered[Z] = m(this, !0)), this.load.remembered[t] = m(this), this.preset = t, u(this, t, !0), this.saveToLocalStorageIfPossible()
                }, revert: function (t) {
                    W.default.each(this.__controllers, function (e) {
                        this.getRoot().load.remembered ? s(t || this.getRoot(), e) : e.setValue(e.initialValue)
                    }, this), W.default.each(this.__folders, function (t) {
                        t.revert(t)
                    }), t || a(this.getRoot(), !1)
                }, listen: function (t) {
                    var e = 0 === this.__listening.length;
                    this.__listening.push(t), e && v(this.__listening)
                }
            }), t.exports = nt
        }, function (t, e) {
            t.exports = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'
        }, function (t, e, n) {
            var i = n(25);
            "string" == typeof i && (i = [[t.id, i, ""]]);
            n(19)(i, {});
            i.locals && (t.exports = i.locals)
        }, function (t, e, n) {
            e = t.exports = n(18)(), e.push([t.id, ".dg {\n  /** Clear list styles */\n  /* Auto-place container */\n  /* Auto-placed GUI's */\n  /* Line items that don't contain folders. */\n  /** Folder names */\n  /** Hides closed items */\n  /** Controller row */\n  /** Name-half (left) */\n  /** Controller-half (right) */\n  /** Controller placement */\n  /** Shorter number boxes when slider is present. */\n  /** Ensure the entire boolean and function row shows a hand */ }\n  .dg ul {\n    list-style: none;\n    margin: 0;\n    padding: 0;\n    width: 100%;\n    clear: both; }\n  .dg.ac {\n    position: fixed;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 0;\n    z-index: 0; }\n  .dg:not(.ac) .main {\n    /** Exclude mains in ac so that we don't hide close button */\n    overflow: hidden; }\n  .dg.main {\n    -webkit-transition: opacity 0.1s linear;\n    -o-transition: opacity 0.1s linear;\n    -moz-transition: opacity 0.1s linear;\n    transition: opacity 0.1s linear; }\n    .dg.main.taller-than-window {\n      overflow-y: auto; }\n      .dg.main.taller-than-window .close-button {\n        opacity: 1;\n        /* TODO, these are style notes */\n        margin-top: -1px;\n        border-top: 1px solid #2c2c2c; }\n    .dg.main ul.closed .close-button {\n      opacity: 1 !important; }\n    .dg.main:hover .close-button,\n    .dg.main .close-button.drag {\n      opacity: 1; }\n    .dg.main .close-button {\n      /*opacity: 0;*/\n      -webkit-transition: opacity 0.1s linear;\n      -o-transition: opacity 0.1s linear;\n      -moz-transition: opacity 0.1s linear;\n      transition: opacity 0.1s linear;\n      border: 0;\n      position: absolute;\n      line-height: 19px;\n      height: 20px;\n      /* TODO, these are style notes */\n      cursor: pointer;\n      text-align: center;\n      background-color: #000; }\n      .dg.main .close-button:hover {\n        background-color: #111; }\n  .dg.a {\n    float: right;\n    margin-right: 15px;\n    overflow-x: hidden; }\n    .dg.a.has-save > ul {\n      margin-top: 27px; }\n      .dg.a.has-save > ul.closed {\n        margin-top: 0; }\n    .dg.a .save-row {\n      position: fixed;\n      top: 0;\n      z-index: 1002; }\n  .dg li {\n    -webkit-transition: height 0.1s ease-out;\n    -o-transition: height 0.1s ease-out;\n    -moz-transition: height 0.1s ease-out;\n    transition: height 0.1s ease-out; }\n  .dg li:not(.folder) {\n    cursor: auto;\n    height: 27px;\n    line-height: 27px;\n    overflow: hidden;\n    padding: 0 4px 0 5px; }\n  .dg li.folder {\n    padding: 0;\n    border-left: 4px solid transparent; }\n  .dg li.title {\n    cursor: pointer;\n    margin-left: -4px; }\n  .dg .closed li:not(.title),\n  .dg .closed ul li,\n  .dg .closed ul li > * {\n    height: 0;\n    overflow: hidden;\n    border: 0; }\n  .dg .cr {\n    clear: both;\n    padding-left: 3px;\n    height: 27px; }\n  .dg .property-name {\n    cursor: default;\n    float: left;\n    clear: left;\n    width: 40%;\n    overflow: hidden;\n    text-overflow: ellipsis; }\n  .dg .c {\n    float: left;\n    width: 60%; }\n  .dg .c input[type=text] {\n    border: 0;\n    margin-top: 4px;\n    padding: 3px;\n    width: 100%;\n    float: right; }\n  .dg .has-slider input[type=text] {\n    width: 30%;\n    /*display: none;*/\n    margin-left: 0; }\n  .dg .slider {\n    float: left;\n    width: 66%;\n    margin-left: -5px;\n    margin-right: 0;\n    height: 19px;\n    margin-top: 4px; }\n  .dg .slider-fg {\n    height: 100%; }\n  .dg .c input[type=checkbox] {\n    margin-top: 9px; }\n  .dg .c select {\n    margin-top: 5px; }\n  .dg .cr.function,\n  .dg .cr.function .property-name, .dg .cr.function *,\n  .dg .cr.boolean,\n  .dg .cr.boolean * {\n    cursor: pointer; }\n  .dg .selector {\n    display: none;\n    position: absolute;\n    margin-left: -9px;\n    margin-top: 23px;\n    z-index: 10; }\n  .dg .c:hover .selector,\n  .dg .selector.drag {\n    display: block; }\n  .dg li.save-row {\n    padding: 0; }\n    .dg li.save-row .button {\n      display: inline-block;\n      padding: 0px 6px; }\n  .dg.dialogue {\n    background-color: #222;\n    width: 460px;\n    padding: 15px;\n    font-size: 13px;\n    line-height: 15px; }\n\n/* TODO Separate style and structure */\n#dg-new-constructor {\n  padding: 10px;\n  color: #222;\n  font-family: Monaco, monospace;\n  font-size: 10px;\n  border: 0;\n  resize: none;\n  box-shadow: inset 1px 1px 1px #888;\n  word-wrap: break-word;\n  margin: 12px 0;\n  display: block;\n  width: 440px;\n  overflow-y: scroll;\n  height: 100px;\n  position: relative; }\n\n#dg-local-explain {\n  display: none;\n  font-size: 11px;\n  line-height: 17px;\n  border-radius: 3px;\n  background-color: #333;\n  padding: 8px;\n  margin-top: 10px; }\n  #dg-local-explain code {\n    font-size: 10px; }\n\n#dat-gui-save-locally {\n  display: none; }\n\n/** Main type */\n.dg {\n  color: #eee;\n  font: 11px 'Lucida Grande', sans-serif;\n  text-shadow: 0 -1px 0 #111;\n  /** Auto place */\n  /* Controller row, <li> */\n  /** Controllers */ }\n  .dg.main {\n    /** Scrollbar */ }\n    .dg.main::-webkit-scrollbar {\n      width: 5px;\n      background: #1a1a1a; }\n    .dg.main::-webkit-scrollbar-corner {\n      height: 0;\n      display: none; }\n    .dg.main::-webkit-scrollbar-thumb {\n      border-radius: 5px;\n      background: #676767; }\n  .dg li:not(.folder) {\n    background: #1a1a1a;\n    border-bottom: 1px solid #2c2c2c; }\n  .dg li.save-row {\n    line-height: 25px;\n    background: #dad5cb;\n    border: 0; }\n    .dg li.save-row select {\n      margin-left: 5px;\n      width: 108px; }\n    .dg li.save-row .button {\n      margin-left: 5px;\n      margin-top: 1px;\n      border-radius: 2px;\n      font-size: 9px;\n      line-height: 7px;\n      padding: 4px 4px 5px 4px;\n      background: #c5bdad;\n      color: #fff;\n      text-shadow: 0 1px 0 #b0a58f;\n      box-shadow: 0 -1px 0 #b0a58f;\n      cursor: pointer; }\n      .dg li.save-row .button.gears {\n        background: #c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;\n        height: 7px;\n        width: 8px; }\n      .dg li.save-row .button:hover {\n        background-color: #bab19e;\n        box-shadow: 0 -1px 0 #b0a58f; }\n  .dg li.folder {\n    border-bottom: 0; }\n  .dg li.title {\n    padding-left: 16px;\n    background: #000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;\n    cursor: pointer;\n    border-bottom: 1px solid rgba(255, 255, 255, 0.2); }\n  .dg .closed li.title {\n    background-image: url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==); }\n  .dg .cr.boolean {\n    border-left: 3px solid #806787; }\n  .dg .cr.color {\n    border-left: 3px solid; }\n  .dg .cr.function {\n    border-left: 3px solid #e61d5f; }\n  .dg .cr.number {\n    border-left: 3px solid #2FA1D6; }\n    .dg .cr.number input[type=text] {\n      color: #2FA1D6; }\n  .dg .cr.string {\n    border-left: 3px solid #1ed36f; }\n    .dg .cr.string input[type=text] {\n      color: #1ed36f; }\n  .dg .cr.function:hover,\n  .dg .cr.boolean:hover {\n    background: #111; }\n  .dg .c input[type=text] {\n    background: #303030;\n    outline: none; }\n    .dg .c input[type=text]:hover {\n      background: #3c3c3c; }\n    .dg .c input[type=text]:focus {\n      background: #494949;\n      color: #fff; }\n  .dg .c .slider {\n    background: #303030;\n    cursor: ew-resize; }\n  .dg .c .slider-fg {\n    background: #2FA1D6; }\n  .dg .c .slider:hover {\n    background: #3c3c3c; }\n    .dg .c .slider:hover .slider-fg {\n      background: #44abda; }\n", ""])
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            e.__esModule = !0;
            var r = n(10), a = i(r), o = n(13), s = i(o), c = n(14), l = i(c), u = n(11), h = i(u), d = n(20), p = i(d), f = n(8), m = i(f), g = n(5), v = i(g), y = function (t, e) {
                var n = t[e];
                return v.default.isArray(arguments[2]) || v.default.isObject(arguments[2]) ? new a.default(t, e, arguments[2]) : v.default.isNumber(n) ? v.default.isNumber(arguments[2]) && v.default.isNumber(arguments[3]) ? v.default.isNumber(arguments[4]) ? new l.default(t, e, arguments[2], arguments[3], arguments[4]) : new l.default(t, e, arguments[2], arguments[3]) : new s.default(t, e, {
                    min: arguments[2],
                    max: arguments[3]
                }) : v.default.isString(n) ? new h.default(t, e) : v.default.isFunction(n) ? new p.default(t, e, "") : v.default.isBoolean(n) ? new m.default(t, e) : void 0
            };
            e.default = y, t.exports = e.default
        }, function (t, e) {
            "use strict";
            e.__esModule = !0, e.default = function () {
                function t(t) {
                    window.setTimeout(t, 1e3 / 60)
                }

                return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || t
            }, t.exports = e.default
        }, function (t, e, n) {
            "use strict";
            function i(t) {
                return t && t.__esModule ? t : {default: t}
            }

            function r(t, e) {
                if (!(t instanceof e))throw new TypeError("Cannot call a class as a function")
            }

            e.__esModule = !0;
            var a = n(9), o = i(a), s = n(5), c = i(s), l = function () {
                function t() {
                    r(this, t), this.backgroundElement = document.createElement("div"), c.default.extend(this.backgroundElement.style, {
                        backgroundColor: "rgba(0,0,0,0.8)",
                        top: 0,
                        left: 0,
                        display: "none",
                        zIndex: "1000",
                        opacity: 0,
                        WebkitTransition: "opacity 0.2s linear",
                        transition: "opacity 0.2s linear"
                    }), o.default.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), c.default.extend(this.domElement.style, {
                        position: "fixed",
                        display: "none",
                        zIndex: "1001",
                        opacity: 0,
                        WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                        transition: "transform 0.2s ease-out, opacity 0.2s linear"
                    }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                    var e = this;
                    o.default.bind(this.backgroundElement, "click", function () {
                        e.hide()
                    })
                }

                return t.prototype.show = function () {
                    var t = this;
                    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), c.default.defer(function () {
                        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                    })
                }, t.prototype.hide = function t() {
                    var e = this, t = function t() {
                        e.domElement.style.display = "none", e.backgroundElement.style.display = "none", o.default.unbind(e.domElement, "webkitTransitionEnd", t), o.default.unbind(e.domElement, "transitionend", t), o.default.unbind(e.domElement, "oTransitionEnd", t)
                    };
                    o.default.bind(this.domElement, "webkitTransitionEnd", t), o.default.bind(this.domElement, "transitionend", t), o.default.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                }, t.prototype.layout = function () {
                    this.domElement.style.left = window.innerWidth / 2 - o.default.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - o.default.getHeight(this.domElement) / 2 + "px"
                }, t
            }();
            e.default = l, t.exports = e.default
        }])
    })
}, function (t, e) {
    "use strict";
    Object.defineProperty(e, "__esModule", {value: !0}), e.default = {gui: {}, orbit: {}, stats: {}}
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function r(t) {
        if (t && t.__esModule)return t;
        var e = {};
        if (null != t)for (var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e.default = t, e
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var a = n(2), o = r(a), s = n(3), c = i(s), l = n(13), u = i(l), h = n(15)(o);
    e.default = function () {
        u.default.orbit = new h(c.default.camera, c.default.renderer.domElement), u.default.orbit.enableZoom = !0
    }
}, function (t, e) {
    t.exports = function (t) {
        function e(e, n) {
            function i() {
                return 2 * Math.PI / 60 / 60 * U.autoRotateSpeed
            }

            function r() {
                return Math.pow(.95, U.zoomSpeed)
            }

            function a(t) {
                H.theta -= t
            }

            function o(t) {
                H.phi -= t
            }

            function s(e) {
                U.object instanceof t.PerspectiveCamera ? V /= e : U.object instanceof t.OrthographicCamera ? (U.object.zoom = Math.max(U.minZoom, Math.min(U.maxZoom, U.object.zoom * e)), U.object.updateProjectionMatrix(), W = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), U.enableZoom = !1)
            }

            function c(e) {
                U.object instanceof t.PerspectiveCamera ? V *= e : U.object instanceof t.OrthographicCamera ? (U.object.zoom = Math.max(U.minZoom, Math.min(U.maxZoom, U.object.zoom / e)), U.object.updateProjectionMatrix(), W = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), U.enableZoom = !1)
            }

            function l(t) {
                X.set(t.clientX, t.clientY)
            }

            function u(t) {
                K.set(t.clientX, t.clientY)
            }

            function h(t) {
                Z.set(t.clientX, t.clientY)
            }

            function d(t) {
                Y.set(t.clientX, t.clientY), q.subVectors(Y, X);
                var e = U.domElement === document ? U.domElement.body : U.domElement;
                a(2 * Math.PI * q.x / e.clientWidth * U.rotateSpeed), o(2 * Math.PI * q.y / e.clientHeight * U.rotateSpeed), X.copy(Y), U.update()
            }

            function p(t) {
                $.set(t.clientX, t.clientY), tt.subVectors($, K), tt.y > 0 ? s(r()) : tt.y < 0 && c(r()), K.copy($), U.update()
            }

            function f(t) {
                J.set(t.clientX, t.clientY), Q.subVectors(J, Z), it(Q.x, Q.y), Z.copy(J), U.update()
            }

            function m(t) {
            }

            function g(t) {
                t.deltaY < 0 ? c(r()) : t.deltaY > 0 && s(r()), U.update()
            }

            function v(t) {
                switch (t.keyCode) {
                    case U.keys.UP:
                        it(0, U.keyPanSpeed), U.update();
                        break;
                    case U.keys.BOTTOM:
                        it(0, -U.keyPanSpeed), U.update();
                        break;
                    case U.keys.LEFT:
                        it(U.keyPanSpeed, 0), U.update();
                        break;
                    case U.keys.RIGHT:
                        it(-U.keyPanSpeed, 0), U.update()
                }
            }

            function y(t) {
                X.set(t.touches[0].pageX, t.touches[0].pageY)
            }

            function _(t) {
                var e = t.touches[0].pageX - t.touches[1].pageX, n = t.touches[0].pageY - t.touches[1].pageY, i = Math.sqrt(e * e + n * n);
                K.set(0, i)
            }

            function x(t) {
                Z.set(t.touches[0].pageX, t.touches[0].pageY)
            }

            function b(t) {
                Y.set(t.touches[0].pageX, t.touches[0].pageY), q.subVectors(Y, X);
                var e = U.domElement === document ? U.domElement.body : U.domElement;
                a(2 * Math.PI * q.x / e.clientWidth * U.rotateSpeed), o(2 * Math.PI * q.y / e.clientHeight * U.rotateSpeed), X.copy(Y), U.update()
            }

            function w(t) {
                var e = t.touches[0].pageX - t.touches[1].pageX, n = t.touches[0].pageY - t.touches[1].pageY, i = Math.sqrt(e * e + n * n);
                $.set(0, i), tt.subVectors($, K), tt.y > 0 ? c(r()) : tt.y < 0 && s(r()), K.copy($), U.update()
            }

            function M(t) {
                J.set(t.touches[0].pageX, t.touches[0].pageY), Q.subVectors(J, Z), it(Q.x, Q.y), Z.copy(J), U.update()
            }

            function E(t) {
            }

            function T(t) {
                if (U.enabled !== !1) {
                    if (t.preventDefault(), t.button === U.mouseButtons.ORBIT) {
                        if (U.enableRotate === !1)return;
                        l(t), z = B.ROTATE
                    } else if (t.button === U.mouseButtons.ZOOM) {
                        if (U.enableZoom === !1)return;
                        u(t), z = B.DOLLY
                    } else if (t.button === U.mouseButtons.PAN) {
                        if (U.enablePan === !1)return;
                        h(t), z = B.PAN
                    }
                    z !== B.NONE && (document.addEventListener("mousemove", S, !1), document.addEventListener("mouseup", A, !1), U.dispatchEvent(D))
                }
            }

            function S(t) {
                if (U.enabled !== !1)if (t.preventDefault(), z === B.ROTATE) {
                    if (U.enableRotate === !1)return;
                    d(t)
                } else if (z === B.DOLLY) {
                    if (U.enableZoom === !1)return;
                    p(t)
                } else if (z === B.PAN) {
                    if (U.enablePan === !1)return;
                    f(t)
                }
            }

            function A(t) {
                U.enabled !== !1 && (m(t), document.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", A, !1), U.dispatchEvent(F), z = B.NONE)
            }

            function L(t) {
                U.enabled === !1 || U.enableZoom === !1 || z !== B.NONE && z !== B.ROTATE || (t.preventDefault(), t.stopPropagation(), g(t), U.dispatchEvent(D), U.dispatchEvent(F))
            }

            function R(t) {
                U.enabled !== !1 && U.enableKeys !== !1 && U.enablePan !== !1 && v(t)
            }

            function C(t) {
                if (U.enabled !== !1) {
                    switch (t.touches.length) {
                        case 1:
                            if (U.enableRotate === !1)return;
                            y(t), z = B.TOUCH_ROTATE;
                            break;
                        case 2:
                            if (U.enableZoom === !1)return;
                            _(t), z = B.TOUCH_DOLLY;
                            break;
                        case 3:
                            if (U.enablePan === !1)return;
                            x(t), z = B.TOUCH_PAN;
                            break;
                        default:
                            z = B.NONE
                    }
                    z !== B.NONE && U.dispatchEvent(D)
                }
            }

            function P(t) {
                if (U.enabled !== !1)switch (t.preventDefault(), t.stopPropagation(), t.touches.length) {
                    case 1:
                        if (U.enableRotate === !1)return;
                        if (z !== B.TOUCH_ROTATE)return;
                        b(t);
                        break;
                    case 2:
                        if (U.enableZoom === !1)return;
                        if (z !== B.TOUCH_DOLLY)return;
                        w(t);
                        break;
                    case 3:
                        if (U.enablePan === !1)return;
                        if (z !== B.TOUCH_PAN)return;
                        M(t);
                        break;
                    default:
                        z = B.NONE
                }
            }

            function O(t) {
                U.enabled !== !1 && (E(t), U.dispatchEvent(F), z = B.NONE)
            }

            function I(t) {
                t.preventDefault()
            }

            this.object = e, this.domElement = void 0 !== n ? n : document, this.enabled = !0, this.target = new t.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -(1 / 0), this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            }, this.mouseButtons = {
                ORBIT: t.MOUSE.LEFT,
                ZOOM: t.MOUSE.MIDDLE,
                PAN: t.MOUSE.RIGHT
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () {
                return k.phi
            }, this.getAzimuthalAngle = function () {
                return k.theta
            }, this.reset = function () {
                U.target.copy(U.target0), U.object.position.copy(U.position0), U.object.zoom = U.zoom0, U.object.updateProjectionMatrix(), U.dispatchEvent(N), U.update(), z = B.NONE
            }, this.update = function () {
                var n = new t.Vector3, r = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)), o = r.clone().inverse(), s = new t.Vector3, c = new t.Quaternion;
                return function () {
                    var t = U.object.position;
                    return n.copy(t).sub(U.target), n.applyQuaternion(r), k.setFromVector3(n), U.autoRotate && z === B.NONE && a(i()), k.theta += H.theta, k.phi += H.phi, k.theta = Math.max(U.minAzimuthAngle, Math.min(U.maxAzimuthAngle, k.theta)), k.phi = Math.max(U.minPolarAngle, Math.min(U.maxPolarAngle, k.phi)), k.makeSafe(), k.radius *= V, k.radius = Math.max(U.minDistance, Math.min(U.maxDistance, k.radius)), U.target.add(j), n.setFromSpherical(k), n.applyQuaternion(o), t.copy(U.target).add(n), U.object.lookAt(U.target), U.enableDamping === !0 ? (H.theta *= 1 - U.dampingFactor, H.phi *= 1 - U.dampingFactor) : H.set(0, 0, 0), V = 1, j.set(0, 0, 0), !!(W || s.distanceToSquared(U.object.position) > G || 8 * (1 - c.dot(U.object.quaternion)) > G) && (U.dispatchEvent(N), s.copy(U.object.position), c.copy(U.object.quaternion), W = !1, !0)
                }
            }(), this.dispose = function () {
                U.domElement.removeEventListener("contextmenu", I, !1), U.domElement.removeEventListener("mousedown", T, !1), U.domElement.removeEventListener("wheel", L, !1), U.domElement.removeEventListener("touchstart", C, !1), U.domElement.removeEventListener("touchend", O, !1), U.domElement.removeEventListener("touchmove", P, !1), document.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", A, !1), window.removeEventListener("keydown", R, !1)
            };
            var U = this, N = {type: "change"}, D = {type: "start"}, F = {type: "end"}, B = {
                NONE: -1,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2,
                TOUCH_ROTATE: 3,
                TOUCH_DOLLY: 4,
                TOUCH_PAN: 5
            }, z = B.NONE, G = 1e-6, k = new t.Spherical, H = new t.Spherical, V = 1, j = new t.Vector3, W = !1, X = new t.Vector2, Y = new t.Vector2, q = new t.Vector2, Z = new t.Vector2, J = new t.Vector2, Q = new t.Vector2, K = new t.Vector2, $ = new t.Vector2, tt = new t.Vector2, et = function () {
                var e = new t.Vector3;
                return function (t, n) {
                    e.setFromMatrixColumn(n, 0), e.multiplyScalar(-t), j.add(e)
                }
            }(), nt = function () {
                var e = new t.Vector3;
                return function (t, n) {
                    e.setFromMatrixColumn(n, 1), e.multiplyScalar(t), j.add(e)
                }
            }(), it = function () {
                var e = new t.Vector3;
                return function (n, i) {
                    var r = U.domElement === document ? U.domElement.body : U.domElement;
                    if (U.object instanceof t.PerspectiveCamera) {
                        var a = U.object.position;
                        e.copy(a).sub(U.target);
                        var o = e.length();
                        o *= Math.tan(U.object.fov / 2 * Math.PI / 180), et(2 * n * o / r.clientHeight, U.object.matrix), nt(2 * i * o / r.clientHeight, U.object.matrix)
                    } else U.object instanceof t.OrthographicCamera ? (et(n * (U.object.right - U.object.left) / U.object.zoom / r.clientWidth, U.object.matrix), nt(i * (U.object.top - U.object.bottom) / U.object.zoom / r.clientHeight, U.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), U.enablePan = !1)
                }
            }();
            U.domElement.addEventListener("contextmenu", I, !1), U.domElement.addEventListener("mousedown", T, !1), U.domElement.addEventListener("wheel", L, !1), U.domElement.addEventListener("touchstart", C, !1), U.domElement.addEventListener("touchend", O, !1), U.domElement.addEventListener("touchmove", P, !1), window.addEventListener("keydown", R, !1), this.update()
        }

        return e.prototype = Object.create(t.EventDispatcher.prototype), e.prototype.constructor = e, Object.defineProperties(e.prototype, {
            center: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
                }
            }, noZoom: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
                }, set: function (t) {
                    console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !t
                }
            }, noRotate: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
                }, set: function (t) {
                    console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !t
                }
            }, noPan: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
                }, set: function (t) {
                    console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !t
                }
            }, noKeys: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
                }, set: function (t) {
                    console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !t
                }
            }, staticMoving: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
                }, set: function (t) {
                    console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !t
                }
            }, dynamicDampingFactor: {
                get: function () {
                    return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
                }, set: function (t) {
                    console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = t
                }
            }
        }), e
    }
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    Object.defineProperty(e, "__esModule", {value: !0});
    var r = n(17), a = i(r), o = n(13), s = i(o);
    e.default = function () {
        s.default.stats = new a.default, s.default.stats.showPanel(0), document.body.appendChild(s.default.stats.dom)
    }
}, function (t, e, n) {
    !function (e, n) {
        t.exports = n()
    }(this, function () {
        var t = function () {
            function e(t) {
                return r.appendChild(t.dom), t
            }

            function n(t) {
                for (var e = 0; e < r.children.length; e++)r.children[e].style.display = e === t ? "block" : "none";
                i = t
            }

            var i = 0, r = document.createElement("div");
            r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function (t) {
                t.preventDefault(), n(++i % r.children.length)
            }, !1);
            var a = (performance || Date).now(), o = a, s = 0, c = e(new t.Panel("FPS", "#0ff", "#002")), l = e(new t.Panel("MS", "#0f0", "#020"));
            if (self.performance && self.performance.memory)var u = e(new t.Panel("MB", "#f08", "#201"));
            return n(0), {
                REVISION: 16, dom: r, addPanel: e, showPanel: n, begin: function () {
                    a = (performance || Date).now()
                }, end: function () {
                    s++;
                    var t = (performance || Date).now();
                    if (l.update(t - a, 200), t > o + 1e3 && (c.update(1e3 * s / (t - o), 100), o = t, s = 0, u)) {
                        var e = performance.memory;
                        u.update(e.usedJSHeapSize / 1048576, e.jsHeapSizeLimit / 1048576)
                    }
                    return t
                }, update: function () {
                    a = this.end()
                }, domElement: r, setMode: n
            }
        };
        return t.Panel = function (t, e, n) {
            var i = 1 / 0, r = 0, a = Math.round, o = a(window.devicePixelRatio || 1), s = 80 * o, c = 48 * o, l = 3 * o, u = 2 * o, h = 3 * o, d = 15 * o, p = 74 * o, f = 30 * o, m = document.createElement("canvas");
            m.width = s, m.height = c, m.style.cssText = "width:80px;height:48px";
            var g = m.getContext("2d");
            return g.font = "bold " + 9 * o + "px Helvetica,Arial,sans-serif",
                g.textBaseline = "top", g.fillStyle = n, g.fillRect(0, 0, s, c), g.fillStyle = e, g.fillText(t, l, u), g.fillRect(h, d, p, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h, d, p, f), {
                dom: m,
                update: function (c, v) {
                    i = Math.min(i, c), r = Math.max(r, c), g.fillStyle = n, g.globalAlpha = 1, g.fillRect(0, 0, s, d), g.fillStyle = e, g.fillText(a(c) + " " + t + " (" + a(i) + "-" + a(r) + ")", l, u), g.drawImage(m, h + o, d, p - o, f, h, d, p - o, f), g.fillRect(h + p - o, d, o, f), g.fillStyle = n, g.globalAlpha = .9, g.fillRect(h + p - o, d, o, a((1 - c / v) * f))
                }
            }
        }, t
    })
}, function (t, e, n) {
    "use strict";
    function i(t) {
        return t && t.__esModule ? t : {default: t}
    }

    function r() {
        c.default.user.stats && u.default.stats.begin(), c.default.backgroundColor !== !1 && o.default.renderer.setClearColor(c.default.backgroundColor), p(), c.default.user.stats && u.default.stats.end(), requestAnimationFrame(r), o.default.renderer.render(o.default.scene, o.default.camera), o.default.capturer && o.default.capturer.capture(o.default.renderer.domElement)
    }

    Object.defineProperty(e, "__esModule", {value: !0}), e.resize = void 0, e.default = r;
    var a = n(3), o = i(a), s = n(4), c = i(s), l = n(13), u = i(l), h = n(8), d = i(h), p = function () {
        d.default.uProgress.value >= 1 ? d.default.uProgress.value = 0 : d.default.uProgress.value += .003
    }, f = e.resize = function () {
        o.default.camera.aspect = window.innerWidth / window.innerHeight, o.default.camera.updateProjectionMatrix(), o.default.renderer.setSize(window.innerWidth, window.innerHeight)
    };
    window.addEventListener("resize", f, !1)
}]);